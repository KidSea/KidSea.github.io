<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Android语言切换原理]]></title>
    <url>%2F2017%2F11%2F19%2FAndroid%E8%AF%AD%E8%A8%80%E5%88%87%E6%8D%A2%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[Android语言切换原理前言&#160;&#160;&#160;之前因为系统有些国家使用的字体乱码的原因，研究了下Android系统字体加载相关的知识，写了一篇Android系统字体加载流程的总结，浅析Android字体加载原理，然而系统的字体与系统当前的语言有密切的关系，因此抽空了解了下Android系统语言切换的流程，写下总结，加深印象。 Android语言切换流程分析概述&#160;&#160;&#160;有过Android开发经验的人，应该都知道Android有一套成熟的国际化机制，通常应用或系统要走出海外，都要进行国际化适配，而Android语言切换依赖于国际化适配，但这里，我们不深入了解Android国际化的原理，有兴趣的读者可以自行Google或者百度，下面对Android语言切换流程进行分析。 Android多语言描述&#160;&#160;&#160;有关Android系统本地化的介绍，请查看官网，本地化。 &#160;&#160;&#160;对于Android语言切换接口，在Android 6.0及以前的语言设置都是单一的语言，只能选一种语言，见下图。 &#160;&#160;&#160;Android7.0系统以上，则是更人性化了，允许用户在设置中选择多个语言，如下图，用户可以根据自己的喜好选择语言列表，并将默认的语言拖拽到首项，设为系统默认语言。 &#160;&#160;&#160;这么做的目的是为了一些国家使用多种语言，比如印度，印度语是第一母语，英语则为其第二母语，这样的话，在系统捏添加这两个语言后，会加载相应的语言资源，当第一语言没有相应资源时，会去第二语言中查找，而7.0以下的系统就只能加载一种语言下的资源文件，存在很大的限制，这里就不做扩展，有兴趣的读者可以自行了解。 Android多语言切换&#160;&#160;&#160;如上所述，Android在不同的系统版本为用户提供不同的语言切换功能，因此在切换流程过中，调用的接口也不同，如Android6.0及以下，设置切换语言的接口调用的是updateLocale(Locale locale)，如Android7.0以上，设置切换语言的接口调用的是updateLocales(LocaleList locales)，但是大致的流程还是保持一致，多的只是文件存放位置的变化，下面笔者将以Android7.0的流程进行分析，7.0以下的，读者可自行分析。 注：从上面的两个接口，也可以看出，高版本系统与低版本系统加载语言的区别，前者是加载多个语言的列表，后者是加载一个语言。 &#160;&#160;&#160;如上所述，当用户在设置中选择对应的语言后，Android会首先调frameworks/base/com/android/internal/app/LocalePicker.java中的updateLocales(LocaleList locales)方法。 注：如果你不想用Android7.0以上的语言切换功能，可以考虑自己实现updateLocale(Locale locale)方法。 12345678910111213141516171819202122232425/** * Requests the system to update the list of system locales. * Note that the system looks halted for a while during the Locale migration, * so the caller need to take care of it. */public static void updateLocales(LocaleList locales) &#123; try &#123; //获取am final IActivityManager am = ActivityManagerNative.getDefault(); //获取am配置对象 final Configuration config = am.getConfiguration(); //为配置对象重新设置语言 config.setLocales(locales); //重置标志位 config.userSetLocale = true; am.updatePersistentConfiguration(config); // Trigger the dirty bit for the Settings Provider. BackupManager.dataChanged("com.android.providers.settings"); &#125; catch (RemoteException e) &#123; // Intentionally left blank &#125;&#125; &#160;&#160;&#160;Google对该方法的介绍是，当更新系统语言列表的时候，就会调用这个方法。从上方展示的源码来看,该方法首先会调用ActivityManagerNative.getDefault()来获取ActivityManagerServices(以下简称AMS)在本地的代理，从而调用AMS中的updatePersistentConfiguration()并传入创建好的配置对象(Configuration)。 注：这里是ActivityManagerNative使用远程代理通过Binder条用AMS的同名方法，由于Android的代理机制十分复杂，这里不继续介绍Android代理机制。 12345678910111213141516171819@Overridepublic void updatePersistentConfiguration(Configuration values) &#123; //强制权限校验 enforceCallingPermission(android.Manifest.permission.CHANGE_CONFIGURATION, "updateConfiguration()"); //强制写入设置权限 enforceWriteSettingsPermission("updateConfiguration()"); if (values == null) &#123; throw new NullPointerException("Configuration must not be null"); &#125; //获取调用用户的ID int userId = UserHandle.getCallingUserId(); synchronized(this) &#123; //调用方法 updatePersistentConfigurationLocked(values, userId); &#125;&#125; &#160;&#160;&#160;可以看出，该方法首先进行了权限校验，权限赋予，然后调用updatePersistentConfigurationLocked()方法，继续看下这个方法。 1234567891011private void updatePersistentConfigurationLocked(Configuration values, @UserIdInt int userId) &#123; //清除Binder调用标识 final long origId = Binder.clearCallingIdentity(); try &#123; //重要方法 updateConfigurationLocked(values, null, false, true, userId, false /* deferResume */); &#125; finally &#123; Binder.restoreCallingIdentity(origId); &#125;&#125; &#160;&#160;&#160;这个方法只是清除了Binder标识，并调用了updateConfigurationLocked()方法，该方法非常重要，注意这里的传参，继续往下看。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384/** * Do either or both things: (1) change the current configuration, and (2) * make sure the given activity is running with the (now) current * configuration. Returns true if the activity has been left running, or * false if &lt;var&gt;starting&lt;/var&gt; is being destroyed to match the new * configuration. * * @param userId is only used when persistent parameter is set to true to persist configuration * for that particular user */private boolean updateConfigurationLocked(Configuration values, ActivityRecord starting, boolean initLocale, boolean persistent, int userId, boolean deferResume) &#123; int changes = 0; ... if (values != null) &#123; Configuration newConfig = new Configuration(mConfiguration); changes = newConfig.updateFrom(values); if (changes != 0) &#123; if (DEBUG_SWITCH || DEBUG_CONFIGURATION) Slog.i(TAG_CONFIGURATION, "Updating configuration to: " + values); EventLog.writeEvent(EventLogTags.CONFIGURATION_CHANGED, changes); if (!initLocale &amp;&amp; !values.getLocales().isEmpty() &amp;&amp; values.userSetLocale) &#123; //得到选择的国家语言列表 final LocaleList locales = values.getLocales(); int bestLocaleIndex = 0; if (locales.size() &gt; 1) &#123; if (mSupportedSystemLocales == null) &#123; //获取系统支持国家语言列表 mSupportedSystemLocales = Resources.getSystem().getAssets().getLocales(); &#125; //匹配国家，获取选择默认国家语言下标 bestLocaleIndex = Math.max(0, locales.getFirstMatchIndex(mSupportedSystemLocales)); &#125; SystemProperties.set("persist.sys.locale", locales.get(bestLocaleIndex).toLanguageTag()); //设置为选择的国家语言为默认国家语言 LocaleList.setDefault(locales, bestLocaleIndex); //发送消息通知挂载守护进程国家语言变更 mHandler.sendMessage(mHandler.obtainMessage(SEND_LOCALE_TO_MOUNT_DAEMON_MSG, locales.get(bestLocaleIndex))); &#125; ... // Make sure all resources in our process are updated // right now, so that anyone who is going to retrieve // resource values after we return will be sure to get // the new ones. This is especially important during // boot, where the first config change needs to guarantee // all resources have that config before following boot // code is executed. //更新资源配置 mSystemThread.applyConfigurationToResources(configCopy); //如果有配置改动，就发送该消息通知配置改动 if (persistent &amp;&amp; Settings.System.hasInterestingConfigurationChanges(changes)) &#123; Message msg = mHandler.obtainMessage(UPDATE_CONFIGURATION_MSG); msg.obj = new Configuration(configCopy); msg.arg1 = userId; mHandler.sendMessage(msg); &#125; ... for (int i=mLruProcesses.size()-1; i&gt;=0; i--) &#123; ProcessRecord app = mLruProcesses.get(i); try &#123; if (app.thread != null) &#123; if (DEBUG_CONFIGURATION) Slog.v(TAG_CONFIGURATION, "Sending to proc " + app.processName + " new config " + mConfiguration); app.thread.scheduleConfigurationChanged(configCopy); &#125; &#125; catch (Exception e) &#123; &#125; &#125; ... &#125; &#160;&#160;&#160;从Google给的注释说明可以看到，这个方法的最重要的作用如下： 更新当前系统的配置到最新的配置； 保证所有的Activity都能更新到改变后的配置。 注：在更新或者清除configuration时，是通过changes位标记法来确认是configuration中的哪一项。 &#160;&#160;&#160;继续来看Android是如何进行配置更新的。首先调用updateFrom()，方法来更新配置，我们先看看这个方法。 1234567891011121314151617181920212223242526272829303132333435363738/** * Copies the fields from delta into this Configuration object, keeping * track of which ones have changed. Any undefined fields in &#123;@code delta&#125; * are ignored and not copied in to the current Configuration. * * @return a bit mask of the changed fields, as per &#123;@link #diff&#125; */public @Config int updateFrom(@NonNull Configuration delta) &#123; //变化项 int changed = 0; ... //当有语言列表变化时，走这 if (!delta.mLocaleList.isEmpty() &amp;&amp; !mLocaleList.equals(delta.mLocaleList)) &#123; changed |= ActivityInfo.CONFIG_LOCALE; mLocaleList = delta.mLocaleList; // delta.locale can't be null, since delta.mLocaleList is not empty. if (!delta.locale.equals(locale)) &#123; locale = (Locale) delta.locale.clone(); // If locale has changed, then layout direction is also changed ... changed |= ActivityInfo.CONFIG_LAYOUT_DIRECTION; // ... and we need to update the layout direction (represented by the first // 2 most significant bits in screenLayout). setLayoutDirection(locale); &#125; &#125; ... if (delta.userSetLocale &amp;&amp; (!userSetLocale || ((changed &amp; ActivityInfo.CONFIG_LOCALE) != 0))) &#123; changed |= ActivityInfo.CONFIG_LOCALE; userSetLocale = true; &#125; return changed;&#125; &#160;&#160;&#160;从以上可以看到，当我们修改了语言列表，那么返回的变化项change一定大于0。继续回到updateConfigurationLocked()方法中，由于change不为0，并且根据前面的传参，updateConfigurationLocked()方法将从变更的国家语言列表中获取默认国家语言下标，然后设置默认国家语言以及默认国家列表，并发送消息通知挂载守护进程国家语言的变化，其中设置默认情况的代码如下。 123456789101112131415161718192021222324252627282930//设置默认国家语言以及国家语言列表/** * This may be used directly by system processes to set the default locale list for apps. For * such uses, the default locale list would always come from the user preferences, but the * default locale may have been chosen to be a locale other than the first locale in the locale * list (based on the locales the app supports). * * &#123;@hide&#125; */public static void setDefault(@NonNull @Size(min=1) LocaleList locales, int localeIndex) &#123; if (locales == null) &#123; throw new NullPointerException("locales is null"); &#125; if (locales.isEmpty()) &#123; throw new IllegalArgumentException("locales is empty"); &#125; synchronized (sLock) &#123; sLastDefaultLocale = locales.get(localeIndex); Locale.setDefault(sLastDefaultLocale); sLastExplicitlySetLocaleList = locales; sDefaultLocaleList = locales; if (localeIndex == 0) &#123; sDefaultAdjustedLocaleList = sDefaultLocaleList; &#125; else &#123; sDefaultAdjustedLocaleList = new LocaleList( sLastDefaultLocale, sDefaultLocaleList); &#125; &#125;&#125; &#160;&#160;&#160;再此之后，系统进程会首先通知Configuration改变，所以mSystemThread即系统的ActivityThread类对象调用applyConfigurationToResources()确保自己所在的进程资源更新到最新(主要指framework-res.apk中的资源，也就是上面所说的updateConfigurationLocked()方法的第一个重要作用)，以便任何人检索资源的时候拿到的都是最新的资源，然后发送通知更新用户配置。 注：这里是系统更新配置资源，后面将对pplyConfigurationToResources()方法进行描述。 1234567891011121314151617// Make sure all resources in our process are updated// right now, so that anyone who is going to retrieve// resource values after we return will be sure to get// the new ones. This is especially important during// boot, where the first config change needs to guarantee// all resources have that config before following boot// code is executed.//更新资源配置mSystemThread.applyConfigurationToResources(configCopy);//如果有配置改动，就发送该消息通知配置改动if (persistent &amp;&amp; Settings.System.hasInterestingConfigurationChanges(changes)) &#123; Message msg = mHandler.obtainMessage(UPDATE_CONFIGURATION_MSG); msg.obj = new Configuration(configCopy); msg.arg1 = userId; mHandler.sendMessage(msg);&#125; &#160;&#160;&#160;继续往下看，以下是遍历每个应用，通知其配置的改变。 123456789101112131415161718192021222324//保存所有应用的进程final ArrayList&lt;ProcessRecord&gt; mLruProcesses = new ArrayList&lt;ProcessRecord&gt;();for (int i=mLruProcesses.size()-1; i&gt;=0; i--) &#123; ProcessRecord app = mLruProcesses.get(i); try &#123; if (app.thread != null) &#123; if (DEBUG_CONFIGURATION) Slog.v(TAG_CONFIGURATION, "Sending to proc " + app.processName + " new config " + mConfiguration); app.thread.scheduleConfigurationChanged(configCopy); &#125; &#125; catch (Exception e) &#123; &#125;&#125;public final void scheduleConfigurationChanged(Configuration config) throws RemoteException &#123; Parcel data = Parcel.obtain(); data.writeInterfaceToken(IApplicationThread.descriptor); config.writeToParcel(data, 0); mRemote.transact(SCHEDULE_CONFIGURATION_CHANGED_TRANSACTION, data, null, IBinder.FLAG_ONEWAY); data.recycle();&#125; &#160;&#160;&#160;可以看到，mLruProcesses中保存的是所有运行的进程，Android中，每个应用运行时都对应于一个进程，因此这里包含了所有运行的应用。我们注意到这里循环调用了app.thread.scheduleConfigurationChanged(configCopy)，app.thread对应于每个应用的线程，其作用是通知各个应用进程Configuration改变。跳转后会发现，这里其实又是通过binder调用跨进程方法，在这里是调用ActivityThread.java中私有ApplicationThread的方法，查看该方法。 注：ApplicationThread是ActivityThread的内部类，也是一个Binder对象，这边用以等待AMS发送消息。 123456789101112131415161718public void scheduleConfigurationChanged(Configuration config) &#123; updatePendingConfiguration(config); //发送消息给对应的主线程 sendMessage(H.CONFIGURATION_CHANGED, config);&#125;...case CONFIGURATION_CHANGED: Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, "configChanged"); mCurDefaultDisplayDpi = ((Configuration)msg.obj).densityDpi; mUpdatingSystemConfig = true; //接收到AMS发来的数据 handleConfigurationChanged((Configuration)msg.obj, null); mUpdatingSystemConfig = false; Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER); break; &#160;&#160;&#160;这里ApplicationThread接收到AMS的信息后，会发送消息CONFIGURATION_CHANGED给对应应用的ActivityThread。ActivityThread收到CONFIGURATION_CHANGED消息后，其会调用handleConfigurationChanged()方法。 1234567891011121314151617181920212223242526272829303132333435363738final void handleConfigurationChanged(Configuration config, CompatibilityInfo compat) &#123; int configDiff = 0; synchronized (mResourcesManager) &#123; ... //将资源配置修改应用到资源中 mResourcesManager.applyConfigurationToResourcesLocked(config, compat); //更新语言列表 updateLocaleListFromAppContext(mInitialApplication.getApplicationContext(), mResourcesManager.getConfiguration().getLocales()); ... &#125; //组件修改回调对象 ArrayList&lt;ComponentCallbacks2&gt; callbacks = collectComponentCallbacks(false, config); freeTextLayoutCachesIfNeeded(configDiff); if (callbacks != null) &#123;framework-res.apk final int N = callbacks.size(); for (int i=0; i&lt;N; i++) &#123; ComponentCallbacks2 cb = callbacks.get(i); if (cb instanceof Activity) &#123; // If callback is an Activity - call corresponding method to consider override // config and avoid onConfigurationChanged if it hasn't changed. Activity a = (Activity) cb; //Activity回调响应 performConfigurationChangedForActivity(mActivities.get(a.getActivityToken()), config, REPORT_TO_ACTIVITY); &#125; else &#123; //其他回调响应 performConfigurationChanged(cb, null, config, null, REPORT_TO_ACTIVITY); &#125; &#125; &#125;&#125; &#160;&#160;&#160;在handleConfigurationChanged()方法中，也会调用applyConfigurationToResourcesLocked()方法，去更新每个应用的配置资源(也就是上述updateConfigurationLocked()方法的第二个重要作用)。 &#160;&#160;&#160;也就是说，不管是系统资源还是应用资源的更新都要调用applyConfigurationToResourcesLocked()方法。按字面意思，大概的作用就是将资源配置修改应用到资源中，而资源文件就包含语言资源文件、图片资源、布局资源等，查看其代码。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public final boolean applyConfigurationToResourcesLocked(@NonNull Configuration config, @Nullable CompatibilityInfo compat) &#123; private final ArrayMap&lt;ResourcesKey, WeakReference&lt;ResourcesImpl&gt;&gt; mResourceImpls = new ArrayMap&lt;&gt;(); try &#123; ... //获取更新项 int changes = mResConfiguration.updateFrom(config); // Things might have changed in display manager, so clear the cached displays. mDisplays.clear(); ... //更新系统资源配置 Resources.updateSystemConfiguration(config, defaultDisplayMetrics, compat); //通知配置文件修改,清理缓存，如Icon和String ApplicationPackageManager.configurationChanged(); //Slog.i(TAG, "Configuration changed in " + currentPackageName()); Configuration tmpConfig = null; for (int i = mResourceImpls.size() - 1; i &gt;= 0; i--) &#123; ResourcesKey key = mResourceImpls.keyAt(i); ResourcesImpl r = mResourceImpls.valueAt(i).get(); if (r != null) &#123; ... r.updateConfiguration(tmpConfig, dm, compat); &#125; else &#123; r.updateConfiguration(config, dm, compat); &#125; //Slog.i(TAG, "Updated app resources " + v.getKey() // + " " + r + ": " + r.getConfiguration()); &#125; else &#123; //Slog.i(TAG, "Removing old resources " + v.getKey()); mResourceImpls.removeAt(i); &#125; &#125; return changes != 0; &#125; finally &#123; Trace.traceEnd(Trace.TRACE_TAG_RESOURCES); &#125;&#125; &#160;&#160;&#160;按照上面的说法，系统进程以及应用进程会分别调用applyConfigurationToResourcesLocked()方法来更新配置。 &#160;&#160;&#160;当系统进程执行该方法时，Resources.updateSystemConfiguration()会更新系统资源配置(frameworks-res.apk)，在执行完ApplicationPackageManager.configurationChanged()方法后，会清除进程的资源缓存，如Icon与String，并移除其他旧的资源，最终加载新的系统资源。 注：这里并未对更新细节进行详细描述，如有兴趣可以自行研究下。 &#160;&#160;&#160;当应用进程执行该方法时，会通知应用进程更新资源配置，并且实现ComponentCallbacks2接口的组件，如Activity、Services、Application等会被记录，并在handleConfigurationChanged()中被遍历回调通知更新资源配置，因此我们再回到handleConfigurationChanged()方法中。 12345678910111213141516171819202122//组件修改回调对象ArrayList&lt;ComponentCallbacks2&gt; callbacks = collectComponentCallbacks(false, config);freeTextLayoutCachesIfNeeded(configDiff);if (callbacks != null) &#123; final int N = callbacks.size(); for (int i=0; i&lt;N; i++) &#123; ComponentCallbacks2 cb = callbacks.get(i); if (cb instanceof Activity) &#123; // If callback is an Activity - call corresponding method to consider override // config and avoid onConfigurationChanged if it hasn't changed. Activity a = (Activity) cb; //Activity回调响应 performConfigurationChangedForActivity(mActivities.get(a.getActivityToken()), config, REPORT_TO_ACTIVITY); &#125; else &#123; //其他回调响应 performConfigurationChanged(cb, null, config, null, REPORT_TO_ACTIVITY); &#125; &#125;&#125; &#160;&#160;&#160;从上面可以看出，在回调中，如果是Activity，则回调performConfigurationChangedForActivity()方法，如果是Services、Application等，回调performConfigurationChanged()方法，按注释解释，这样做是为了Activity在更新配置时重写配置和避免没有修改时回调onConfigurationChanged()方法，但不管是什么组件，最终都是调用performConfigurationChanged()方法，我们来具体看下这个方法。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879private void performConfigurationChanged(ComponentCallbacks2 cb, IBinder activityToken, Configuration newConfig, Configuration amOverrideConfig, boolean reportToActivity) &#123; // Only for Activity objects, check that they actually call up to their // superclass implementation. ComponentCallbacks2 is an interface, so // we check the runtime type and act accordingly. Activity activity = (cb instanceof Activity) ? (Activity) cb : null; if (activity != null) &#123; activity.mCalled = false; &#125; boolean shouldChangeConfig = false; if ((activity == null) || (activity.mCurrentConfig == null)) &#123; shouldChangeConfig = true; &#125; else &#123; // If the new config is the same as the config this Activity is already // running with and the override config also didn't change, then don't // bother calling onConfigurationChanged. int diff = activity.mCurrentConfig.diff(newConfig); if (diff != 0 || !mResourcesManager.isSameResourcesOverrideConfig(activityToken, amOverrideConfig)) &#123; // Always send the task-level config changes. For system-level configuration, if // this activity doesn't handle any of the config changes, then don't bother // calling onConfigurationChanged as we're going to destroy it. if (!mUpdatingSystemConfig || (~activity.mActivityInfo.getRealConfigChanged() &amp; diff) == 0 || !reportToActivity) &#123; shouldChangeConfig = true; &#125; &#125; &#125; if (shouldChangeConfig) &#123; // Propagate the configuration change to the Activity and ResourcesManager. // ContextThemeWrappers may override the configuration for that context. // We must check and apply any overrides defined. Configuration contextThemeWrapperOverrideConfig = null; if (cb instanceof ContextThemeWrapper) &#123; final ContextThemeWrapper contextThemeWrapper = (ContextThemeWrapper) cb; contextThemeWrapperOverrideConfig = contextThemeWrapper.getOverrideConfiguration(); &#125; // We only update an Activity's configuration if this is not a global // configuration change. This must also be done before the callback, // or else we violate the contract that the new resources are available // in &#123;@link ComponentCallbacks2#onConfigurationChanged(Configuration)&#125;. if (activityToken != null) &#123; // Apply the ContextThemeWrapper override if necessary. // NOTE: Make sure the configurations are not modified, as they are treated // as immutable in many places. final Configuration finalOverrideConfig = createNewConfigAndUpdateIfNotNull( amOverrideConfig, contextThemeWrapperOverrideConfig); mResourcesManager.updateResourcesForActivity(activityToken, finalOverrideConfig); &#125; if (reportToActivity) &#123; // Apply the ContextThemeWrapper override if necessary. // NOTE: Make sure the configurations are not modified, as they are treated // as immutable in many places. final Configuration configToReport = createNewConfigAndUpdateIfNotNull( newConfig, contextThemeWrapperOverrideConfig); cb.onConfigurationChanged(configToReport); &#125; if (activity != null) &#123; if (reportToActivity &amp;&amp; !activity.mCalled) &#123; throw new SuperNotCalledException( "Activity " + activity.getLocalClassName() + " did not call through to super.onConfigurationChanged()"); &#125; activity.mConfigChangeFlags = 0; activity.mCurrentConfig = new Configuration(newConfig); &#125; &#125;&#125; &#160;&#160;&#160;从上面代码注释，可以看到，只有Activity组件才会实现这个方法，并且只有当配置修改不是全局时，Activity会在回调前调用updateResourcesForActivity()方法来更新配置资源，最后回调onConfigurationChanged()方法。 12345678910111213141516171819202122232425262728293031323334/** * Called by the system when the device configuration changes while your * activity is running. Note that this will &lt;em&gt;only&lt;/em&gt; be called if * you have selected configurations you would like to handle with the * &#123;@link android.R.attr#configChanges&#125; attribute in your manifest. If * any configuration change occurs that is not selected to be reported * by that attribute, then instead of reporting it the system will stop * and restart the activity (to have it launched with the new * configuration). * &lt;p&gt; * &lt;p&gt;At the time that this function has been called, your Resources * object will have been updated to return resource values matching the * new configuration. * * @param newConfig The new device configuration. */public void onConfigurationChanged(Configuration newConfig) &#123; if (DEBUG_LIFECYCLE) Slog.v(TAG, "onConfigurationChanged " + this + ": " + newConfig); mCalled = true; mFragments.dispatchConfigurationChanged(newConfig); if (mWindow != null) &#123; // Pass the configuration changed event to the window mWindow.onConfigurationChanged(newConfig); &#125; if (mActionBar != null) &#123; // Do this last; the action bar will need to access // view changes from above. mActionBar.onConfigurationChanged(newConfig); &#125;&#125; &#160;&#160;&#160;以上注释大概的意思是，当你的Activity在运行时，有设备配置发生了变化，系统就会调用这个方法。如果你在manifest中配置了configChanges属性，则表示由你自己处理配置修改，否则就会重启这个Activity,并且会加载新的资源，这样就让系统以及应用加载完新的资源，完成了语言的切换。 总结 &#160;&#160;&#160;从整个流程来看，Android字体切换的流程如下： 当切换或添加新的语言时，会生成新的Configuration来替换原来的Configuration，并且修改项是可追寻的； 根据最新的Configuration来更新系统资源以及应用资源； 重启所有的Activity并更新到最新的资源； 完成语言切换。 &#160;&#160;&#160;以下为语言切换流程大致的时序图。 注：由于个人能力有限以及时间关系，有遗漏或错误的地方，还请批评指出，谢谢。 参考博客&#160;&#160;&#160;wqhjfree&#160;&#160;&#160;七号大蒜 版权声明：本文为博主原创文章，转载请注明出处KidSea]]></content>
      <tags>
        <tag>安卓</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[读深入理解Java虚拟机]]></title>
    <url>%2F2017%2F10%2F17%2F%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3java%E8%99%9A%E6%8B%9F%E6%9C%BA-4%2F</url>
    <content type="text"><![CDATA[Java类加载机制前言 &#160;&#160;&#160;看到Java类加载机制这章，简单的做下读书笔记，加深自己对Java类加载机制的理解。 内容 概述&#160;&#160;&#160;有Java开发经验的人，应该都知道.class文件里描述二进制数据的信息，需要加载到Jvm虚拟机中才能运行和使用。因此，类的加载机制就是指，JVM把所描述的类的信息从.class文件加载到内存中，进而进行数据验证，转化解析以及初始化，最终转化为JVM可以使用的类型。 &#160;&#160;&#160;类文件来源 从本地文件系统中加载.class文件 从网络访问中加载.class文件 从相应的Jar包中加载.class文件 将相应Java源文件动态编译.class文件 从专有的数据库中提取.class文件 类的生命周期&#160;&#160;&#160;Android中有很多机制都有其特定的生命周期,比Activity、Service以及广播等。类加载机制也有其生命周期，从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期包括：加载、验证、准备、解析、初始化、使用、卸载共七个阶段，流程如下图所示。 &#160;&#160;&#160;其中准备、验证、解析3个部分统称为连接；类加载过程则包括了加载、验证、准备、解析、初始化这五个阶段；加载、验证、准备、初始化以及卸载这五个阶段的发生顺序是确定的，而解析阶段是不一定的，在某些时候它的发送时机是在初始化之后，这是为了支持Java语言的运行时绑定（也称为动态绑定或晚期绑定）。 注：另外注意这里的几个阶段是按顺序开始，而不是按顺序进行或完成，因为这些阶段通常都是互相交叉地混合进行的，通常在一个阶段执行的过程中调用或激活另一个阶段。 &#160;&#160;&#160;下面分别介绍几个重要阶段的作用 加载 &#160;&#160;&#160;其主要作用是查找并加载类的二进制数据。 &#160;&#160;&#160;在加载阶段，虚拟机需要完成以下3件事情： 通过一个类的全限定名来获取定义此类的二进制字节流； 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构； 在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口。 &#160;&#160;&#160;对于整个生命周期来说，加载阶段可控性最强，我们可以通过使用系统提供的加载器来完成加载，也可以使用自己定义的加载器来加载。 &#160;&#160;&#160;加载阶段完成之后二进制字节流就按照虚拟机所需的格式存储在方法区中，并且在Java堆中也创建一个类对象，方便我们通过该对象访问方法区中的数据。 验证 &#160;&#160;&#160;其主要作用是确保被加载的类的正确性。 &#160;&#160;&#160;验证阶段大致会完成4个阶段的检验动作： 文件格式验证：验证字节流是否符合Class文件格式的规范；例如：是否以魔术0xCAFEBABE开头、主次版本号是否在当前虚拟机的处理范围之内、常量池中的常量是否有不被支持的类型。 元数据验证：对字节码描述的信息进行语义分析（注意：对比javac编译阶段的语义分析），以保证其描述的信息符合Java语言规范的要求；例如：这个类是否有父类，除了java.lang.Object之外。 字节码验证：通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的。 符号引用验证：确保解析动作能正确执行。 &#160;&#160;&#160;验证阶段是非常重要的，但不是必须的，它对程序运行期没有影响，如果所引用的类经过反复验证，那么可以考虑采用-Xverifynone参数来关闭大部分的类验证措施，以缩短虚拟机类加载的时间。 准备 &#160;&#160;&#160;其主要作用是为类的静态变量分配内存，并将其初始化为默认值。 &#160;&#160;&#160;这些变量所使用的内存都将在方法区中进行分配。这时候进行内存分配的仅包括类变量（被static修饰的变量），而不包括实例变量，实例变量将会在对象实例化时随着对象一起分配在堆中。其次，这里所说的初始值“通常情况”下是数据类型的零值，假设一个类变量的定义为： 1public static int value=30; &#160;&#160;&#160;那么变量value在准备阶段过后的初始值为0，而不是30，因为这时候尚未开始执行任何Java方法，而把value赋值为30的putstatic指令是在程序编译后，存放于类构造器&lt;clinit&gt;（）方法之中的，所以把value赋值为30的动作将在初始化阶段才会执行。 解析 &#160;&#160;&#160;解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符7类符号引用进行。 &#160;&#160;&#160;符号引用就是一组符号来描述目标，可以是任何字面量。 &#160;&#160;&#160;直接引用就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄。 初始化 &#160;&#160;&#160;类初始化阶段是类加载过程的最后一步，在这个阶段JVM负责对类进行初始化，主要对类变量进行初始化，也可以说初始化阶段是执行类构造器&lt;clinit&gt;()方法的过程。在Java中对类变量进行初始值设定有两种方式： 声明类变量是指定初始值 使用静态代码块为类变量指定初始值 &#160;&#160;&#160;类初始化时机 创建类实例。也就是new的方式 调用某个类的类方法 访问某个类或接口的类变量，或为该类变量赋值 使用反射方式强制创建某个类或接口对应的java.lang.Class对象 初始化某个类的子类，则其父类也会被初始化 直接使用java.exe命令来运行某个主类 &#160;&#160;&#160;类初始化步骤 假如这个类还没有被加载和连接，则程序先加载并连接该类； 假如该类的直接父类还没有被初始化，则先初始化其直接父类； 假如类中有初始化语句，则系统依次执行这些初始化语句。 类的加载器&#160;&#160;&#160;类加载器（ClassLoader），顾名思义，即加载类的东西。其功能就是将类的字节码文件加载到内存中，并对字节码进行解析生成对应的类对象，类的动态加载就是使用类加载器来实现的。 JVM类加载机制 全盘负责，当一个类加载器负责加载某个Class时，该Class所依赖的和引用的其他Class也将由该类加载器负责载入，除非显示使用另外一个类加载器来载入。 父类委托，先让父类加载器试图加载该类，只有在父类加载器无法加载该类时才尝试从自己的类路径中加载该类。 缓存机制，缓存机制将会保证所有加载过的Class都会被缓存，当程序中需要使用某个Class时，类加载器先从缓存区寻找该Class，只有缓存区不存在，系统才会读取该类对应的二进制数据，并将其转换成Class对象，存入缓存区。这就是为什么修改了Class后，必须重启JVM，程序的修改才会生效。 类加载器&#160;&#160;&#160;Java 提供三种类型的系统类加载器： 启动类加载器(Bootstrap ClassLoader)：由C++实现，不是ClassLoader子类，加载 JAVA_HOME/lib 目录中的文件，或-Xbootclasspath指定目录下的能被虚拟机识别的类库。 扩展类加载器(ExtClassLoader)：负责加载JAVA_HOME\lib\ext目录中或系统变量 java.ext.dirs 所指定的目录中的所有类库。 应用类加载器(AppClassLoader)：负责加载用户类路径中的文件，一般情况下这个就是程序中默认的类加载器。 &#160;&#160;&#160;用户可以直接使用扩展类加载器或系统类加载器来加载自己的类，但是用户无法直接使用启动类加载器，除了这两种类加载器以外，用户也可以自定义类加载器(CustomClassLoader)，加载流程如下图所示： 参考资料 《深入理解Java虚拟机：JVM高级特性与最佳实践 第2版》 周志明 著. 版权声明：本文为博主原创文章，转载请注明出处KidSea]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android字体加载原理总结]]></title>
    <url>%2F2017%2F08%2F12%2FAndroid%E5%AD%97%E4%BD%93%E5%8A%A0%E8%BD%BD%E5%8E%9F%E7%90%86%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[前言 &#160;&#160;&#160;之前在处理系统字体问题的时候，可借鉴的资料很少，遇到了很多坑，不得不了解Android字体加载原理，现抽空写一篇总结，来加深自己对这块的理解。 内容 概述&#160;&#160;&#160;Android字体系统是由底层的Android 2D图形引擎Skia来实现的，Android3.0之后逐渐使用了新的硬件绘图模块hwui，在5.0之后正式取代了Skia，因此不同版本的系统其字体加载机制有些差异，按照Google的API Level来看，大体可以分为三个阶段： Android4.0以下的系统 Android4.0到Android4.4的系统 Android5.0以上的系统 &#160;&#160;&#160;当然这每个阶段中，可能也存在些许小差异，但大方向是没变化的，本文主要对Android5.0以上的系统的字体加载机制进行描述，围绕系统字体配置文件解析与字体加载相关内容，不涉及系统运行库的实现细节。 注：浏览器及webView中的字体有单独的字体系统 &#160;&#160;&#160;下面将从Java层面、Native层面、文件配置系统三个部分来阐述Android字体加载原理。 Java层面&#160;&#160;&#160;有研究过Android的人大概都有了解，Android的Java层封装了构建应用程序时可能会用到的各种Api。而在字体这部分，起主要作用的是android.graphics.Typeface，其主要负责字体加载以及对上层提供创建字体功能的调用，下面将着重分析该类的调用过程。 &#160;&#160;&#160;首先，在Android启动的过程中，ZygoteInit类中的main()方法会调用加载方法preload()，对各种类、链接库、资源等进行初始化，具体代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public static void main(String argv[]) &#123; ... registerZygoteSocket(socketName); Trace.traceBegin(Trace.TRACE_TAG_DALVIK, "ZygotePreload"); EventLog.writeEvent(LOG_BOOT_PROGRESS_PRELOAD_START, SystemClock.uptimeMillis()); //调用加载方法 preload(); EventLog.writeEvent(LOG_BOOT_PROGRESS_PRELOAD_END, SystemClock.uptimeMillis()); Trace.traceEnd(Trace.TRACE_TAG_DALVIK); ... &#125;//主要用于加载并初始化各种类、链接库、资源等。static void preload() &#123; Log.d(TAG, "begin preload"); //Systrace开始tag Trace.traceBegin(Trace.TRACE_TAG_DALVIK, "BeginIcuCachePinning"); //开始Icu缓存开销 beginIcuCachePinning(); //Systrace结束tag Trace.traceEnd(Trace.TRACE_TAG_DALVIK); Trace.traceBegin(Trace.TRACE_TAG_DALVIK, "PreloadClasses"); //预加载Classes preloadClasses(); Trace.traceEnd(Trace.TRACE_TAG_DALVIK); Trace.traceBegin(Trace.TRACE_TAG_DALVIK, "PreloadResources"); //预加载resources preloadResources(); Trace.traceEnd(Trace.TRACE_TAG_DALVIK); Trace.traceBegin(Trace.TRACE_TAG_DALVIK, "PreloadOpenGL"); //预加载openGL preloadOpenGL(); Trace.traceEnd(Trace.TRACE_TAG_DALVIK); //加载分享库 preloadSharedLibraries(); //加载文本资源 preloadTextResources(); // Ask the WebViewFactory to do any initialization that must run in the zygote process, // for memory sharing purposes.、 WebViewFactory.prepareWebViewInZygote(); endIcuCachePinning(); warmUpJcaProviders(); Log.d(TAG, "end preload");&#125; &#160;&#160;&#160;其中preloadClasses()方法会加载并初始化一些系统常用的API类，这些类都是位于frameworks/base/preloaded-classes文件中，当然也包括Typeface类。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950/** * Performs Zygote process initialization. Loads and initializes * commonly used classes. * * Most classes only cause a few hundred bytes to be allocated, but * a few will allocate a dozen Kbytes (in one case, 500+K). */private static void preloadClasses() &#123; ... InputStream is; try &#123; is = new FileInputStream(PRELOADED_CLASSES); &#125; catch (FileNotFoundException e) &#123; Log.e(TAG, "Couldn't find " + PRELOADED_CLASSES + "."); return; &#125; ... try &#123; BufferedReader br = new BufferedReader(new InputStreamReader(is), 256); int count = 0; String line; while ((line = br.readLine()) != null) &#123; // Skip comments and blank lines. line = line.trim(); if (line.startsWith("#") || line.equals("")) &#123; continue; &#125; Trace.traceBegin(Trace.TRACE_TAG_DALVIK, "PreloadClass " + line); try &#123; if (false) &#123; Log.v(TAG, "Preloading " + line + "..."); &#125; // Load and explicitly initialize the given class. Use // Class.forName(String, boolean, ClassLoader) to avoid repeated stack lookups // (to derive the caller's class-loader). Use true to force initialization, and // null for the boot classpath class-loader (could as well cache the // class-loader of this class in a variable). Class.forName(line, true, null); count++; ... &#125; &#160;&#160;&#160;从上面的代码可以看到，Android通过反射机制Class.forName(“android.graphics.Typeface”)加载了Typeface类，在加载的同时，会调用类中的static方法块。如下： 1234567891011121314151617181920212223242526272829303132333435static &#123; //初始化系统字体 init(); // Set up defaults and typefaces exposed in public API DEFAULT = create((String) null, 0); DEFAULT_BOLD = create((String) null, Typeface.BOLD); SANS_SERIF = create("sans-serif", 0); SERIF = create("serif", 0); MONOSPACE = create("monospace", 0); sDefaults = new Typeface[] &#123; DEFAULT, DEFAULT_BOLD, create((String) null, Typeface.ITALIC), create((String) null, Typeface.BOLD_ITALIC), &#125;;&#125;public static Typeface create(String familyName, int style) &#123; if (sSystemFontMap != null) &#123; return create(sSystemFontMap.get(familyName), style); &#125; return null;&#125;public static Typeface create(Typeface family, int style) &#123; ... typeface = new Typeface(nativeCreateFromTypeface(ni, style)); ... return typeface;&#125; &#160;&#160;&#160;在上面的static方法块中，最终通过调用Native层方法nativeCreateFromTypeface()，来初始化系统字体并且设置默认的系统字体以及字体样式，可以从上面的方法看出系统默认创建sans-serif（无衬线字体），serif（衬线字体），monospace（等宽字体）三种字体，并且通过create第一个参数为null，来创建默认字体的四种style：normal，bold，italic，bolditalic。 注：这里需要注意的是，Android4.x版本的系统与Android5.0以上的版本所调用的API基本一致，但是native层确有很大的变，这是由于5.0以上的系统添加了一个新的方法init()，其主要实现了解析系统字体配置文件，并据此加载系统字体。而Android4.x版本是在native层实现的。 &#160;&#160;&#160;因为现在Android阵营已经基本上都是5.0以上的系统了，所以5.0以下版本的加载不在解释。下面我们来看init()方法的具体逻辑： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677/* * (non-Javadoc) * * This should only be called once, from the static class initializer block. */private static void init() &#123; // Load font config and initialize Minikin state //获取系统字体配置文件位置放置于system/etc目录下 File systemFontConfigLocation = getSystemFontConfigLocation(); //获取配置文件fonts.xml File configFilename = new File(systemFontConfigLocation, FONTS_CONFIG); //以下代码是对fonts.xml的解析，即是对系统字体的解析 try &#123; FileInputStream fontsIn = new FileInputStream(configFilename); FontListParser.Config fontConfig = FontListParser.parse(fontsIn); Map&lt;String, ByteBuffer&gt; bufferForPath = new HashMap&lt;String, ByteBuffer&gt;(); //用来承载fonts.xml中的每个family节点 List&lt;FontFamily&gt; familyList = new ArrayList&lt;FontFamily&gt;(); // Note that the default typeface is always present in the fallback list; // this is an enhancement from pre-Minikin behavior. //从每个family节点中解析字体样式，这里解析系统默认字体 for (int i = 0; i &lt; fontConfig.families.size(); i++) &#123; FontListParser.Family f = fontConfig.families.get(i); if (i == 0 || f.name == null) &#123; familyList.add(makeFamilyFromParsed(f, bufferForPath)); &#125; &#125; //系统默认字体集合 sFallbackFonts = familyList.toArray(new FontFamily[familyList.size()]); //设置默认系统字体 setDefault(Typeface.createFromFamilies(sFallbackFonts)); //这里加载系统字体，包括默认字体 Map&lt;String, Typeface&gt; systemFonts = new HashMap&lt;String, Typeface&gt;(); for (int i = 0; i &lt; fontConfig.families.size(); i++) &#123; Typeface typeface; FontListParser.Family f = fontConfig.families.get(i); if (f.name != null) &#123; if (i == 0) &#123; // The first entry is the default typeface; no sense in // duplicating the corresponding FontFamily. typeface = sDefaultTypeface; &#125; else &#123; //从每个family节点中解析字体 FontFamily fontFamily = makeFamilyFromParsed(f, bufferForPath); FontFamily[] families = &#123; fontFamily &#125;; typeface = Typeface.createFromFamiliesWithDefault(families); &#125; //解析的字体添加到系统字体中 systemFonts.put(f.name, typeface); &#125; &#125; //通过权重别号解析字体，别名必须与字体对应 for (FontListParser.Alias alias : fontConfig.aliases) &#123; Typeface base = systemFonts.get(alias.toName); Typeface newFace = base; int weight = alias.weight; if (weight != 400) &#123; newFace = new Typeface(nativeCreateWeightAlias(base.native_instance, weight)); &#125; systemFonts.put(alias.name, newFace); &#125; //系统字体集合 sSystemFontMap = systemFonts; &#125; catch (RuntimeException e) &#123; Log.w(TAG, "Didn't create default family (most likely, non-Minikin build)", e); // TODO: normal in non-Minikin case, remove or make error when Minikin-only &#125; catch (FileNotFoundException e) &#123; Log.e(TAG, "Error opening " + configFilename, e); &#125; catch (IOException e) &#123; Log.e(TAG, "Error reading " + configFilename, e); &#125; catch (XmlPullParserException e) &#123; Log.e(TAG, "XML parse exception for " + configFilename, e); &#125;&#125; &#160;&#160;&#160;通过以上代码，可以看出，系统解析过程中，一共有三种字体模式。一种的是系统默认字体；一种是系统字体，所有字体，包括自己添加的字体；一种是设置别名的字体，字体的衍生。而这三种字体都会在init()中被加载，而它们加载主要涉及以下方法。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687//通过family节点解析FontFamilyprivate static FontFamily makeFamilyFromParsed(FontListParser.Family family, Map&lt;String, ByteBuffer&gt; bufferForPath) &#123; //这里的lang表示国家缩写，variant表示字体的排列格式一般有compact与elegant两种 FontFamily fontFamily = new FontFamily(family.lang, family.variant); for (FontListParser.Font font : family.fonts) &#123; ByteBuffer fontBuffer = bufferForPath.get(font.fontName); if (fontBuffer == null) &#123; try (FileInputStream file = new FileInputStream(font.fontName)) &#123; FileChannel fileChannel = file.getChannel(); long fontSize = fileChannel.size(); fontBuffer = fileChannel.map(FileChannel.MapMode.READ_ONLY, 0, fontSize); bufferForPath.put(font.fontName, fontBuffer); &#125; catch (IOException e) &#123; Log.e(TAG, "Error mapping font file " + font.fontName); continue; &#125; &#125; if (!fontFamily.addFontWeightStyle(fontBuffer, font.ttcIndex, font.axes, font.weight, font.isItalic)) &#123; Log.e(TAG, "Error creating font " + font.fontName + "#" + font.ttcIndex); &#125; &#125; return fontFamily;&#125;/*以下是通过不同的格式解析出不同的family*/public FontFamily() &#123; mNativePtr = nCreateFamily(null, 0); if (mNativePtr == 0) &#123; throw new IllegalStateException("error creating native FontFamily"); &#125;&#125;public FontFamily(String lang, String variant) &#123; int varEnum = 0; if ("compact".equals(variant)) &#123; varEnum = 1; &#125; else if ("elegant".equals(variant)) &#123; varEnum = 2; &#125; mNativePtr = nCreateFamily(lang, varEnum); if (mNativePtr == 0) &#123; throw new IllegalStateException("error creating native FontFamily"); &#125;&#125;@Overrideprotected void finalize() throws Throwable &#123; try &#123; nUnrefFamily(mNativePtr); &#125; finally &#123; super.finalize(); &#125;&#125;public boolean addFont(String path, int ttcIndex) &#123; try (FileInputStream file = new FileInputStream(path)) &#123; FileChannel fileChannel = file.getChannel(); long fontSize = fileChannel.size(); ByteBuffer fontBuffer = fileChannel.map(FileChannel.MapMode.READ_ONLY, 0, fontSize); return nAddFont(mNativePtr, fontBuffer, ttcIndex); &#125; catch (IOException e) &#123; Log.e(TAG, "Error mapping font file " + path); return false; &#125;&#125;public boolean addFontWeightStyle(ByteBuffer font, int ttcIndex, List&lt;FontListParser.Axis&gt; axes, int weight, boolean style) &#123; return nAddFontWeightStyle(mNativePtr, font, ttcIndex, axes, weight, style);&#125;public boolean addFontFromAsset(AssetManager mgr, String path) &#123; return nAddFontFromAsset(mNativePtr, mgr, path);&#125;private static native long nCreateFamily(String lang, int variant);private static native void nUnrefFamily(long nativePtr);private static native boolean nAddFont(long nativeFamily, ByteBuffer font, int ttcIndex);private static native boolean nAddFontWeightStyle(long nativeFamily, ByteBuffer font, int ttcIndex, List&lt;FontListParser.Axis&gt; listOfAxis, int weight, boolean isItalic);private static native boolean nAddFontFromAsset(long nativeFamily, AssetManager mgr, String path); 12345678910111213141516171819202122232425262728293031323334/** * Create a new typeface from an array of font families. * * @param families array of font families * @hide *///通过FontFamily解析创建字体public static Typeface createFromFamilies(FontFamily[] families) &#123; long[] ptrArray = new long[families.length]; for (int i = 0; i &lt; families.length; i++) &#123; ptrArray[i] = families[i].mNativePtr; &#125; return new Typeface(nativeCreateFromArray(ptrArray));&#125;/** * Create a new typeface from an array of font families, including * also the font families in the fallback list. * * @param families array of font families * @hide *///通过FontFamily解析创建字体public static Typeface createFromFamiliesWithDefault(FontFamily[] families) &#123; long[] ptrArray = new long[families.length + sFallbackFonts.length]; for (int i = 0; i &lt; families.length; i++) &#123; ptrArray[i] = families[i].mNativePtr; &#125; for (int i = 0; i &lt; sFallbackFonts.length; i++) &#123; ptrArray[i + families.length] = sFallbackFonts[i].mNativePtr; &#125; return new Typeface(nativeCreateFromArray(ptrArray));&#125; &#160;&#160;&#160;从上面的代码可看到，系统通过解析/system/etc/fonts.xml（字体配置文件），然后接收Native层方法回调上来的值，来创建指定的Typeface即字体，保存在sSystemFontMap中。而相关native方法列表以及注册(在frameworks/base/core/jni/android/graphics/Typeface.cpp中注册)如下： 12345678910111213141516171819202122232425private static native long nativeCreateFromTypeface(long native_instance, int style);private static native long nativeCreateWeightAlias(long native_instance, int weight);private static native void nativeUnref(long native_instance);private static native int nativeGetStyle(long native_instance);private static native long nativeCreateFromArray(long[] familyArray);private static native void nativeSetDefault(long native_instance);///////////////////////////////////////////////////////////////////////////////static const JNINativeMethod gTypefaceMethods[] = &#123; &#123; "nativeCreateFromTypeface", "(JI)J", (void*)Typeface_createFromTypeface &#125;, &#123; "nativeCreateWeightAlias", "(JI)J", (void*)Typeface_createWeightAlias &#125;, &#123; "nativeUnref", "(J)V", (void*)Typeface_unref &#125;, &#123; "nativeGetStyle", "(J)I", (void*)Typeface_getStyle &#125;, &#123; "nativeCreateFromArray", "([J)J", (void*)Typeface_createFromArray &#125;, &#123; "nativeSetDefault", "(J)V", (void*)Typeface_setDefault &#125;,&#125;;int register_android_graphics_Typeface(JNIEnv* env)&#123; return RegisterMethodsOrDie(env, "android/graphics/Typeface", gTypefaceMethods, NELEM(gTypefaceMethods));&#125; &#160;&#160;&#160;最终，通过这一层的关系，调用到Native层的方法。 &#160;&#160;&#160;到此，字体加载Java层面就结束了，下面将调用Native层的方法。 Native层面&#160;&#160;&#160;Native层主要是skia图形引擎的Android移植版，项目源码位于external\skia目录下。 &#160;&#160;&#160;在Android4.X版本中主要是用skia来进行软件绘制，所以解析配置文件并加载字体是在skia中完成，这里不在描述过程，可以参看相关博客中的描述。而由于绘制性能等问题，Android5.0之后使用了新的硬件绘图模块hwui，hwui主要则是使用opengles来进行gpu硬件绘图，提升整个系统的绘制性能。 &#160;&#160;&#160;在上述Java层调用过程后，字体加载指向了Native层。在Native层调用首先进入jni/android/graphics/Typeface.cpp，调用对应的方法，然后进入hwui/Typeface.h和hwui/Typeface.cpp中定制的函数，从而解析配置文件并加载字体。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960//jni/android/graphics/Typeface.cpp#include "jni.h"#include "core_jni_helpers.h"#include "GraphicsJNI.h"#include "ScopedPrimitiveArray.h"#include "SkTypeface.h"#include &lt;android_runtime/android_util_AssetManager.h&gt;#include &lt;androidfw/AssetManager.h&gt;#include &lt;hwui/Typeface.h&gt;using namespace android;static jlong Typeface_createFromTypeface(JNIEnv* env, jobject, jlong familyHandle, jint style) &#123; Typeface* family = reinterpret_cast&lt;Typeface*&gt;(familyHandle); Typeface* face = Typeface::createFromTypeface(family, (SkTypeface::Style)style); // TODO: the following logic shouldn't be necessary, the above should always succeed. // Try to find the closest matching font, using the standard heuristic if (NULL == face) &#123; face = Typeface::createFromTypeface(family, (SkTypeface::Style)(style ^ SkTypeface::kItalic)); &#125; for (int i = 0; NULL == face &amp;&amp; i &lt; 4; i++) &#123; face = Typeface::createFromTypeface(family, (SkTypeface::Style)i); &#125; return reinterpret_cast&lt;jlong&gt;(face);&#125;static jlong Typeface_createWeightAlias(JNIEnv* env, jobject, jlong familyHandle, jint weight) &#123; Typeface* family = reinterpret_cast&lt;Typeface*&gt;(familyHandle); Typeface* face = Typeface::createWeightAlias(family, weight); return reinterpret_cast&lt;jlong&gt;(face);&#125;static void Typeface_unref(JNIEnv* env, jobject obj, jlong faceHandle) &#123; Typeface* face = reinterpret_cast&lt;Typeface*&gt;(faceHandle); if (face != NULL) &#123; face-&gt;unref(); &#125;&#125;static jint Typeface_getStyle(JNIEnv* env, jobject obj, jlong faceHandle) &#123; Typeface* face = reinterpret_cast&lt;Typeface*&gt;(faceHandle); return face-&gt;fSkiaStyle;&#125;static jlong Typeface_createFromArray(JNIEnv *env, jobject, jlongArray familyArray) &#123; ScopedLongArrayRO families(env, familyArray); std::vector&lt;FontFamily*&gt; familyVec; for (size_t i = 0; i &lt; families.size(); i++) &#123; FontFamily* family = reinterpret_cast&lt;FontFamily*&gt;(families[i]); familyVec.push_back(family); &#125; return reinterpret_cast&lt;jlong&gt;(Typeface::createFromFamilies(familyVec));&#125;static void Typeface_setDefault(JNIEnv *env, jobject, jlong faceHandle) &#123; Typeface* face = reinterpret_cast&lt;Typeface*&gt;(faceHandle); return Typeface::setDefault(face);&#125; 1234567891011121314151617181920212223242526272829303132333435363738//hwui/Typeface.h#ifndef _ANDROID_GRAPHICS_TYPEFACE_IMPL_H_#define _ANDROID_GRAPHICS_TYPEFACE_IMPL_H_#include "SkTypeface.h"#include &lt;cutils/compiler.h&gt;#include &lt;minikin/FontCollection.h&gt;#include &lt;vector&gt;namespace android &#123;struct ANDROID_API Typeface &#123; FontCollection *fFontCollection; // style used for constructing and querying Typeface objects SkTypeface::Style fSkiaStyle; // base weight in CSS-style units, 100..900 int fBaseWeight; // resolved style actually used for rendering FontStyle fStyle; void unref(); static Typeface* resolveDefault(Typeface* src); static Typeface* createFromTypeface(Typeface* src, SkTypeface::Style style); static Typeface* createWeightAlias(Typeface* src, int baseweight); static Typeface* createFromFamilies(const std::vector&lt;FontFamily*&gt;&amp; families); static void setDefault(Typeface* face);&#125;;&#125;#endif // _ANDROID_GRAPHICS_TYPEFACE_IMPL_H_ &#160;&#160;&#160;Native层的c/c++方法调用比较复杂，通过一系列的调用，返回值给Java层，这里就不在阐述，有兴趣的人可以自己下个源码深入理解下，到这里Android的字体加载原理基本完成了，不得不感叹Google工程师的丰功伟绩。 文件配置系统&#160;&#160;&#160;前面介绍的是加载的原理，现在简单的描述下字体加载过程中所用到的字体加载文件。 &#160;&#160;&#160;在4.x版本的系统字体配置文件位于system/etc/system_fonts.xml，备用字体配置文件位于system/etc/fallback_fonts.xml和vendor/etc/fallback_fonts.xml。而5.0以上的版本的系统字体及备用字体配置均位于system/etc/fonts.xml文件中，下面展示部分fonts.xml内容。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;familyset version="22"&gt; &lt;!-- first font is default --&gt; &lt;family name="sans-serif"&gt; &lt;font weight="100" style="normal"&gt;Roboto-Thin.ttf&lt;/font&gt; &lt;font weight="100" style="italic"&gt;Roboto-ThinItalic.ttf&lt;/font&gt; &lt;font weight="300" style="normal"&gt;Roboto-Light.ttf&lt;/font&gt; &lt;font weight="300" style="italic"&gt;Roboto-LightItalic.ttf&lt;/font&gt; &lt;font weight="400" style="normal"&gt;Roboto-Regular.ttf&lt;/font&gt; &lt;font weight="400" style="italic"&gt;Roboto-Italic.ttf&lt;/font&gt; &lt;font weight="500" style="normal"&gt;Roboto-Medium.ttf&lt;/font&gt; &lt;font weight="500" style="italic"&gt;Roboto-MediumItalic.ttf&lt;/font&gt; &lt;font weight="900" style="normal"&gt;Roboto-Black.ttf&lt;/font&gt; &lt;font weight="900" style="italic"&gt;Roboto-BlackItalic.ttf&lt;/font&gt; &lt;font weight="700" style="normal"&gt;Roboto-Bold.ttf&lt;/font&gt; &lt;font weight="700" style="italic"&gt;Roboto-BoldItalic.ttf&lt;/font&gt; &lt;/family&gt; &lt;!-- Note that aliases must come after the fonts they reference. --&gt; &lt;alias name="sans-serif-thin" to="sans-serif" weight="100" /&gt; &lt;alias name="sans-serif-light" to="sans-serif" weight="300" /&gt; &lt;alias name="sans-serif-medium" to="sans-serif" weight="500" /&gt; &lt;alias name="sans-serif-black" to="sans-serif" weight="900" /&gt; &lt;alias name="arial" to="sans-serif" /&gt; &lt;alias name="helvetica" to="sans-serif" /&gt; &lt;alias name="tahoma" to="sans-serif" /&gt; &lt;alias name="verdana" to="sans-serif" /&gt; ... &lt;!-- fallback fonts --&gt; &lt;family lang="und-Arab" variant="elegant"&gt; &lt;font weight="400" style="normal"&gt;NotoNaskhArabic-Regular.ttf&lt;/font&gt; &lt;font weight="700" style="normal"&gt;NotoNaskhArabic-Bold.ttf&lt;/font&gt; &lt;/family&gt; &lt;family lang="und-Arab" variant="compact"&gt; &lt;font weight="400" style="normal"&gt;NotoNaskhArabicUI-Regular.ttf&lt;/font&gt; &lt;font weight="700" style="normal"&gt;NotoNaskhArabicUI-Bold.ttf&lt;/font&gt; &lt;/family&gt; &lt;family lang="und-Ethi"&gt; &lt;font weight="400" style="normal"&gt;NotoSansEthiopic-Regular.ttf&lt;/font&gt; &lt;font weight="700" style="normal"&gt;NotoSansEthiopic-Bold.ttf&lt;/font&gt; &lt;/family&gt; &lt;!-- 简体中文字体 --&gt; &lt;family lang="zh-Hans"&gt; &lt;font weight="400" style="normal"&gt;NotoSansSC-Regular.otf&lt;/font&gt; &lt;/family&gt; &lt;!-- 繁体中文字体 --&gt; &lt;family lang="zh-Hant"&gt; &lt;font weight="400" style="normal"&gt;NotoSansTC-Regular.otf&lt;/font&gt; &lt;/family&gt; &#160;&#160;&#160;如上所示，第一个family节点为系统默认字体。nameset节点的各个name子节点定义可用的字体名称，fileset节点的file子节点分别对应normal、bold、italic、bold-italic四种字体样式，如果file节点个数少于四个，相应字体样式会对应已有兄弟file节点的字体文件。family属性中lang代表国家的缩写，系统在切换语言的时候会从加载的字体中匹配国家的缩写，从而调出对于的系统字体、variant属性指的是字体的排列格式通常有compact(紧凑型)以及(简洁型)。 &#160;&#160;&#160;fallback_fonts配置了系统备用字体。只有在系统内置字体中找不到相应字符时，才会到备用字体中去寻找，family节点的顺序对应搜索顺序，搜索匹配规则采用BCP47的定义。 &#160;&#160;&#160;5.0以后的字体配置文件与之前版本的相比，最大的一个改进是将之前字体样式中的单一bold样式改为各种不同过的weight，这样可以更加细粒度的控制字重。 为系统添加新的字体&#160;&#160;&#160;现在的手机产商都对Android系统进行了定制，当然也会加上属于自己的字体，下面简单描述下添加新字体的流程，以缅甸字体为例。 &#160;&#160;&#160;1.在frameworks/base/data/fonts/fonts.xml中添加字体节点 123&lt;family lang="my"&gt; &lt;font weight="400" style="normal"&gt;ZawgyiOne.ttf&lt;/font&gt;&lt;/family&gt; &#160;&#160;&#160;2.在frameworks/base/data/fonts/fonts.mk的最后加入新加的字体文件 1234567891011121314PRODUCT_COPY_FILES := \ frameworks/base/data/fonts/fonts.xml:$(TARGET_COPY_OUT_SYSTEM)/etc/fonts.xmlPRODUCT_PACKAGES := \ DroidSansFallback.ttf \ DroidSansMono.ttf \ AndroidClock.ttf \ DINPro-Black.otf \ DINPro-Bold.otf \ DINPro-Light.otf \ DINPro-Medium.otf \ DINPro-Regular.otf \ Flyme-Light.ttf \ ZawgyiOne.ttf &#160;&#160;&#160;3.在frameworks/base/data/fonts/Android.mk的font_src_files最后加入新加的字体文件 12345font_src_files := \ AndroidClock.ttf \ Flyme-Light.ttf \ ZawgyiOne.ttf &#160;&#160;&#160;4.将下载的字体放入frameworks/base/data/fonts下 &#160;&#160;&#160;其中第2、第3步是为了让字体能够编译进入系统中。 参考博客&#160;&#160;&#160;knight &#160;&#160;&#160;flyeek 版权声明：本文为博主原创文章，转载请注明出处KidSea]]></content>
      <tags>
        <tag>安卓</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅析onWindowsFocusChanged()方法]]></title>
    <url>%2F2017%2F07%2F12%2F%E6%B5%85%E6%9E%90onWindowsFocusChanged()%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[前言 在接手的项目中，看到了onWindowsFocusChanged()的方法，抽空了解下它的用途 内容 概述&#160;&#160;&#160;从字面上来讲，onWindowsFocusChanged()方法是指当窗口焦点变化的时候；从意义来说，onWindowsFocusChanged()就是指当前的Activity的Windows(窗口)获取或者失去焦点时这个方法就会被调用，并且当回调这个方法时，Activity是完全可见的。 &#160;&#160;&#160;在Activity生命周期中，onStart(), onResume(), onCreate()都不是布局visible的时间点，真正的visible时间点是onWindowFocusChanged()函数被执行时。从onWindowFocusChanged()被执行起，用户可以与应用进行交互了，换句话说，如果你想要在Activity加载后做些操作，可以在这个方法里调用而这之前，对用户的操作需要做一点限制。 onWindowFocusChanged()的使用情景与作用&#160;&#160;&#160;根据介绍可以了解，onWindowFocusChanged()使用于以下等情景： 首次进入一个Activity后会在onResume()方法后面调用； 从Activity 跳到另一个Activity，新的窗口会获取焦点, 就的Activity的窗口会失去焦点； 打开软键盘进行输入时，窗口失去焦点； 软键盘输入完毕消失时，窗口重新获取焦点； 应用进入后台，窗口失去焦点； 应用从后台返回当前, 窗口重新获取焦点； … &#160;&#160;&#160;因此其可以有如下作用： 监控一个Activity是否载完毕； 在Activity加载后进行一些操作，如获取手机屏幕的高度和宽度； 当Activity挂起或恢复时，可以在方法内进行一些数据的保存或恢复的操作； … onWindowFocusChanged()调用详解&#160;&#160;&#160;介绍完onWindowFocusChanged()基本的使用情景以及作用后，撸个demo来看下onWindowFocusChanged()具体的调用情况。 &#160;&#160;&#160;首先在Activity中重写的onWindowFocusChanged()方法如下： 123456789101112/** * 添加窗体在视图初始化完成过后 * * @param hasFocus */ @Override public void onWindowFocusChanged(boolean hasFocus) &#123; super.onWindowFocusChanged(hasFocus); if (hasFocus) &#123; //add Window..... &#125; &#125; &#160;&#160;&#160;其中参数hasFocus表示窗口是否获取或失去焦点，true表示获取焦点，false表示失去焦点。 &#160;&#160;&#160;然后我们看下总体的代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071public class WindosFoucesDemo extends AppCompatActivity &#123; private static final String TAG = "LifeCycleDemo"; //Activity创建时被调用 @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); Log.i(TAG, "onCreate is called."); setContentView(R.layout.activity_main); &#125; //Activity创建或者从后台重新回到前台时被调用 @Override protected void onStart() &#123; super.onStart(); Log.i(TAG, "onStart is called."); &#125; //Activity创建或者从被覆盖、后台重新回到前台时被调用 @Override protected void onResume() &#123; super.onResume(); Log.i(TAG, "onResume is called."); &#125; //Activity窗口获得或失去焦点时被调用,在onResume之后或onPause之后 @Override public void onWindowFocusChanged(boolean hasFocus) &#123; super.onWindowFocusChanged(hasFocus); if(hasFocus)&#123; Log.i(TAG, "onWindowFocusChanged is called and" + "hasFocus is true"); &#125;else &#123; Log.i(TAG, "onWindowFocusChanged is called and" + "hasFocus is false"); &#125; &#125; //Activity被覆盖到下面或者锁屏时被调用 @Override protected void onPause() &#123; super.onPause(); Log.i(TAG, "onPause is called."); //有可能在执行完onPause或onStop后,系统资源紧张将Activity杀死,所以有必要在此保存持久数据 &#125; //退出当前Activity或者跳转到新Activity时被调用 @Override protected void onStop() &#123; super.onStop(); Log.i(TAG, "onStop is called."); &#125; //退出当前Activity时被调用,调用之后Activity就结束了 @Override protected void onDestroy() &#123; super.onDestroy(); Log.i(TAG, "onDestory is called."); &#125; //Activity从后台重新回到前台时被调用 @Override protected void onRestart() &#123; super.onRestart(); Log.i(TAG, "onRestart called."); &#125;&#125; &#160;&#160;&#160;运行该Demo，查看Log日志，可以得到以下日志结果。 &#160;&#160;&#160;1. 启动Activity时: &#160;&#160;&#160;2. 按下任务栏键，Activity被遮挡时： 注意：按锁屏键和按任务栏或者Home键的生命周期是不同的，按Home执行onPause –&gt; onStop –&gt; onRestart –&gt; onStart —&gt; onResume 按锁屏键和对话框覆盖界面的生命周期是一样的，都只会进行onPause －－&gt; onResume .不会执行onStop,onRestart,onStart。 &#160;&#160;&#160;3. Activity恢复到前台时： &#160;&#160;&#160;4. Activity退出时： &#160;&#160;&#160;从上面的例子以及结果可以清楚的onWindowFocusChanged()在整个Activity生命周期内的调用情况，可以根据这些结果，在开发中来充分利用onWindowFocusChanged()方法的作用。 onWindowFocusChanged()源码分析&#160;&#160;&#160;通过Activity源码去查看,发现onWindowFocusChanged()这个方法出现在WindowCallbackWrapper.java和View.java这两个类中，而WindowCallbackWrapper.java中其实也是调用View.java中的onWindowFocusChanged()，其代码如下： 1234567891011121314151617181920212223242526272829303132333435363738 /** * Called when the window containing this view gains or loses focus. Note * that this is separate from view focus: to receive key events, both * your view and its window must have focus. If a window is displayed * on top of yours that takes input focus, then your own window will lose * focus but the view focus will remain unchanged. * * @param hasWindowFocus True if the window containing this view now has * focus, false otherwise. * 当前的window(窗口)获取或者失去焦点的时候会回调这个方法.请注意,这个焦点和 * view焦点是分离的,为了获取按键事件,view和view所在的窗口都必须获得焦点.如果 * 一个窗口处于你的输入事件的最上层,那么该窗口将失去焦点而view的焦点会保持不 * 变. */public void onWindowFocusChanged(boolean hasWindowFocus) &#123; //获取软键盘a system window such as the keyguard may InputMethodManager imm = InputMethodManager.peekInstance(); if (!hasWindowFocus) &#123; if (isPressed()) &#123; //键盘有按下事件,则强制将该view包含的所有子控件全部setPressed()设置为false setPressed(false); &#125; if (imm != null &amp;&amp; (mPrivateFlags &amp; FOCUSED) != 0) &#123; //这是一个隐藏的方法(带@hide标签),当view失去焦点时会调用该方法 imm.focusOut(this); &#125; //移onWindowFocusChanged(boolean hasFocus) 被回调的触发时机是窗口获取或失去焦点的时候.除长按事件回调的接口方法 removeLongPressCallback(); //移除轻触探测器,源码中叫 "Remove the tap detection timer." removeTapCallback(); //当焦点(fucos)从按下变成取消的时候会调用,属于隐藏方法 onFocusLost(); &#125; else if (imm != null &amp;&amp; (mPrivateFlags &amp; FOCUSED) != 0) &#123; //当view获得焦点时调用该方法,属于隐藏方法 imm.focusIn(this); &#125; //强制view刷新drawable state,并且会回调drawableStateChanged()方法 refreshDrawableState();&#125; &#160;&#160;&#160;从源码可以验证出，onWindowFocusChanged()方法被回调的触发时机是窗口获取或失去焦点的时候。并且在onResume()方法中的官方解释 Use {@link #onWindowFocusChanged} to know for certain that your activity is visible to the user (for example, to resume a game). 可以知道onWindowFocusChanged()第一次调用是在onResume()方法后面。 版权声明：本文为博主原创文章，转载请注明出处KidSea]]></content>
      <tags>
        <tag>安卓</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JSON数据格式以及GSON的使用]]></title>
    <url>%2F2017%2F05%2F29%2FJSON%E6%95%B0%E6%8D%AE%E6%A0%BC%E5%BC%8F%E4%BB%A5%E5%8F%8AGSON%E7%9A%84%E4%BD%BF%E7%94%A8%20%2F</url>
    <content type="text"><![CDATA[前言&#160;&#160;&#160;作为一个Android开发者来说，Json数据是经常接触到的一种数据结构，并且现在越来越多的项目和开发插件等默认都会支持和使用Json数据格式,本文我们就来浅谈下Json数据结构以及Gson库的使用。 内容 JSON数据结构JSON的定义&#160;&#160;&#160;什么是Json？ JSON指的是 JavaScript 对象表示法（JavaScript Object Notation）； JSON是轻量级的文本数据交换格式； JSON独立于编程语言与平台； JSON具有自我描述性，更易理解; JSON 解析器和 JSON 库支持许多不同的编程语言。 JSON的两种结构&#160;&#160;&#160;1. “名称/值”对的集合（A collection of name/value pairs）。不同的语言中，它被理解为对象（object），记录（record），结构（struct），字典（dictionary），哈希表（hash table），有键列表（keyed list），或者关联数组 （associative array）。 &#160;&#160;&#160;2. 值的有序列表（An ordered list of values）。在大部分语言中，它被理解为数组（array）。 &#160;&#160;&#160;JSON具有以下这些形式： &#160;&#160;&#160;对象是一个无序的“‘名称/值’对”集合。一个对象以“{”（左括号）开始，“}”（右括号）结束。每个“名称”后跟一个“:”（冒号）；“‘名称/值’ 对”之间使用“,”（逗号）分隔。 &#160;&#160;&#160;数组是值（value）的有序集合。一个数组以“[”（左中括号）开始，“]”（右中括号）结束。值之间使用“,”（逗号）分隔。 JSON实例&#160;&#160;&#160;简单的JSON对象如下所示： 123456&#123;"category":"普通", "time":"2017-05-09#17:18:55","content":"主楼502病人突发状况"&#125; &#160;&#160;&#160;该对象有三个属性，分别为categor、time、content，属性后面紧接着是属性的值。 &#160;&#160;&#160;简单的JSON数组如下所示： 12345678&#123;"employees":[ &#123;"firstName":"John", "lastName":"Doe"&#125;, &#123;"firstName":"Anna", "lastName":"Smith"&#125;, &#123;"firstName":"Peter", "lastName":"Jones"&#125;]&#125; &#160;&#160;&#160;在以上实例中，对象”employees”是一个数组。包含了三个对象，每个为个对象为员工的记录（姓和名）。 JSON与XML比较&#160;&#160;&#160;1. 可读性 &#160;&#160;&#160;JSON和XML的可读性可谓不相上下，一边是简易的语法，一边是规范的标签形式，很难分出胜负。 &#160;&#160;&#160;2. 可扩展性 &#160;&#160;&#160;XML天生有很好的扩展性，JSON当然也有，没有什么是XML可以扩展而JSON却不能扩展的。不过JSON在Javascript主场作战，可以存储Javascript复合对象，有着XML不可比拟的优势。 &#160;&#160;&#160;3. 工具对比 &#160;&#160;&#160;XML有丰富的工具，比如Dom4j、JDom等，JSON也有提供的工具，如FastJson，Gson等。 &#160;&#160;&#160;4. 两者实例对比 &#160;&#160;&#160;用XML表示中国部分省市数据如下： 123456789101112131415161718192021222324252627&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;country&gt; &lt;name&gt;中国&lt;/name&gt; &lt;province&gt; &lt;name&gt;福建&lt;/name&gt; &lt;cities&gt; &lt;city&gt;福州&lt;/city&gt; &lt;city&gt;厦门&lt;/city&gt; &lt;/cities&gt; &lt;/province&gt; &lt;province&gt; &lt;name&gt;广东&lt;/name&gt; &lt;cities&gt; &lt;city&gt;广州&lt;/city&gt; &lt;city&gt;深圳&lt;/city&gt; &lt;city&gt;珠海&lt;/city&gt; &lt;/cities&gt; &lt;/province&gt; &lt;province&gt; &lt;name&gt;台湾&lt;/name&gt; &lt;cities&gt; &lt;city&gt;台北&lt;/city&gt; &lt;city&gt;高雄&lt;/city&gt; &lt;/cities&gt; &lt;/province&gt;&lt;/country&gt; &#160;&#160;&#160;用JSON表示如下： 12345678910111213141516171819202122232425262728293031323334&#123; "name": "中国", "province": [&#123; "name": "福建", "cities": &#123; "city": ["福州", "厦门"] &#125; &#125;, &#123; "name": "广东", "cities": &#123; "city": ["广州", "深圳", "珠海"] &#125; &#125;, &#123; "name": "台湾", "cities": &#123; "city": ["台北", "高雄"] &#125; &#125;]&#125;``` ## GSON的使用&amp;#160;&amp;#160;&amp;#160;通常在安卓开发中，我们常用的两种方式：一种是JSON原生的方法，即用org.json包来解析；另一种是使用谷歌提供的GSON工具来解析。下面笔者将介绍下二者的使用，例子如下所示。```Json&#123;"person":[&#123;"name":"zhangsan","age":20&#125;,&#123;"name":"lisi","age":21&#125;,&#123;"name":"wangwu","age":32&#125;]&#125; &#160;&#160;&#160;对应的JavaBean如下： 123456789101112131415161718192021222324252627282930313233public class Person &#123; private String name; private int age; public Person(String name, int age) &#123; super(); this.name = name; this.age = age; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; @Override public String toString() &#123; return "Person [name=" + name + ", age=" + age + "]"; &#125; &#125; 使用JSON（org.json）包解析1234567891011121314151617181920212223242526public class JSONDEMO &#123; public static void main(String[] args) throws JSONException &#123; String str = "&#123;person:[&#123;name:'zhangsan',age:20&#125;,&#123;name:'lisi',age:2&#125;,&#123;name:'wangwu',age:3&#125;]&#125;"; List&lt;Person&gt; l = new ArrayList&lt;&gt;(); //创建JSONObject对象 JSONObject ob = new JSONObject(str); //获取JSONObject对象的值，该值是一个JSON数组 JSONArray array = ob.getJSONArray("person"); for (int i = 0; i &lt; array.length(); i++) &#123; //获得JSON数组中的每一个JSONObject对象 JSONObject o = array.getJSONObject(i); //获得每一个JSONObject对象中的键所对应的值 String name = o.getString("name"); int age = o.getInt("age"); //将解析出来的属性值存入Person对象 Person p = new Person(name, age); //将解析出来的每一个Person对象添加到List中 l.add(p); &#125; for (Person person : l) &#123; System.out.println(person); &#125; &#125; &#125; &#160;&#160;&#160;输出结果如下： 123Person[name=zhangsan,age=20]Person[name=lisi,age=22]Person[name=wangwu,age=32] &#160;&#160;&#160;使用这种方法解析JSON，看注释，没什么好多的，总结一句话就是：遇到{}用JSONObject，遇到[]用JSONArray，这样你就可以说你精通org.json解析JSON了。 使用GSON解析123456789101112131415public class GSONDEMO &#123; public static void main(String[] args) throws JSONException &#123; String str = "&#123;person:[&#123;name:'zhangsan',age:20&#125;,&#123;name:'lisi',age:2&#125;,&#123;name:'wangwu',age:3&#125;]&#125;"; //创建Gson对象 Gson gson = new Gson(); //将JSON转化成Person对象集合 List&lt;Person&gt; ps = gson.fromJson(str, new TypeToken&lt;List&lt;Person&gt;&gt;()&#123;&#125;.getType()); //输出 for (Person person : ps) &#123; System.out.println(person); &#125; &#125; &#125; &#160;&#160;&#160;输出结果如下： 1234Person[name=zhangsan,age=20]Person[name=lisi,age=22]Person[name=wangwu,age=32] &#160;&#160;&#160;可以从上面的例子看出，使用GSON工具来解析JSON比原生方法简单的多，所以一般在开发过程中，推荐使用GSON来解析网络数据JSON。 Gson的常见用法&#160;&#160;&#160;1. JSON转化成对象 &#160;&#160;&#160;这种用法通过创建GSON对象，调用fromJson（）方法来将JSON数据转化成对应对象，用法如下： 12345678// 使用new方法,创建对象Gson gson = new Gson();// fromJson 将json字符串转为bean对象Person person= gson.fromJson(jsonStr, Person.class);// **反序列化成List时需要使用到TypeToken getType()**List&lt;Person&gt; retList = gson.fromJson(jsonStr2,new TypeToken&lt;List&lt;Person&gt;&gt;()&#123;&#125;.getType()); &#160;&#160;&#160;2. 对象转化成JSON &#160;&#160;&#160;这种用法通过创建GSON对象，调用toJson（）方法来将对象化转化成对应JSON数据，用法如下： 12345678// 使用new方法,创建对象Gson gson = new Gson();// toJson 将bean对象转换为json字符串String jsonStr = gson.toJson(person, Person.class);// **序列化List**String jsonStr2 = gson.toJson(list); 版权声明：本文为博主原创文章，转载请注明出处KidSea]]></content>
      <tags>
        <tag>安卓</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[舒适区终有一天会毁掉你的青春]]></title>
    <url>%2F2017%2F04%2F03%2F%E8%88%92%E9%80%82%E5%8C%BA%E7%BB%88%E6%9C%89%E4%B8%80%E5%A4%A9%E4%BC%9A%E6%AF%81%E6%8E%89%E4%BD%A0%E7%9A%84%E9%9D%92%E6%98%A5%2F</url>
    <content type="text"><![CDATA[前言 在大城市里，搞废一个人的方式特别简单，给你一个安静狭小的空间，给你一根网线，最好再加一个外卖电话。好了，你开始废了。以自己为圆心，自己的手为半径，开始画个圆。你会发现所有需要的东西，都在这个圆圈里。 内容 &#160;&#160;&#160;在大城市里，搞废一个人的方式特别简单，给你一个安静狭小的空间，给你一根网线，最好再加一个外卖电话。好了，你开始废了。以自己为圆心，自己的手为半径，开始画个圆。你会发现所有需要的东西，都在这个圆圈里。 &#160;&#160;&#160;这个圈，叫作舒适圈。这一个月我一直在全国各地出差，回到北京，见到一个许久没见的朋友，一起去KTV唱歌，他刚刚被公司解雇。我问他，一个月没见，最近忙啥呢。 &#160;&#160;&#160;他说，没忙啥，待着呢。 &#160;&#160;&#160;我说，其实我特别能理解你，你这个月是不是觉得自己过得特别无忧无虑，恨不得连电话都想丢了。他说，电话还是得要的，不过确实电话每次响起还是有点紧张，总觉得自己安稳的小世界要被打破了。 &#160;&#160;&#160;我点点头，想起了《肖申克救赎》里的一句话：这些墙挺有意思，一开始你抵触它，然后你习惯它，最后你不得不依赖它。 &#160;&#160;&#160;人有一种习惯，就是总喜欢在舒适熟悉的环境待着，这种“舒适区”一旦被建立，就会变得无比依赖，慢慢地爱上了周围的墙，恋上了这舒适的小屋，从而不愿意飞出去看看，怕看到外面熙熙攘攘的世界。 &#160;&#160;&#160;我想起另一个朋友，毕业去了一家国企上班，每天朝九晚四，日子像上了发条一样，只有周末，才像被赋予了灵魂一样，穿着打扮逛街约会去了。我跟她聊过舒适区，她告诉我，我这才不是舒适区，我可是每天都要按时工作的，不迟到不早退，很规律很努力的。 &#160;&#160;&#160;我说，那工作一年了，感觉到自己有什么变化吗？她想了想，说，你别说，好像还真没有。 &#160;&#160;&#160;其实，舒适区分为两种，一种是成天无所事事，另一种更可怕，因为很难意识到，就是无意义有规律的循环。而后者，更是许多人的生活状态：看起来很努力，看起来很累很忙，不过是重复无意义地循环着，这样的生活，过着过着只会觉得舒服，却没有本质的变化。 &#160;&#160;&#160;我曾经见到一个在医院门口收费的哥们儿，每天摆着一副臭脸，谁也不能多问他一个问题，否则他会大发雷霆。可是他一下班，脸上就露出了笑容。后来，我明白了，只有下班后，他才走出了自己的舒适区，开始了多姿多彩的生活。所以，只有一个人舒适区被打破，才能见到突破和卓越，从而带来持久的幸福。 &#160;&#160;&#160;我特别怕自己在年轻的日子里，把日子过成发条，只剩下滴答滴答。于是，从开始工作第一天起，就没有坐过班，即使是现在创业，董事会非要求坐班，我也断然拒绝。甚至有一段时间闹得很僵，他们问我为什么这么不愿意全心投入这份工作？ &#160;&#160;&#160;我跟他们说，不去坐班不是不全力投入，相反，很多人每天坐八小时一周坐五天，也就干了十个小时的活，搞得自己也郁闷。 &#160;&#160;&#160;后来，我拿实际行动证明了自己不坐班效率反而更高，我能用大把属于自己的时间做许多事情，跨了几个领域，这些领域能互相协作，而且都做得不错。 &#160;&#160;&#160;其实，我还有个原因不愿意坐班，就是我特别了解自己的惰性，一旦我的日子变得循规蹈矩每天都有固定的方式方法，慢慢地就失去这么强的创造力和闯劲儿。我怕自己习惯了一种生活模式，换了环境就不适应了。 &#160;&#160;&#160;关于走出舒适区，并不是盲目地辞职，相反，你应该有一份保底活下来的工作，除此之外，一定要给自己生活中埋下一些彩蛋：去吃一次没吃过的超辣鸡翅；去表白一个只见过一次的姑娘；去看一本一直想看的书。 &#160;&#160;&#160;所以，别让舒适区毁掉青春，相反，应该趁着青春，去围墙的外面看看，你要相信，故步自封的人，舒适区会越来越小，终有一天，会发现世界早已无立足之处。真正的强者，他们在年轻的时候，经历了沧桑，化解了迷茫，学会了坚强，懂得了疗伤，他们在哪里都能活，哪里都是自己的天堂。 版权声明：本文为博主转载文章，转载请注明出处点这]]></content>
      <tags>
        <tag>文章</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Adb常用指令]]></title>
    <url>%2F2017%2F03%2F19%2FAdb%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[前言 对于Android开发者来说，Adb应该都不陌生，作为Android调试的桥梁，熟练使用其主要的指令，可以提升我们的开发效率，下面就对常见的Adb指令进行介绍 内容 Adb概述&#160;&#160;&#160;adb的全称为Android Debug Bridge，就是起到调试桥的作用。通过adb我们可以在Eclipse中方便通过DDMS来调试Android程序，说白了就是debug工具。adb的工作方式比较特殊，采用监听Socket TCP 5554等端口的方式让IDE和Qemu通讯，默认情况下adb会daemon相关的网络端口，所以当我们运行Eclipse时adb进程就会自动运行。作为开发人员，掌握适当所需要的ADB操作命令是非常必须的。就把平时工作中用得相对比较多的adb命令作个小总结。 &#160;&#160;&#160;Adb工具位于SDK的platform-tools目录下，所以要使用该工具的时候，需要通过cd命令，切换到该目录下，或者将platform-tools的路径添加到系统环境变量中，这样就可以直接使用了（针对windows系统，linux系统会自动配置） Adb常用指令&#160;&#160;&#160;下面我们来看一些Adb常用命令 显示系统Android全部平台： android list targets 显示系统中全部AVD（模拟器）： android list avd 创建AVD（模拟器）： android create avd –name 名称 –target 平台编号 启动模拟器： emulator -avd 名称 -sdcard ~/名称.img (-skin 1280x800) 删除AVD（模拟器）： android delete avd –name 名称 显示当前运行的全部模拟器或真机： adb devices 安装应用程序： adb install -r 应用程序.apk 获取模拟器中的文件： adb pull 向模拟器中写文件： adb push 进入模拟器的shell模式：adb shell 缷载apk包： 这个操作需要执行以下步骤adb shellcd data/apprm apk包exitadb uninstall apk包的主包名adb install -r apk包 查看adb命令帮助信息：adb help 在命令行中查看LOG信息：adb logcat -s 标签名 删除系统应用： adb remount （重新挂载系统分区，使系统分区重新可写）。 adb shell cd system/app rm *.apk 获取管理员权限：adb root remount命令的作用是加载文件系统 模拟器重启命令:adb reboot 版权声明：本文为博主原创文章，转载请注明出处KidSea]]></content>
      <tags>
        <tag>Adb</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android运行环境Context理解]]></title>
    <url>%2F2017%2F03%2F10%2F%E8%B0%88%E8%B0%88%E5%AF%B9Context%E7%9A%84%E7%90%86%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[前言 &#160;&#160;&#160;Context相信有Android开发经验的人不陌生，基本上每天都在接触，谈谈自己对Context的理解 内容 Context类型&#160;&#160;&#160;Context通常被翻译为上下文，我通常理解为Android的运行环境，在Android中，Activity、Service、Application都是继承自Context。Android程序不像Java程序一样，随便创建一个类，写个main()方法就能跑了，而是要有一个完整的Android工程环境，在这个环境下，我们有像Activity、Service、BroadcastReceiver等系统组件，而这些组件并不是像一个普通的Java对象new一下就能创建实例的了，而是要有它们各自的上下文环境，也就是这里讨论的Context。 &#160;&#160;&#160;Android应用程序如下几个时间点创建应用的上下文Context: 创建Application时 创建Activity时 创建Service时 &#160;&#160;&#160;细心的人可以发现，创建Context的时机就是创建Context的实现类。在应用第一次启动的时候，系统就会创建Application对象，同时创建ApplicationContext，而系统所有的组件都拥有一个这样的上下文对象，这个上下文对象贯穿整个应用程序的生命周期，为系统提供了全局的功能和环境支持，当然创建组件的时候，系统也会给组件创建他们自己相应的上下问对象，但是从原理上来说某些时候二者是有一些区别的。 getContext()、getApplicationContext()、this的区别&#160;&#160;&#160;使用this，说明当前类是context类的子类，一般是application activity等 &#160;&#160;&#160;getApplicationContext()指的是app所使用的application，是在AndroidManifest唯一指定的意味着，在当前app的任意位置使用这个函数得到的是同一个Context，而使用getContext获取的是当前对象所在的Context。 &#160;&#160;&#160;举个简单的例子。 &#160;&#160;&#160;我们在公司上班， 我们是一个类，公司是一个类，公司.this是context()即公司的环境，我.this不是context，而我getcontext()是指公司的环境。而getApplicationContext()则可以看做是所有公司的集合，发生的所有事情都在这个集合中，有且只有一个。 版权声明：本文为博主原创文章，转载请注明出处KidSea]]></content>
      <tags>
        <tag>安卓</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[开源库LitePal的用法]]></title>
    <url>%2F2017%2F02%2F23%2FActivity%E5%BC%80%E6%BA%90%E6%95%B0%E6%8D%AE%E5%BA%93LitePal%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[前言 &#160;&#160;&#160;LitePal是一个开源的Android库，允许开发人员使用SQLite数据库非常容易。您可以完成大多数数据库操作，甚至不需要编写SQL语句，包括创建或升级表，压缩操作，聚合函数等。LitePal的设置也很简单，您可以将它集成到您的项目中少于5分钟。 内容 LitePal的快速配置1.引入Jar包或源码&#160;&#160;&#160;使用Android Studio在项目的build.gradle中添加下面依赖： 1234dependencies &#123; compile 'org.litepal.android:core:1.3.2'&#125; &#160;&#160;&#160;使用Eclipse到这里下载好了jar包之后，把它复制到项目的libs目录中就算是引入成功了。 2.配置litepal.xml&#160;&#160;&#160;在项目的assets目录下面新建一个litepal.xml文件，内容如下： 1234567891011121314&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;litepal&gt; &lt;dbname value="cool_weather" /&gt; &lt;version value="1" /&gt; &lt;list&gt; &lt;mapping class="com.example.yuxuehai.coolweather.bean.Province" /&gt; &lt;mapping class="com.example.yuxuehai.coolweather.bean.City" /&gt; &lt;mapping class="com.example.yuxuehai.coolweather.bean.County" /&gt; &lt;/list&gt;&lt;/litepal&gt; &#160;&#160;&#160;其中： 是数据库的名字 是数据库的版本号 是数据库的映射模型（数据库表） 是数据库的映射模型的地址（数据库表结构） 3. 配置LitePalApplication&#160;&#160;&#160;在AndroidManifest.xml中配置LitePalApplication，如下： 1234567&lt;application android:name="org.litepal.LitePalApplication" ... &gt; ... ...&lt;/application&gt; &#160;&#160;&#160;如果是已经有自己的application,则可以继承LitePalApplication或者在代码中加入如下代码: 12345678910111213public class MyApplication extends LitePalApplication &#123; ... &#125;public class MyApplication extends AnotherApplication&#123; @Override public void onCreate() &#123; super.onCreate(); LitePal.initialize(this); &#125; ... &#125; LitePal的建表&#160;&#160;&#160;根据对象关系映射模式的理念，每一张表都应该对应一个模型(Model)，建表先要新建一个模型类，新建一个Province类，如下: 123456789101112131415161718192021222324252627282930public class Province extends DataSupport &#123; private int id; private String provinceName; private int provinceCode; public int getProvinceCode() &#123; return provinceCode; &#125; public void setProvinceCode(int provinceCode) &#123; this.provinceCode = provinceCode; &#125; public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public String getProvinceName() &#123; return provinceName; &#125; public void setProvinceName(String provinceName) &#123; this.provinceName = provinceName; &#125;&#125; &#160;&#160;&#160;LitePal的映射规则是非常轻量级的，不像一些其它的数据库框架，需要为每个模型类单独配置一个映射关系的XML，LitePal的所有映射都是自动完成的。根据LitePal的数据类型支持，可以进行对象关系映射的数据类型一共有8种，int、short、long、float、double、boolean、String和Date。只要是声明成这8种数据类型的字段都会被自动映射到数据库表中，并不需要进行任何额外的配置。 注意:只有private修饰的字段才会被映射到数据库表中，即如果有某一个字段不想映射的话，就设置为public、protected或者default修饰符就可以了。 &#160;&#160;&#160;建立好Model后，我们就把他配置到映射列表中，即编辑assest目录下的litepal.xml文件，在标签中加入DEST类的声明，这里要注意，要类的完整类名。 123456789101112&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;litepal&gt; &lt;dbname value="cool_weather" /&gt; &lt;version value="1" /&gt; &lt;list&gt; &lt;mapping class="com.example.yuxuehai.coolweather.bean.Province" /&gt; &lt;/list&gt;&lt;/litepal&gt; &#160;&#160;&#160;到这里，就完成了LitePal数据库的配置。 LitePal的升级表1.添加新表&#160;&#160;&#160;首先创建一个新的模型类，然后把它设置到litepal.xml中，如下： 1234567891011121314&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;litepal&gt; &lt;dbname value="cool_weather" /&gt; &lt;version value="1" /&gt; &lt;list&gt; &lt;mapping class="com.example.yuxuehai.coolweather.bean.Province" /&gt; &lt;mapping class="com.example.yuxuehai.coolweather.bean.City" /&gt; &lt;mapping class="com.example.yuxuehai.coolweather.bean.County" /&gt; &lt;/list&gt;&lt;/litepal&gt; &#160;&#160;&#160;然后，把litepal.xml中的version的值加一即可，如下： 1234567891011121314&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;litepal&gt; &lt;dbname value="cool_weather" /&gt; &lt;version value="2" /&gt; &lt;list&gt; &lt;mapping class="com.example.yuxuehai.coolweather.bean.Province" /&gt; &lt;mapping class="com.example.yuxuehai.coolweather.bean.City" /&gt; &lt;mapping class="com.example.yuxuehai.coolweather.bean.County" /&gt; &lt;/list&gt;&lt;/litepal&gt; 2.旧表添加新列&#160;&#160;&#160;首先在需要升级的模型类中添加新的private修饰的字段,然后再把litepal.xml中的version的值加一即可，这里就不展示代码了，读者可以自己去体验。 LitePal的操作&#160;&#160;&#160;LitePal要存储数据，首先模型类要继承DataSupport，即： 1234public class Province extends DataSupport &#123; ... ...&#125; &#160;&#160;&#160;继承了DataSupport类之后，这些实体类就拥有了进行CRUD操作的能力。 1.存储操作&#160;&#160;&#160;创建对象，为对象的属性进行赋值，最后调用save()方法即可存储，如下: 1234Province province = new Province();province.setProvinceName(provinceObject.getString("name"));province.setProvinceCode(provinceObject.getInt("id"));province.save(); &#160;&#160;&#160;更好的是，save()方法是有返回值的，读者可以根据自己需要对其进行判断后做出一些操作： 12345if (mDest.save()) &#123; Toast.makeText(context, "存储成功", Toast.LENGTH_SHORT).show(); &#125; else &#123; Toast.makeText(context, "存储失败", Toast.LENGTH_SHORT).show(); &#125; 2.修改操作&#160;&#160;&#160;如果想把Province表中id为1的provinceCode改为”1”，可以这样写： 123456789ContentValues values = new ContentValues(); values.put("provinceCode", "1"); DataSupport.update(Pronvice.class, values, 1); //或者用下面这种方法Province updateNews = new Province(); updateNews.setProvinceCode(1) updateNews.update(1); &#160;&#160;&#160;如果想把Province表中所有id为”1”的改为”2”可以这样写： 123456789ContentValues values = new ContentValues(); values.put("provinceCode", "2"); DataSupport.updateAll(DEST.class, values, "provinceCode = ?", "1"); //或者用下面这种方法Province updateNews = new Province(); updateNews.setProvinceCode("2"); updateNews.updateAll("setProvinceCode = ?", "1"); 3.LitePal的删除操作&#160;&#160;&#160;比如说我们想删除Province表中id为2的记录，就可以这样写： 1DataSupport.delete(Province.class, 2); &#160;&#160;&#160;想把Province表中id为“1”的所有数据删除，就可以这样写： 1DataSupport.deleteAll(Province.class, "destId = ? ", "1"); &#160;&#160;&#160;想把Province表中所有数据删除，就可以这样写： 1DataSupport.deleteAll(Province.class); LitePal的查询操作&#160;&#160;&#160;查询Province表中id为1的这条记录，使用LitePal就可以这样写： 1Province mProvince = DataSupport.find(Province.class, 1); &#160;&#160;&#160;想要获取Province表中的第一条数据，只需要这样写： 1Province mProvince = DataSupport.findFirst(Province.class); &#160;&#160;&#160;想要获取Province表中的最后一条数据，只需要这样写： 1Province mProvince = DataSupport.findLast(Province.class); &#160;&#160;&#160;查询Province表中id为1,2,3的这条记录，使用LitePal就可以这样写： 1List&lt;Province&gt; mProvince = DataSupport.findAll(Province.class,1,2,3); &#160;&#160;&#160;查询所有数据，只需要这样写： 1List&lt;Province&gt; mProvince = DataSupport.findAll(Province.class); &#160;&#160;&#160;笔者只是对一些简单的操作进行介绍，如想学习更多操作请浏览guolin郭霖老师的博客点这里 版权声明：本文为博主原创文章，转载请注明出处KidSea]]></content>
      <tags>
        <tag>安卓</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Recyclerview的用法]]></title>
    <url>%2F2017%2F01%2F14%2Frecycleview%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[前言 简单的介绍下Recyclerview的用法 内容 Android5.0 RecyclerView特点、用法、及自定义动画&#160;&#160;&#160;RecyclerView派生于ViewGroup，是一种更先进的柔性版的ListView。这个小工具是一个容器，用于显示，它能非常有效地维护了数量有限而滚动大的数据集。相对于ListView来说RecyclerView使用起来更加灵活但同时也增加了一定的复杂度，它在最新的support-V7版本中提供支持.本文主要分为以下2个部分： RecyclerView的简单使用 简单介绍RecyclerView的四大组件 RecyclerView的简单使用&#160;&#160;&#160;虽说相对于以前的ListView，RecyclerView基本上没有新增的功能，但在功能的具体实现和使用的方法上两者却有着很大的区别。要使用RecyclerView，需要先了解这几个个元素：LayoutManager，RecyclerView.Adapter，Itemanimator以及itemDecoration。LayoutManager控制RecyclerView的布局以及资源的回收，RecyclerView.Adapter用于设置数据，ItemAnimator用于创建列表的Item动画，而ItemDecoration则用于绘制列表子项额外的内容。以上四个均为RecyclerView中的抽象类，带有最基本的接口和参数，开发者可以通过继承以上几个类进行扩展实现不同的功能效果。下面首先通过附件中的SimpleDemo介绍一下RecyclerVIew的使用方法： 1. 定义布局文件&#160;&#160;&#160;activity_main.xml的主要布局如下： 12345&lt;android.support.v7.widget.RecyclerViewandroid:id="@+id/recyclerview_vertical"android:layout_width="match_parent"android:layout_height="wrap_content"android:scrollbars="vertical" /&gt; &#160;&#160;&#160;RecyclerView是android.support.v7包下提供的控件,要使用RecyclerView可以直接把源码上整个的v7包导入到工程中， 或者把当前的API升级到21，在sdk/extras/android/support/v7目录下找到android-support-v7-recyclerview.jar（其实也可以直接从网上的Demo中直接copy对应的jar包过去，不过应当注意最近的版本中部分接口已经做了相应的变化 ,应下载最新的jar包），将其导入到工程内即可。 2. 设置RecyclerView.Adapter&#160;&#160;&#160;Demo中的SimpleAdapter.java中的主要代码如下： 12345678910111213141516171819202122232425262728//定义ViewHolder，包含两个控件public static class ViewHolder extends RecyclerView.ViewHolder&#123; public TextView mTextView; public ImageView mImageView; public ViewHolder(View itemView) &#123; super(itemView); &#125;&#125;@Overridepublic ViewHolder onCreateViewHolder(ViewGroup viewGroup, int i) &#123; View view = View.inflate(viewGroup.getContext(), R.layout.item_layout, null); // 创建ViewHolder ViewHolder holder = new ViewHolder(view); holder.mImageView = (ImageView)view.findViewById(R.id.id_index_item_image); holder.mTextView = (TextView)view.findViewById(R.id.id_index_item_text); return holder;&#125;@Overridepublic void onBindViewHolder(ViewHolder viewHolder,int i) &#123; //设置TextView内容 viewHolder.mTextView.setText(mData[i]); //设置ImageView资源 viewHolder.mImageView.setImageResource(R.drawable.mail); &#125; 3. 定义Decoration&#160;&#160;&#160;Decoration.java的主要代码如下： 12345678910111213141516171819202122@Overridepublic void onDrawOver(Canvas c, RecyclerView parent) &#123; if (mDivider == null) &#123; super.onDrawOver(c, parent); return; &#125; //为横向布局的RecyclerView的每个Item设置下划线 if (getOrientation(parent) == LinearLayoutManager.VERTICAL) &#123; final int left = parent.getPaddingLeft(); final int right = parent.getWidth() - parent.getPaddingRight(); final int childCount = parent.getChildCount(); for (int i = 1; i &lt; childCount; i++) &#123; final View child = parent.getChildAt(i); final RecyclerView.LayoutParams params = (RecyclerView.LayoutParams) child .getLayoutParams(); final int size = mDivider.getIntrinsicHeight(); final int top = child.getTop() - params.topMargin; final int bottom = top + size; mDivider.setBounds(left, top, right, bottom); mDivider.draw(c); &#125; 4. 初始化操作&#160;&#160;&#160;在MainActivity.java的主要代码如下： 123456789mRecyclerView = (RecyclerView)findViewById(R.id.recyclerview_vertical);SimpleAdapter simpleAdapter = new SimpleAdapter(dataset, this);mRecyclerView.setAdapter(simpleAdapter);// 创建一个线性布局管理器LinearLayoutManager layoutManager = new LinearLayoutManager(this);layoutManager.setOrientation(LinearLayoutManager.VERTICAL);// 设置布局管理器&amp;#160;&amp;#160;&amp;#160;mRecyclerView.setLayoutManager(layoutManager);mRecyclerView.addItemDecoration(new Decoration(this)); &#160;&#160;&#160;Demo中实现的效果如下： RecyclerView的四大组件Adapter&#160;&#160;&#160;RecyclerView使用的Adapter与ListView使用的BaseAdapter类似，但是，前者定义的Adapter必须继承自RecyclerView.Adapter，内部必须重写三个方法，oncreateViewHolder（）onbindViewHolder（）getItemCount（）,onCreateViewHolder（）类似于BaseAdapter中的getview（）,ListView可以选择使用ViewHolder（）但RecyclerView为了回收资源，必须使用ViewHolder。先对比两者子类部分代码： 1234567891011121314151617181920212223242526@Overridepublic View getView(int position, View convertView, ViewGroup parent) &#123; ViewHolder holder = null; //如果缓存convertView为空，则需要创建View if(convertView == null) &#123; holder = new ViewHolder(); //根据自定义的Item布局加载布局 convertView = mInflater.inflate(R.layout.list_item, null); holder.img = (ImageViewShadow)convertView.findViewById(R.id.img); holder.title = (TextView)convertView.findViewById(R.id.tv); holder.info = (TextView)convertView.findViewById(R.id.info); //将设置好的布局保存到缓存中，并将其设置在Tag里，以便后面方便取出Tag convertView.setTag(holder); &#125;else &#123; holder = (ViewHolder)convertView.getTag(); &#125; Drawable D = StrokeDrawableUtils.createStrokeDrawable(getResources().getDrawable(R.drawable.mail), getResources()); holder.img.setImageDrawable(D); ho.setText((String)data.get(position).get("title")); holder.info.setText((String)data.get(position).get("info")); return convertView;&#125; 1234567891011121314151617181920@Overridepublic ViewHolder onCreateViewHolder(ViewGroup viewGroup, int i) &#123; View view = mInflater.inflate(R.layout.activity_index_item, viewGroup, false); //创建viewHolder对象和绑定viewHolder內的所有组件 ViewHolder viewHolder = new ViewHolder(view); viewHolder.mImg = (ImageView) view .findViewById(R.id.id_index_gallery_item_image); viewHolder.mTxt = (TextView)view.findViewById(R.id.id_index_gallery_item_text); return viewHolder;&#125;@Overridepublic void onBindViewHolder(final ViewHolder viewHolder, final int i) &#123; viewHolder.mImg.setImageResource(mDatas.get(i)); viewHolder.mTxt.setText(String.valueOf(i)); ....&#125; &#160;&#160;&#160;对比以上代码，可以看出在RecyclerView中， ViewHolder直接充当缓存的单位，然后convertView作为ViewHolder的成员变量保持在ViewHolder中，也就是说，假设没有屏幕显示10个条目，则会创建10个ViewHolder缓存起来，每次复用的是ViewHolder，所以他把getView这个方法变为了onCreateViewHolder，而ListView的复用机制则是利用静态的holder把conertiew里面包含的所有组件保存起来，并通过setTag将其与conertView捆绑在一起，convertView是复用对象。 ItemDecoration&#160;&#160;&#160;Decoration意为修饰，android的开发文档中有这样的说明：ItemDecoration允许程序添加自定义的绘画或者布局边距，常用于分割列表子项，突显视觉上的界限。这类似于listView中的devider，但listView中所画的分割线是在Listview内部实现，对于开发者来说，灵活性较低。在新的RecyclerView中很好的解决这个问题，RecycView把对Decoration的控制交给了开发者，RecyclerView默认不带Decoration，但继承自RecyclerView.ItemDecoration开发者通过重写public void onDrawOver(Canvas c, RecyclerView parent)和public void getItemOffsets(Rect outRect, int itemPosition, RecyclerView parent)等，结合CardView的使用可以实现不错的视觉效果，下面为默认模式和加入简单划线对比： LayoutManager&#160;&#160;&#160;这个类决定视图被放在画面中哪个位置，但这只是它的众多职责之一。它可以管理滚动和循环利用，ListView则不能设置为横向。在最新的support v7 中LayoutManager有三个实现类，LinearlayoutManager,GridLayoutManager和StaggeredGridLayoutManager，LayoutManager可以模拟列表的视图，但是没有页眉和页尾。开发者可以仿照原生给出的LinearLayoutManager代码创建一个BaseLayoutManager，并且基于此进行扩展。而在Android L以前，为了给LIstView后期进行扩展，ListVIew的主体功能实现都放在AbsListView，然后通过ListView，和GridVIew实现不同的布局，而在RecyclerVIew中则可以通过设置不同的LayoutManager达到此效果。下面给出RecyclerVIew不同的布局效果： &#160;&#160;&#160;另外需要说明一下，使用RecylerView时必须加入LayoutManager，否则会出现报错。 ItemAnimator&#160;&#160;&#160;在ListView中我们通常在Adatper 的getview（）的时候对特定的item做动画。在RecyclerView中加入了新的实现方法。ItemAnimator同样是RecyclerView中的的抽象类，在V7包中给出了默认的实现类DefaultItemAnimator（渐隐），开发者同样的可以通过继承RecyclerView.ItemAnimator,参考DefaultAnimator建立BaseItemAnimator，然后对其进行扩展打造不同的动画效果，使用时通过调用Recycler.Adapter中的notifyItemChanged（）notifyItemInserted（）等方法触发，如果是使用默认的动画效果，直接添加如下代码即可。 12final DefaultItemAnimator defaultItemAnimator = new DefaultItemAnimator();recyclerView.setItemAnimator(defaultItemAnimator); 版权声明：本文为博主原创文章，转载请注明出处KidSea]]></content>
      <tags>
        <tag>安卓</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mvc、Mvp、Mvvm的使用]]></title>
    <url>%2F2017%2F01%2F09%2FMvc%E3%80%81Mvp%E3%80%81Mvvm%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[前言 MVC的概念很早就知道，现在发现还有MVP、MVVM，那么这些设计模式有什么区别呢？简单谈一下自己的理解 内容前言&#160;&#160;&#160;MVC、MVP和MVVM都是为了解决界面呈现和逻辑代码分离而出现的模式。经典的MVC模式是M-V-X模式的老祖宗，MVP和MVVM都是在MVC的基础上演化而来，和MVC框架模式一样，Model模型处理数据代码。这些架构的目的都是为了提高代码的复用率、降低代码的耦合度、便于模块测试、版本的迭代更新，下面对每个架构进行简单的介绍与使用。 Mvc架构概述&#160;&#160;&#160;MVC全名是Model View Controller，如下图，是模型(model)－视图(view)－控制器(controller)的缩写，一种软件设计典范，用一种业务逻辑、数据、界面显示分离的方法组织代码，在改进和个性化定制界面及用户交互的同时，不需要重新编写业务逻辑，是Java企业级应用的典型架构,当然Android中界面部分也采用了当前比较流行的MVC框架，笔者在最开始接触android的时候用的比较多的是Mvc架构。 Mvc模式 &#160;&#160;&#160;如上图所示，其中M层处理数据，业务逻辑等；V层处理界面的显示结果；C层起到桥梁的作用，来控制V层和M层通信以此来达到分离视图显示和业务逻辑层。 Android中的Mvc&#160;&#160;&#160;在Android中： 视图层：一般采用XML文件进行界面的描述，这些XML可以理解为AndroidApp的View。使用的时候可以非常方便的引入。同时便于后期界面的修改。逻辑中与界面对应的id不变化则代码不用修改，大大增强了代码的可维护性。 控制层：Android的控制层的重任通常落在了众多的Activity的肩上。这句话也就暗含了不要在Activity中写代码，要通过Activity交割Model业务逻辑层处理，这样做的另外一个原因是Android中的Actiivity的响应时间是5s，如果耗时的操作放在这里，程序就很容易被回收掉。 模型层(Model)：我们针对业务模型，建立的数据结构和相关的类，就可以理解为AndroidApp的Model，Model是与View无关，而与业务相关的。对数据库的操作、对网络等的操作都应该在Model里面处理，当然对业务计算等操作也是必须放在的该层的。就是应用程序中二进制的数据。 例子&#160;&#160;&#160;请访问下面地址下载代码Mvc,例子很简单，就是一个验证登入的例子，但是能很好的代入Mvc的特点。 Android中的Mvc的缺点&#160;&#160;&#160;MVC虽然将界面呈现和逻辑代码分离了,但是在实际的Android开发中并没有完全起到想要的作用。View对应的XML文件实际能做的事情很少，很多界面显示由Controllor对应的Activity给做了，这样使得Activity变成了一个类似View和Controllor之间的一个东西。如果是小型项目，MVC是没任何问题的。因为项目比较小嘛，开发周期比较短，Controllor臃肿点也可以理解。假设项目越来越来，尤其是再加上比较复杂的逻辑，这时候一个Activity几千行代码就比较蛋疼了，再加点迷之缩进，那酸爽~~啧啧。所以MVC比较适用于快速开发的小型项目。 &#160;&#160;&#160;因为在在Android开发中，Activity并不是一个标准的MVC模式中的Controller，它的首要职责是加载应用的布局和初始化用户 界面，并接受并处理来自用户的操作请求，进而作出响应。随着界面及其逻辑的复杂度不断提升，Activity类的职责不断增加，以致变得庞大臃肿。 Mvp架构概述&#160;&#160;&#160;MVP从更早的MVC框架演变过来，与MVC有一定的相似性：Controller/Presenter负责逻辑的处理，Model提供数据，View负责显示。 Mvp模式 &#160;&#160;&#160;MVP框架由3部分组成：View负责显示，Presenter负责逻辑处理，Model提供数据。在MVP模式里通常包含3个要素（加上View interface是4个）： View:负责绘制UI元素、与用户进行交互(在Android中体现为Activity) Model:负责存储、检索、操纵数据(有时也实现一个Model interface用来降低耦合) Presenter:作为View与Model交互的中间纽带，处理与用户交互的负责逻辑。 View interface:需要View实现的接口，View通过View interface与Presenter进行交互，降低耦合，方便进行单元测试 与Mvc的区别&#160;&#160;&#160;两种模式的主要区别：View与Model并不直接交互，而是通过与Presenter交互来与Model间接交互。而在MVC中View可以与Model直接交互通常View与Presenter是一对一的，但复杂的View可能绑定多个Presenter来处理逻辑。而Controller是基于行为的，并且可以被多个View共享，Controller可以负责决定显示哪个ViewPresenter与View的交互是通过接口来进行的，更有利于添加单元测试。 例子&#160;&#160;&#160;请访问下面地址下载代码Mvp ,例子是在Mvc的基础先进行改进的，从Mvp的例子里可以看出： 在MVP中，Activity的代码不臃肿； 在MVP中，Model(IUserModel的实现类)的改动不会影响Activity(View)，两者也互不干涉，而在MVC中会； 在MVP中，IUserView这个接口可以实现方便地对Presenter的测试； 在MVP中，UserPresenter可以用于多个视图，但是在MVC中的Activity就不行。 Mvp的缺点&#160;&#160;&#160;MVP模式虽然很好，但是增加了很多的接口和实现类。代码逻辑虽然清晰，但是代码量要庞大一些。当刚接手一个烂尾的MVP模式，如果事先没了解过MVP，会不会一脸的懵逼。所以MVP比较适用于中小型的项目，大型项目慎用。 Mvvm架构概述&#160;&#160;&#160;MVVM可以算是MVP的升级版，其中的VM是ViewModel的缩写，ViewModel可以理解成是View的数据模型和Presenter的合体，ViewModel和View之间的交互通过Data Binding完成，而Data Binding可以实现双向的交互，这就使得视图和控制层之间的耦合程度进一步降低，关注点分离更为彻底，同时减轻了Activity的压力。 Mvc模式 架构的演进&#160;&#160;&#160;MVC -&gt; MVP -&gt; MVVM 这几个软件设计模式是一步步演化发展的，MVVM 是从 MVP 的进一步发展与规范，MVP 隔离了MVC中的 M 与 V 的直接联系后，靠 Presenter 来中转，所以使用 MVP 时 P 是直接调用 View 的接口来实现对视图的操作的，这个 View 接口的东西一般来说是 showData、showLoading等等。M 与 V已经隔离了，方便测试了，但代码还不够优雅简洁，所以 MVVM 就弥补了这些缺陷。在 MVVM 中就出现的 Data Binding 这个概念，意思就是 View 接口的 showData 这些实现方法可以不写了，通过 Binding 来实现。 例子&#160;&#160;&#160;请访问下面地址下载代码Mvvm ,对于Mvvm读者用的不多，所以只能是班门弄斧了，想要多了解的话，去问问度娘或谷歌吧。 版权声明：本文为博主原创文章，转载请注明出处KidSea]]></content>
      <tags>
        <tag>安卓</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[读深入理解Java虚拟机]]></title>
    <url>%2F2017%2F01%2F08%2F%E7%AC%AC%E4%B8%89%E7%AB%A0%2F</url>
    <content type="text"><![CDATA[前言 简单谈下Java虚拟机的垃圾回收机制 内容垃圾回收机制前言&#160;&#160;&#160;对于Java来说，垃圾回收大部分人都把这个技术作为其伴生的产物，但是实际上GC技术的历史远比Java久远。并且对于我们的程序来说，垃圾回收机制的存在是十分有必要的，在通常情况下，垃圾收集对性能的影响一般有以下几个一般有以下几点： 内存泄露 程序暂停 程序吞吐量下降 响应时间慢 垃圾收集的一些基本概念 Concurrent Collector: 收集的同时可运行其他的工作进程。 Parallel Collector: 使用多CPU进行垃圾收集。 Stop-the-word(STW): 收集时必须暂停其他所有的工作进程。 Sticky-reference-count： 对于使用“引用计数”（reference count）算法的GC，如果对象的计数器溢出，则起不到标记某个对象是垃圾的作用了，这种错误称为sticky-reference-count problem，通常可以增加计数器的bit数来减少出现这个问题的几率，但是那样会占用更多空间。一般如果GC算法能迅速清理完对象，也不容易出现这个问题。 Mutator：mutate的中文是变异，在GC中即是指一种JVM程序，专门更新对象的状态的，也就是让对象“变异”成为另一种类型，比如变为垃圾。 On-the-fly：用来描述某个GC的类型：on-the-fly reference count garbage collector，此GC不用标记而是通过引用计数来识别垃圾。 Generational gc：这是一种相对于传统的“标记-清理”技术来说，比较先进的gc，特点是把对象分成不同的generation，即分成几代人，有年轻的，有年老的。这类gc主要是利用计算机程序的一个特点，即“越年轻的对象越容易死亡”，也就是存活的越久的对象越有机会存活下去。 吞吐量与响应时间&#160;&#160;&#160;牵扯到垃圾收集，还需要搞清楚吞吐量与响应时间的含义 吞吐量是对单位时间内完成的工作量的量度。如：每分钟的 Web 服务器请求数量。 响应时间是提交请求和返回该请求的响应之间使用的时间。如：访问Web页面花费的时间。 &#160;&#160;&#160;吞吐量与访问时间的关系很复杂，有时可能以响应时间为代价而得到较高的吞吐量，而有时候又要以吞吐量为代价得到较好的响应时间。而在其他情况下，一个单独的更改可能对两者都有提高。通常，平均响应时间越短，系统吞吐量越大；平均响应时间越长，系统吞吐量越小； 但是，系统吞吐量越大，未必平均响应时间越短；因为在某些情况（例如，不增加任何硬件配置）吞吐量的增大，有时会把平均响应时间作为牺牲，来换取一段时间处理更多的请求。 &#160;&#160;&#160;针对于Java的垃圾回收来说，不同的垃圾回收器会不同程度地影响这两个指标。例如：并行的垃圾收集器，其保证的是吞吐量，会在一定程度上牺牲响应时间。而并发的收集器，则主要保证的是请求的响应时间。 GC的回收流程 找出堆中活着的对象 释放死对象占用的资源 定期调整活对象的位置 GC算法 Mark-Sweep 标记-清除 Mark-Sweep-Compact 标记-整理 Copying Collector 复制算法 Mark-标记从”GC roots”开始扫描(这里的roots包括线程栈、静态常量等)，给能够沿着roots到达的对象标记为”live”,最终所有能够到达的对象都被标记为”live”,而无法到达的对象则为”dead”。效率和存活对象的数量是线性相关的。 Sweep-清除扫描堆，定位到所有”dead”对象，并清理掉。效率和堆的大小是线性相关的。 Compact-压缩对于对象的清除，会产生一些内存碎片，这时候就需要对这些内存进行压缩、整理。包括：relocate(将存货的对象移动到一起，从而释放出连续的可用内存)、remap(收集所有的对象引用指向新的对象地址)。效率和存活对象的数量是线性相关的。 Copy-复制将内存分为”from”和”to”两个区域，垃圾回收时，将from区域的存活对象整体复制到to区域中。效率和存活对象的数量是线性相关的。 &#160;&#160;&#160;其中，Copy对比Mark-sweep 内存消耗：copy需要两倍的最大live set内存；mark-sweep则只需要一倍。 效率上：copy与live set成线性相关，效率高；mark-sweep则与堆大小线性相关，效率较低。 分代收集&#160;&#160;&#160;分代收集是目前比较先进的垃圾回收方案。有以下几个相关理论: 分代假设：大部分对象的寿命很短，“朝生夕死”，重点放在对年青代对象的收集，而且年青代通常只占整个空间的一小部分。 把年青代里活的很长的对象移动到老年代。 只有当老年代满了才去收集。 收集效率明显比不分代高。 &#160;&#160;&#160;HotSpot虚拟机的分代收集，分为一个Eden区、两个Survivor去以及Old Generation/Tenured区，其中Eden以及Survivor共同组成New Generatiton/Young space。通常将对New Generation进行的回收称为Minor GC;对Old Generation进行的回收称为Major GC，但由于Major GC除并发GC外均需对整个堆以及Permanent Generation进行扫描和回收，因此又称为Full GC。 &#160;&#160;&#160;分代收集中典型的垃圾收集算法组合描述如下： 年青代通常使用Copy算法收集，会stop the world 老年代收集一般采用Mark-sweep-compact, 有可能会stop the world，也可以是concurrent或者部分concurrent。 &#160;&#160;&#160;那么何时进行Minor GC、何时进行Major GC? 一般的过程如下： 对象在Eden Space完成内存分配 当Eden Space满了，再创建对象，会因为申请不到空间，触发Minor GC，进行New(Eden + S0 或 Eden S1) Generation进行垃圾回收 Minor GC时，Eden Space不能被回收的对象被放入到空的Survivor（S0或S1，Eden肯定会被清空），另一个Survivor里不能被GC回收的对象也会被放入这个Survivor，始终保证一个Survivor是空的 在Step3时，如果发现Survivor区满了，则这些对象被copy到old区，或者Survivor并没有满，但是有些对象已经足够Old，也被放入Old Space。 当Old Space被放满之后，进行Full GC &#160;&#160;&#160;但这个具体还要看JVM是采用的哪种GC方案。总而言之，内存回收和垃圾收集是比较复杂的原理，很多时候是影响系统性能、并发能力的主要的因素之一，深入理解其运作，对编写的程序有一点影响力。 版权声明：本文为博主原创文章，转载请注明出处KidSea]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[逝去的2016，归来的2017]]></title>
    <url>%2F2017%2F01%2F01%2F%E6%88%91%E7%9A%842016%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[前言致我已逝去的2016，迎我即将到来的2017 内容 题记&#160;&#160;&#160;人生中总有一段时光会让人突然成长，突然想明白很多事，好似看懂了全世界。 正文小谈&#160;&#160;&#160;借着跨年的喜悦气氛，我翻阅了一下自己空间里整个2016年所记录下来的说说踪迹，感觉2016年像梦一样的从我脑海里一闪而过，在这一年里，我仿佛做了很多事情，经历了很多事情，又仿佛经历的没有想象的那么多，感觉这些记忆是那么近，又那么的远，这大概就叫矛盾吧！！ &#160;&#160;&#160;经常会听到身边有人跟我说，“你是我身边最会写说说的男的，你看你空间里面那么多说说”。哈哈，我承认他说的没错，但是我会去想，为什么我会时不时的发个说说，感觉像是在证明着什么或者是记录着什么。 &#160;&#160;&#160;我给自己的解释是，一方面，这也许就是害怕孤独的一种表现，可能知道我的人，都知道我是一个喜欢热闹的、喜欢瞎搞的、喜欢交朋友、喜欢….，发说说或者是朋友是为了让大家时刻记着，嗯，我身边有这么一个人，他喜欢发说说，哈哈；另外一方面我可能是想多记录下自己一天中经历的事情的所感所想，这样，也许在未来的某个日子，我去翻这些说说的时候，我能记起当时这天我在经历着生命，可能会让自己有一种回味的感觉，我不知道大家有没有写日记的习惯，反正我很少会去写，因为有的时候记些流水账，对我来说，很无趣，所以可能说说跟朋友圈就是我日记的一个替代品，只是想做为自己的一种习惯在延续着，哈哈。 回顾2016&#160;&#160;&#160;2016的大事件太多，太多，“与队友们完成美国数学建模比赛”，“在重庆遇见人生的一场雪（几十年不遇）”，“给弟弟的一封信”，“美国小哥的礼物”，“以为朋友在台湾被地震牵连”，“在家过年”，“看了一年很棒的NBA全明星”，“协会招新”，“校招提前批笔试”，“小李子圆了奥斯卡梦”，“完成2次课程设计”，“模拟双选会”，“全国计算机等级三级考试考了个59分（这尼玛）”，“库昊全票MVP”，“协会换届”，“第一次面试”，“得罪最不想得罪的人”，“见证LBJ带领的骑士创造历史”，“搭博客”，“找工作”，“面试魅族”，“面试华为”，“感受前一天天堂，后一天地狱的人生”，“找到工作”，“离校”，“实习”，“初入社会”，“坚持的事”等等….. 找工作&#160;&#160;&#160;对于找工作，如果现在有人问我，你后不后悔不继续读书而选择工作，我的答案是肯定的；如果有人问，你后不后悔进入自己选择的这家公司，答案也是肯定的。因为既然是自己选择的路，为什么要去后悔呢，可能最多的是有遗憾吧，我也庆幸自己能够足够幸运找到合适自己的工作，以及能够在这么一个大家庭里工作。 离校&#160;&#160;&#160;时间总是不和任何人开玩笑，悄无声息地就从我们手中悄悄溜走。转眼之间就到大四了，找到了工作，也为自己盘算着离校的时间去实习。虽然以前不觉得，但是真的一个人如果想到自己要离开校园了，离开自己一直生活的环境，离开自己最熟悉的那群人，多少都会有些伤感。依稀记得，那天踏出校门，回头望去，只觉得那就是青春，可能以后都经历不了了，但是还是很高兴你在我的世界里出现。 初入社会&#160;&#160;&#160;一直以来我都是一个比较独立自主的人，所以踏入社会，我可能会相对来说更容易适应。来到魅族实习，有了新的环境，认识了新的人与事。感受到了魅族的热情，感受到工作的热情，感受到了珠海的魅力，还有很多….，我喜欢这样的生活，充实而又满足，初入社会，我要做的还有很多，我相信未来会更好。 见证历史&#160;&#160;&#160;不得不说，2016年是我看NBA以来最热血澎湃的一年。首先，今年的NBA全明星上，见证了可能是历史上少有的，精彩的扣篮大赛，见证了两个扣篮新星的奇迹表演；其次，见证了LBJ带领骑士创造了历史；最后，见证LBJ在新赛季创新的一个个新的历史，感谢有你。 坚持的事 健身，强度不是很大，但是我相信只要一直坚持下去，至少对身体是有好处的。 写博客，今年才开始写博客，记录自己的学习经历。 看书，读万卷书，行万里路。 看电影，看经典的电影，陶冶情操。 周末出去走走，希望不要宅在家里。 学习，巩固技术知识。 看新闻，看资讯，了解前沿技术，知识。 学英语。 思考。 理想。 我的成长 社交圈变广，慢慢扩展视野； 慢慢学会管理时间，明白时间的重要性； 初入社会，慢慢适应社会； 明白了这世界上有些事是有规律的，违背了规律可能会遇到麻烦； 制定了一个小目标 … 2017年展望&#160;&#160;&#160;保持积极的态度，不骄不躁； &#160;&#160;&#160;严肃对待时间，记录生活； &#160;&#160;&#160;多出去走走，体验生活； &#160;&#160;&#160;坚持看书，看电影； &#160;&#160;&#160;坚持健身，锻炼身体； &#160;&#160;&#160;技术更上一层楼； &#160;&#160;&#160;让家慢慢变好； &#160;&#160;&#160;当然也希望自己越活越年轻，哈哈哈哈哈； &#160;&#160;&#160;还有很多… 最后&#160;&#160;&#160;人生最好的心态是平静，我知道自己可能无法做到，但是，我会慢慢向它靠拢。 &#160;&#160;&#160;2017年给自己的第一句话是，“当自己做了正确的事，就会感觉自己在地球的重量又会增加了些”。 &#160;&#160;&#160;2016年，感谢遇到的所有人，遇到的所有事，2017年，加油！ 版权声明：本文为博主原创文章，转载请注明出处KidSea]]></content>
      <tags>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[读深入理解Java虚拟机]]></title>
    <url>%2F2016%2F12%2F31%2F%E7%AC%AC%E4%BA%8C%E7%AB%A0%2F</url>
    <content type="text"><![CDATA[前言 看了第二章的内容，大致了解了下Java虚拟机的内存分划，以及内存操作导致的内存溢出异常，对于我以后使用Java编程有很大帮助 内容Java 存储区域与内存溢出异常前言&#160;&#160;&#160;对于c/c++的程序开发人员来说，内存管理既是他们的权力也是让他们头疼的问题，而对于Java开发人员来说，在虚拟机的帮助下，我们不需要为每个new操作去配对delete/free代码，因此也不容易出现内存泄漏和内存溢出的问题，但是如果不了解虚拟机的内存管理机制，一旦出现内存问题，很难排查问题，笔者在读完深入理解Java虚拟机后做了以下的笔记，希望对于一些初识者有一些帮助。 运行时数据区域&#160;&#160;&#160;Java虚拟机在执行Java程序的过程中把它所管理的内存划分成若干个不同的数据区域，各自在运行时起到不同的用途。其具体分区情况，如下图所示。 Java虚拟机运行事数据区 &#160;&#160;&#160;下面对各个区域进行简单的介绍 程序计数器： 一块较小的内存单元，是当前线程所执行的字节码的行号指示器； Java虚拟机栈：描述Java方法执行的内存模型，每个方法从调用到执行完毕，对应于一个栈帧在虚拟机栈中入栈到出栈的过程； 本地方法栈： 与虚拟机栈发挥的作用比较相似，虚拟机栈为虚拟机执行Java方法服务，而本地方法栈是虚拟机使用到的Native方法服务。 Java堆： Java堆是Java虚拟机所管理的内存中最大的一块，是所有线程共享的一块内存区域，在虚拟机启动时创建,用以存放对象实例。 方法区： 与Java堆一样，是各个线程共享的内存区域，用以存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。 运行时常量池： 方法区的一部分，用以存放编译期生成的各种字面量和符号作用； 直接内存: 这部分不是虚拟机运行时数据区的一部分，也不是Java虚拟机规范中定义的内存区，但是在运行是这个部分内存也频繁的使用。 虚拟机对象对象的创建&#160;&#160;&#160;Java是一门面向对象的编程语言，在Java程序运行过程种无时无刻都有对象被创建出来。而创建对象的命令就是new,当虚拟机遇到一条new指令的时候，首先将去检查这个指令的参数是否能在常量池种定位到一个类的符号作用，并且检查这个符号引用代表的类是否被加载、解析和初始化过。如果没有，那就先执行相应的类加载过程，在类加载检查通过后，虚拟机才会对新生的对象分配内存，并且内存大小可确定，在内存分配完后，虚拟机要将内存分配到的内存空间初始化为零值，为了保证对象实例在Java代码中可以不赋值直接使用，接下来虚拟机将会对对象进行必要的设置。 &#160;&#160;&#160;在完成以上工作后，一个对象才算真正的被创建起来了。 对象的内存布局&#160;&#160;&#160;在虚拟机中，对象在内存中的存储的布局被分为3块区域：对象头、实例数据和对齐填充。 对象头： 对象头一部分用以存储对象自身的运行数据，一部分是它指向的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例； 实例数据： 是对象真正存储的有效数据，也是在程序代码中所定义的各种类型的字段内容； 对齐填充： 这部分并不是必然存在的，也没有特殊的含义，只是起占位符的作用。 对象的访问定位&#160;&#160;&#160;建立对象是为了使用对象，我们的Java程序需要通过栈上的reference数据来操作堆上的具体对象。 &#160;&#160;&#160;Java虚拟机规范规定了一个指向对象的引用，但是没有定义这个引用应该通过何种方式去定位、访问堆中的对象的具体位置，而是取决于虚拟机的实现而定。目前主流的访问方式有使用句柄和直接指针这两种方式。 使用句柄，Java堆中会划出一块内存来做句柄池，reference中存储的就是对象的句柄地址，而句柄中包含了对象实例数据和类型数据各自的具体地址信息，其原理如下图所示。 使用句柄访问 使用直接指针访问，那么Java堆对象的布局需要考虑如何放置访问类型数据的相关信息，而reference中存储的直接就是对象地址，其原理如下图所示。 使用直接指针访问 &#160;&#160;&#160;两种对象访问方式各有优势，使用句柄来访问的最大好处就是reference中存储的是隐定的句柄地址，在对象被移动时只会改变句柄中的实例数据指针，而reference本身不需要修改；而使用直接指针访问的最大好处就是速度快，节省时间开销。 内存溢出异常&#160;&#160;&#160;在Java虚拟机规范中，定义了两种异常，一种是线程请求的栈深度大于虚拟机所允许的最大深度，将抛出StackOverflowError;另一种是虚拟机在扩展栈的时候无法申请到足够的内存空间，会抛出OutOfMemoryError异常，这两个异常都是我们平常编写程序时，必须要注意的，比如慎用static,数据库处理游标、文件等处理后是否释放资源，图片处理是否进行压缩、回收等。 版权声明：本文为博主原创文章，转载请注明出处KidSea]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[读深入理解Java虚拟机]]></title>
    <url>%2F2016%2F12%2F31%2F%E7%AC%AC%E4%B8%80%E7%AB%A0%2F</url>
    <content type="text"><![CDATA[前言最近从同事借了《深入理解Java虚拟机》，想着没事读读，做做读书笔记 内容 第一章 走进java前言&#160;&#160;&#160;如今，Java不仅仅是一门编程语言，还是一个由一系列计算机软件和规范形成的技术体系，这个技术体系提供了完整的用于软件开发和跨平台不熟的支持环境，并广泛应用于嵌入式系统、移动终端、企业服务器、大型机等各个场合。其具有以下特点： 结构严谨、面向对象的编程语言； 摆脱了硬件平台的束缚，实现了“一次编写，到处运行”的特点； 具有相对安全的内存管理和访问机制； 实现了热点代码检测和运行时编译及优化； 拥有一套完善的应用程序接口等… Java的技术体系&#160;&#160;&#160;从传统意义上来看，Sun官方所定义的Java技术体系包括以下几个组成部分： Java程序设计语言 各种硬件平台上的虚拟机 Class文件格式 Java Api类库 来自商业机构和开源社区的第三方Java类库 &#160;&#160;&#160;我们可以把Java程序设计语言、虚拟机、Java Api类库这三部分称之为JDK就是java开发的最小环境。把Java Api类库中的子集Java Se Api和虚拟机这两部分统称为JRE，即Java运行环境。Java技术体系可以分为四个平台，分别为： Java Card:支持一些Java小程序，运行在小内存设备里； Java Me: 支持Java程序运行在移动终端上； Java Se: 支持面向桌面级应用的Java平台； Java EE: 支持使用多层架构的企业级应用的Java平台。 Java发展史&#160;&#160;&#160;此处省略一万个字……总而言之现在发展到Java8了。 Java虚拟机发展史&#160;&#160;&#160;同上…. 展望Java技术的未来 模块化：模块化是解决应用系统与技术平台越来越复杂、越来越庞大问题的一个重要途径； 混合语言： 如今，单一的Java开发已经无法满足当前软件的复杂需求，为了更好解决问题，混合语言层出不穷，如Clojure,Jruby,Groovy等； 多核并行： Cpu硬件的发展方向已经从高频率转变到多核心，随着多核时代的到来，软件开发越来越多关注并行编程，Java也更加专注； 进一步丰富语言，语法； 64位虚拟机等。 版权声明：本文为博主原创文章，转载请注明出处KidSea]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android源码编译]]></title>
    <url>%2F2016%2F12%2F26%2F%E7%B3%BB%E7%BB%9F%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[前言 Android源码编译学习小结 内容 系统源码编译&#160;&#160;&#160;笔者最近在学习安卓系统源码的编译，为了能够印象深刻，粗略的总结了以下内容，希望对我一样的初学者有一些帮助。 系统编译的初始化指令&#160;&#160;&#160;对Android编译环境进行初始化很简单，分为两步。第一步打开终端输入source build/envseup.sh加载所需的文件。 $ source build/envseup.sh including device/asusource build/envseup.shs/grouper/vendorsetup.sh including device/asus/tilapia/vendorsetup.sh including device/generic/armv7-a-neon/vendorsetup.sh including device/generic/armv7-a/vendorsetup.sh including device/generic/mips/vendorsetup.sh including device/generic/x86/vendorsetup.sh including device/lge/mako/vendorsetup.sh including device/samsung/maguro/vendorsetup.sh including device/samsung/manta/vendorsetup.sh including device/samsung/toroplus/vendorsetup.sh including device/samsung/toro/vendorsetup.sh including device/ti/panda/vendorsetup.sh including sdk/bash_completion/adb.bash &#160;&#160;&#160;从命令的输出可以知道，文件build/envsetup.sh在加载的过程中，又会在device目录中寻找那些名称为vendorsetup.sh的文件，并且也将它们加载到当前终端来。另外，在sdk/bash_completion目录下的adb.bash文件也会加载到当前终端来，它是用来实现adb命令的bash completion功能的。也就是说，加载了该文件之后，我们在运行adb相关的命令的时候，通过按tab键就可以帮助我们自动完成命令的输入。 &#160;&#160;&#160;第二步是执行命令lunch，如下所示： $ lunch You&apos;re building on Linux Lunch menu... pick a combo: 1. full-eng 2. full_x86-eng 3. vbox_x86-eng 4. full_mips-eng 5. full_grouper-userdebug 6. full_tilapia-userdebug 7. mini_armv7a_neon-userdebug 8. mini_armv7a-userdebug 9. mini_mips-userdebug 10. mini_x86-userdebug 11. full_mako-userdebug userdata.img：将被挂载为 /data，包含了应用程序相关的数据以及和用户相关的数据。 12. full_maguro-userdebug 13. full_manta-userdebug 14. full_toroplus-userdebug 15. full_toro-userdebug 16. full_panda-userdebug Which would you like? [full-eng] &#160;&#160;&#160;我们看到lunch命令输出了一个Lunch菜单，该菜单列出了当前Android源码支持的所有设备型号及其编译类型。例如，第一项“full-eng”表示的设备“full”即为模拟器，并且编译类型为“eng”即为工程机。 &#160;&#160;&#160;当我们选定了一个Lunch菜单项序号(1-16)之后，按回车键，就可以完成Android编译环境的初始化过程。例如，我们选择1，可以看到以下输出： Which would you like? [full-eng] 1 ============================================ PLATFORM_VERSION_CODENAME=REL PLATFORM_VERSION=4.2 TARGET_PRODUCT=full TARGET_BUILD_VARIANT=eng TARGET_BUILD_TYPE=release TARGET_BUILD_APPS= TARGET_ARCH=arm TARGET_ARCH_VARIANT=armv7-a HOST_ARCH=x86 HOST_OS=linux HOST_OS_EXTRA=Linux-3.8.0-31-generic-x86_64-with-Ubuntu-13.04-raring HOST_BUILD_TYPE=release BUILD_ID=JOP40C OUT_DIR=out ============================================ &#160;&#160;&#160;我们可以看到，lunch命令帮我们设置好了很多环境变量。通过设置这些环境变量，就配置好了Android编译环境。 源码编译指令&#160;&#160;&#160;在执行编译指令之前，为了确保编译环境的Api匹配所要编译的源码版本，我们会先进行make update-api进行Api更新，在此步骤之中可能会遇到各种问题，请读者们自行上网搜索解决，直到更新完成后执行make指令进行编译，注：对于整个系统源码编译，必须在系统源码根目录下执行。 &#160;&#160;&#160;在Android编译系统在编译过程中，会通过根目录下的Makefile脚本加载build/core/main.mk脚本，接着build/core/main.mk脚本又会加载build/core/Makefile脚本，而Android系统镜像文件就是由build/core/Makefile脚本负责打包生成的。 编译打包过程 首先，每个模块对应一个android.mk，对应于各个模块的makefile，该文件中只需定义一些变量，就能触发一个模块的编译，不同模块的编译方式不同，当然每个模块必须遵守编译规则； 其次，每个模块相互独立，但是利用include指令可以将各个模块，添加如main.mk文件中，并有先后顺序，最终各个零散的makefile文件汇聚成最终的makefile文件； 最后，通过以上过程讲所有模块编译打包。 打包的产物&#160;&#160;&#160;所有的编译产物都将位于 /out 目录下，该目录下主要有以下几个子目录： /out/host/：该目录下包含了针对主机的 Android 开发工具的产物。即 SDK 中的各种工具，例如：emulator，adb，aapt 等。 /out/target/common/：该目录下包含了针对设备的共通的编译产物，主要是 Java 应用代码和 Java 库。 /out/target/product//：包含了针对特定设备的编译结果以及平台相关的 C/C++ 库和二进制文件。其中，是具体目标设备的名称。 /out/dist/：包含了为多种分发而准备的包，通过“make disttarget”将文件拷贝到该目录，默认的编译目标不会产生该目录。 编译生成的镜像文件&#160;&#160;&#160;Build 的产物中最重要的是三个镜像文件，它们都位于 /out/target/product// 目录下。 system.img：包含了 Android OS 的系统文件，库，可执行文件以及预置的应用程序，将被挂载为根分区。 ramdisk.img：在启动时将被 Linux 内核挂载为只读分区，它包含了 /init 文件和一些配置文件。它用来挂载其他系统镜像并启动 init 进程。 userdata.img：将被挂载为 /data，包含了应用程序相关的数据以及和用户相关的数据。 版权声明：本文为博主原创文章，转载请注明出处KidSea]]></content>
      <tags>
        <tag>安卓</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[程序员励志名言]]></title>
    <url>%2F2016%2F11%2F17%2F%E7%A8%8B%E5%BA%8F%E5%91%98%E5%8A%B1%E5%BF%97%E5%90%8D%E8%A8%80%2F</url>
    <content type="text"><![CDATA[前言 1、作为一个真正的程序员，首先应该尊重编程，热爱你所写下的程序，他是你的伙伴，而不是工具。 2、程序员可以让步，却不可以退缩，可以羞涩，却不可以软弱，总之，程序员必须是勇敢的。 3、编程是一种单调的生活，因此程序员比普通人需要更多的关怀，更多的友情。 4、程序不是年轻的专利，但是，他属于年轻。 内容 1、作为一个真正的程序员，首先应该尊重编程，热爱你所写下的程序，他是你的伙伴，而不是工具。 2、程序员可以让步，却不可以退缩，可以羞涩，却不可以软弱，总之，程序员必须是勇敢的。 3、编程是一种单调的生活，因此程序员比普通人需要更多的关怀，更多的友情。 4、程序不是年轻的专利，但是，他属于年轻。 5、没有情调，不懂浪漫，也许这是程序员的一面，但拥有朴实无华的爱是他们的另一面。 6、一个好汉三个帮，程序员同样如此。 7、一个100行的代码调试都可能会让程序员遇到很多挫折，所以，面对挫折，我们永远不能低头。 8、调试完一个动态连接函数，固然值得兴奋，但真正的成功远还在无数个函数之后。 9、程序是我的生命，但我相信爱她甚过爱我的生命。 10、信念和目标，必须永远洋溢在程序员内心。 11、就算我们站在群山之颠，也别忘记雄鹰依旧能从我们头顶飞过。骄傲是比用JAVA进行底层开发更可笑的东西。 12、这句话不是很文雅，彻底鄙视那些害怕别人超越自己而拒绝回答别人问题的程序员。 13、如果调试一个程序让你很苦恼，千万不要放弃，成功永远在拐角之后，除非你走到拐角，否则你永远不知道你离他多远，所以，请记住，坚持不懈，直到成功。 14、最累的时候，家人是你最好的归宿。 15、退一步海阔天空，这是一种应有的心境。 16、如果你喜欢底层开发，千万不要勉强自己去搞VC，找到你最真实的想法，程序员最不能忍受的就是万精油。 17、IF（BOOL 学习= =FALSE）BOOL 落后=TRUE；不断的学习，我们才能不断的前进。 18、你的一个程序有时正常有时不正常，而你已经完全遵循编程的规则，为什么？事实上我认为相信只要遵循别人所说就能得到想当然的结果的人其实是个傻瓜。 19、编程中我们会遇到多少挫折？表放弃，沙漠尽头必是绿洲。 20、非优秀的程序员常常把空间和时间消耗殆尽，优秀的程序员则总是有足够的空间和时间去完成编程任务，而且配合近乎完美。 21、我们应该重视团队的精神，一个人作用再大，也不过是一碗水中比较大的一粒水珠而已。 22、无私奉献不是天方夜谭，有时候，我们也可以做到。 23、程序员是值得尊敬的，程序员的双手是魔术师的双手，他们把枯燥无味的代码变成了丰富多彩的软件。 24、你比他好一点，他不会承认你，反而会嫉妒你，只有你比他好很多，他才会承认你，然后还会很崇拜你，所以要做，就一定要比别人做得好很多。 25、对程序员来说大部分的快乐是从解决问题，特别是独立解决问题中获得，而不是从这个CASE有多大，奖金有多少中获得。 26、人呐，眼光放得长远一些，看到的东西也会多一些，生活也就会过得更有意义一点。 27、程序员，他们想的是什么？他们想的永远都是技术，他们崇尚的也永远都是技术。 28、其实你找不到错误不代表错误不存在，同样你看不到技术比你牛的人并不代表世界上没有技术比你牛的人。 29、一个人静静坐在电脑面前写代码的感觉，那是什么感觉？那是武林高手闭关修炼的感觉。 30、程序员中的前辈在谈到一个人学写程序有没有前途时，总是会说：“学程序不光要能吃苦能用功，还得看有没有sense，没sense的人，就是再怎么学，再怎么给他讲效果都不好。” 31、为什么很多人都想成功，但成功的人只是极少数？不是因为成功有多困难，其实成功简单得很，只要你一开始都有计划，并且能一直做下去，总会成功的。关键是如何面对成功，你失败了，起码还有人同情你，而成功了，连得到同情的机会都没有。 32、一匹真正的好马，即使在鞭子的影子下，也能飞奔。 33、如果你没有把握做到，最好就不要承诺，你什么也不承诺，至少别人不会看不起你。 34、一本好书，就像高级武功秘籍一样，哪怕只是从里面领悟到个一招半势，功力提升起来都是惊人的。 35、永不放弃，永不放弃又有两个原则，第一个原则是永不放弃，第二个原则就是：当你想放弃时回头看第一个原则。 36、疯狂的程序员决不是靠狂妄和拼命的程序员，而是能够脚踏实地，持续努力的程序员，一个程序员真正做到这两点，技术上去后，唯一能限制他的只有想象力，到那个时候才算“疯狂的程序员”，这种程序员，才能令对手无比恐惧。 37、硬的怕横的，横的怕不要命的，疯子都是不要命的，所以疯子力量大，程序员只有一种，疯狂的程序员。 38、要么做第一个，要么做最好的一个。 39、理想如果不向现实做一点点屈服，那么理想也将归于尘土。 40、每一个问题都是一把锁，你要相信世界上一定有一把钥匙能打开这把锁，你也能找到这把钥匙。 41、所有的道理都是相通的，我们所做的并非是创造性的工作，所有的问题前人都曾经解决，所以我们更是无所畏惧，更何况我们不只有书店，而且有互联网，动动手脚就能找到需要的资料，我们只要认真研究就够了。所以当遇到困难时，请静下心来慢慢研究，因为只要用心，没有学不会的东西。 42、完美主义者常常因试图努力把一件事做好而放弃对新领域的尝试，从而使做事的机会成本增加，有时回头一看才发现，自己在某件事上，已经花了太多时间，而实际上，暂时的妥协可能并不会影响到最终完美结果的呈现，因为不但知识需要积累，事情之间也总是有关联的。 43、调试完一个动态连接函数，固然值得兴奋，但真正的成功远还在无数个函数之后。 44、“设计是一个发现问题、而不是发现解决方案的过程” —— Leslie Chicoine 45、“功能说明书里不存在可操作性” —— 37 Signals 46、“过去的代码都是未经测试的代码” —— Michael Feathers 47、“任何傻瓜都能写出计算机可以理解的代码。好的程序员能写出人能读懂的代码” —— Martin Fowler 48、“测试是来表明bug的存在而不是不存在” —— Edsger Dijkstra 49、“简单不先于复杂，而是在复杂之后” —— Alan Perlis 50、“Real developers ship” —— Jeff Attwood 51、“没有绝世神功” —— Frederick Brooks 52、“过去的33年里，我每天早上看着镜子问自己：“今天是我生命的最后一天吗？我是否要去做今天该做的事？”一天一天太多次是“不是”，我知道这需要改变…所有的事情——所有身外的期望，所有的骄傲，所有的对困难和失败的恐惧——这些东西在死亡面前立刻消失的无影无踪，只剩下真正重要的东西。想着自己即将死去，这是让我避免落入担心失去什么的陷阱里的最好的方法。” —— Steve Jobs 版权声明：本文为博主转载文章，转载请注明出处点这]]></content>
      <tags>
        <tag>文章</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[为自己的人生打工场]]></title>
    <url>%2F2016%2F10%2F17%2F%E4%B8%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E4%BA%BA%E7%94%9F%E6%89%93%E5%B7%A5%E5%9C%BA%2F</url>
    <content type="text"><![CDATA[前言 在中国，虽然找一份工作可能不是太困难的事情，但是，真正找一份理想的工作并不容易。 内容 在中国，虽然找一份工作可能不是太困难的事情，但是，真正找一份理想的工作并不容易。因此，珍惜现有的工作岗位是一个优秀员工时刻要牢记的。只要你把公司当作是自己实现抱负的平台，你就已经是公司的老板了。因为你已经和公司融为一体了，你的每一分努力都不会白费。 齐勃瓦出生在美国乡村，只接受过很短的学校教育。15岁那年，家中一贫如洗的他就到一个山村做了马夫。他不甘心一辈子做马夫，无时无刻不在寻找发展的机会。三年后，齐勃瓦终于来到钢铁大王卡内基所属的一个建筑工地打工。虽然他也是一个进城的农民工，但是，自从进入建筑工地那一天起，齐勃瓦就下定决心，要做同事中最优秀的人。当其他人在抱怨工作辛苦、薪水低的时候，齐勃瓦却默默地积累着工作经验，并自学建筑知识。晚上吃过晚饭，工友们往往扎在一起闲聊天或打扑克，只有齐勃瓦躲在角落里看书。有一天，公司经理到工地检查，视察工人宿舍时看见了齐勃瓦手中的书，又翻了翻他的笔记，什么也没说就走了。 第二天，经理把齐勃瓦叫到办公室问：“你学那些东西干什么？”齐勃瓦不慌不忙地回答说：“我想我们公司并不缺少打工者，缺少的是既有工作经验、又有专业知识的技术人员和管理者，是不是？”经理点了点头。 不久，齐勃瓦就被破格提升为技师，那些打工者中也有人讽刺挖苦齐勃瓦，但是他回答说：“我不光是在为老板打工，更不单纯是为了赚钱，我是在为自己的梦想打工。我们只能在工作业绩中提升自己，我要使自己工作所创造的价值远远超过所得的薪水。我把自己当作公司的主人，就能获得发展的机遇。” 正是抱定了这样的信念，他努力工作，刻苦钻研，系统地掌握了技术知识。就这样，齐勃瓦一步一步升到了总工程师的职位上。25岁那年，齐勃瓦终于做了这家建筑公司的总经理。 齐勃瓦的成功完全在于他自己的努力。他自从加入公司的那一天起就胸怀大志，为自己的目标去努力奋斗，公司反过来就成为他实现自己奋斗目标的平台和施展自己才华的舞台。正是由于这种目标加勤奋，齐勃瓦不仅做了建筑公司的总经理，在建筑公司建成了最大的布拉得钢铁厂时，他超人的工作热情和管理才能又被卡内基钢铁公司的天才工程师兼合伙人琼斯发现。琼斯立即推荐齐勃瓦做了自己的副手，主管全厂事务。两年后，琼斯因一次事故而丧生，齐勃瓦接任了厂长。由于齐勃瓦的积极努力和工作热情，加上他日渐成熟的管理艺术，布拉得钢铁厂成了卡内基钢铁公司的灵魂。几年过后，卡内基亲自任命齐勃瓦担任钢铁公司董事长。 我们讲齐勃瓦的故事，并非说只要努力，你就一定能够成为公司老板，而是说只要努力，只要付出比别人更多的工作热情，你的才华最终是不会被埋没的。前提是你必须把公司当作自己事业的舞台，以公司主人翁的心态去对待工作。 你在为谁打工？答案已经非常明确：你在为自己打工，为自己的人生打工！ 版权声明：本文为博主转载文章，转载请注明出处点这]]></content>
      <tags>
        <tag>文章</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git学习笔记]]></title>
    <url>%2F2016%2F10%2F17%2FGit%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[前言 趁着偷闲的时间，写了一篇 Git 学习笔记以便学习和今后回顾 内容 Git 基础学习Git 是一个开源的分布式版本控制工具，它的开发者是大名鼎鼎的 Linux 操作系统的作者 Linus Torvalds 。优点有速度快、完全分布式、允许成千上万个并行开发的分支、有能力高效管理类似 Linux 内核一样的超大规模项目。 学习 Git 最重要的是理解其内部原理，分清楚工作区、暂存区、版本库，还有就是理解 Git 跟踪并管理的是修改，而非文件。下面列举一下 Git 的一些特点: 1. 直接记录快照，而非差异比较 Git 和其它版本控制系统的主要差别在于 Git 对待数据的方法。 概念上来区分，其它大部分系统以文件变更列表的方式存储信息。Git 更像是把数据看作是对小型文件系统的一组快照。 每次提交更新，或在 Git 中保存项目状态时，它主要对当时的全部文件制作一个快照并保存这个快照的索引。 2. 近乎所有操作都是本地执行 在 Git 中的绝大多数操作都只需要访问本地文件和资源，一般不需要来自网络上其它计算机的信息。比如要浏览项目的历史，Git 不需外连到服务器去获取历史，它只需直接从本地数据库中读取。 如果你想查看当前版本与一个月前的版本之间引入的修改，Git 会查找到一个月前的文件做一次本地的差异计算，而不是由远程服务器处理或从远程服务器拉回旧版本文件再来本地处理。 3. Git保证完整性 Git 中所有数据在存储前都计算校验和，然后以校验和来引用。 这意味着不可能在 Git 不知情时更改任何文件内容或目录内容。 这个功能建构在 Git 底层，是构成 Git 哲学不可或缺的部分。 若你在传送过程中丢失信息或损坏文件，Git 就能发现。Git 数据库中保存的信息都是以文件内容的哈希值来索引，而不是文件名。 4. Git一般只添加数据 你执行的 Git 操作，几乎只往 Git 数据库中增加数据。 很难让 Git 执行任何不可逆操作，或者让它以任何方式清除数据。 同别的 VCS 一样，未提交更新时有可能丢失或弄乱修改的内容；但是一旦你提交快照到 Git 中，就难以再丢失数据，特别是如果你定期的推送数据库到其它仓库的话。 5. 三种状态：已提交、已修改、已暂存据 已提交表示数据已经安全的保存在本地数据库中。 已修改表示修改了文件，但还没保存到数据库中。 已暂存表示对一个已修改文件的当前版本做了标记，使之包含在下次提交的快照中。 Git 仓库目录是 Git 用来保存项目的元数据和对象数据库的地方。 这是 Git 中最重要的部分，从其它计算机克隆仓库时，拷贝的就是这里的数据。 工作目录是对项目的某个版本独立提取出来的内容。 这些从 Git 仓库的压缩数据库中提取出来的文件，放在磁盘上供你使用或修改。 暂存区域是一个文件，保存了下次将提交的文件列表信息，一般在 Git 仓库目录中。 有时候也被称作“索引”，不过一般说法还是叫暂存区域。 基本的 Git 工作流程如下： 1.在工作目录中修改文件。2.暂存文件，将文件的快照放入暂存区域。3.提交更新，找到暂存区域的文件，将快照永久性存储到 Git 仓库目录。 如果 Git 目录中保存着的特定版本文件，就属于已提交状态。 如果作了修改并已放入暂存区域，就属于已暂存状态。 如果自上次取出后，作了修改但还没有放到暂存区域，就是已修改状态。 Git简单命令行学习以下是对git的简单操作介绍 用户信息配置 1.$ git config –global user.name “Your Name”2.$ git config –global user.email “Your Email” 检查配置信息 $ git config –l 初始化 $ git init 克隆 1.$ git clone url2.$ git clone url name #重命名成 name 设置标签 $ git tag 查看状态 $ git status$ git diff 提交 1.$ git add file.txt #将”当前修改”移动到暂存区(stage)2.$ git commit -m “Add file.txt” #将暂存区修改提交 回退 1.# 取消commit(比如需要重写commit信息) $ git reset –soft HEAD2.# 取消commit、add(重新提交代码和commit) $ git reset HEAD3.$ git reset –mixed HEAD4.# 取消commit、add、工作区修改(需要完全重置) $ git reset –hard HEAD 查看记录 1.$ git reflog2.$ git log 远程操作 $ git remote add origin url 查看分支 $ git branch 创建分支 $ git branch branchname 切换分支 $ git checkout branchname 创建并切换分支 $ git checkout -b branchname 合并分支 $ git merge branchname 删除分支 $ git branch -d branchname 参考与扩展阅读 GitPro2 git-简明指南 learnGitBranching 版权声明：本文为博主原创文章，转载请注明出处KidSea]]></content>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[华为轮值CEO胡厚崑：站在云端看世界]]></title>
    <url>%2F2016%2F09%2F15%2F%E5%8D%8E%E4%B8%BA%E8%BD%AE%E5%80%BCCEO%E8%83%A1%E5%8E%9A%E5%B4%91%EF%BC%9A%E7%AB%99%E5%9C%A8%E4%BA%91%E7%AB%AF%E7%9C%8B%E4%B8%96%E7%95%8C%2F</url>
    <content type="text"><![CDATA[前言 华为轮值CEO胡厚崑在2016华为全联接大会发表主题演讲 内容 ICT是智能社会的基石&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;智能社会正在到来。这是一次深刻的社会巨变，今天我们还无法全面认识它的深度和广度。但有一点确定的是，信息通信（ICT）技术，是智能社会背后最重要的基石。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;智能社会有三个特征，万物感知、万物互联、万物智能。由于有了先进的ICT技术，这三大特征才能实现。在智能社会，终端是万物感知的触角，网络连接万物，而云则是万物智能的源泉，与此对应的是全面协同的“端、管、云”架构。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;未来，所有人和物都能感知环境，成为智能世界的入口。电脑与人的距离越来越近，从大型机时代的几公里、PC机时代的几米，到智能手机时代的几厘米、再到可穿戴的几毫米。最后，可植入的智能芯片将使人机融为一体。5到10年内，将出现各式各样的多场景、自适应的智能终端，智能手机只是其中一种。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;未来，光缆和无线网络提供无处不在的超宽带、低时延的连接。在4G移动网络条件下，理论上可达到50毫秒的时延，这个速度对于网络运行VR、AR类应用还不够快，所以玩PokemonGO时，往往是看到了小精灵，就是抓不住！未来5G时代，理论上网络时延可以达到1毫秒，今天无法实现的很多应用，都有希望实现了。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;未来，分布全球而又相互连接的计算机，汇聚了人类社会海量信息，在云端生成了一个“数字大脑”。它实时进化，永不衰老。人和机器可以通过超宽带连接和智能终端调用它的智慧。自动驾驶、智慧医疗以及大部分人类脑力活动会在“数字大脑”协助下变得更高效。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;基于这些理解和假设，华为一直致力于打造智能社会的“端、管、云”技术架构，这也正是华为重点投入的战略方向。 云正在塑造一切，有变革才有重生&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;像人类历史上其他重大技术革命一样，云的影响远远超过技术本身，还影响了商业模式和人的思维模式，引发了一系列商业革命。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;过去十年，谷歌、亚马逊、滴滴、Airbnb等是“生于云的一代”，它们开创了敏捷创新、体验好、低成本的云的1.0时代，利用云技术、云架构实现了资源共享，利用移动互联网技术更好联接客户，即使在酒店、出租车等传统行业中，创造了颠覆性的商业模式。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;颠覆者的成功唤醒了各行各业。下一个十年，将是云的2.0时代，企业是云化的主角，各行各业将在云中成长，各种行业云也将兴起。我们预计，到2025年，所有企业企业都会用到云的技术、云的模式，85%以上企业应用会被部署到云上。企业都会结合核心业务，探索最适合的云化解决方案。 化云为雨，Think Big，Act Small &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;云重要，化云为雨更重要，要让云为业务创造价值。实现化云为雨，不仅要大胆构想（Think Big）, 更要小步快跑（Act Small）。 第一个体会是，重塑观念。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;企业应重新认识ICT的作用，把信息技术从辅助性技术上升为关键的生产技术，大胆利用信息技术驱动商业模式和运营模式创新，大胆利用新技术重新设计生产流程，而不是让技术适应流程。华为也在积极学习、思考，如何在云时代运用好云思维。 第二个体会是，重构人才。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;掌握以云为基础的信息技术应成为企业员工尤其是企业管理者的基本技能、素质。对于华为这样一个拥有17万员工的企业来说，如何升级员工知识结构，很具有挑战性，我们也一直在探索。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;纵观全球，云计算、大数据、人工智能方面的人才供不应求，顶尖人才更是稀缺资源，这种情况还会持续甚至加剧。企业应提前布局，大胆争夺人才；未雨绸缪，提前储备人才。在华为，我们也一直在积极部署人才战略，希望吸引更多顶尖人才。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;说到人才，必须谈谈CIO。云时代，CIO不仅是企业“技术掌门人”，应成为“战略制定者”，能够用信息技术驱动业务变革。 第三，小步快跑。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;制定云化战略，既要大胆构想，制定长期的、系统的战略，也要小步快跑，从小处入手，解决问题，创造价值，循序渐进地建立持久的信心。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;华为在全球有8万研发人员、16个研究中心、超过1500个实验室。过去，计算资源非常分散，难以共享，利用率低。从2013年开始，我们整合研发资源，实现代码和研发作业的上云部署，重构研发流程，效率大幅提升，其中，资源复用率提升2.5倍，各环节作业时间平均缩短50%，产品上市时间也大幅提前。 做智能社会发展推动者&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在云时代，有变化，才有希望；有行动，才有未来。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;华为希望，成为成为智能社会的使能者与推动者。具体到华为云战略，我们的定位是：以客户为中心；聚焦ICT基础设施，提供创新的云技术；成为客户优选的伙伴；积极参与云生态建设。 做创新的云技术提供者&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;技术是不断演进，客户需求也不断变化、升级。华为有信心，做好创新的云技术提供者，底气来自于哪里呢？ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;除了多年来积累的技术和创新能力，我们最大信心来自于华为以客户为中心的企业文化。28年来，这种价值观成为了华为的DNA和华为员工的最高行动指南。作为技术提供者，不能总想着用一把钥匙开不同的锁。所谓以客户为中心，就是接地气，愿意向客户学习，愿意真正沉下心去理解各行各业特点，把握业务特点带来的不同需求，并用创新的云技术和解决方案去匹配，做到“按需应变”。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;比如，大企业客户在云化时，特别关注自主可控不被厂家锁定以及内外部数据互联互通，华为就应用业界主流开源技术构建了开放云架构。又如，数据安全和隐私保护是客户在云化时的首要顾虑，华为就推出了基于统一架构的混合云解决方案，让客户同时享受私有云自主可控和公有云弹性敏捷。华为的云解决方案，特别强调了开放性、安全性、企业级的体验，以及一站式等特性，受到越来越多客户欢迎，这更坚定了我们云技术的研究中以客户为中心的信念。 我们是伙伴，而不仅仅是供应商&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;云时代，客户需要的不仅是供应商，而是深度合作的伙伴。华为愿意也有能力，成为这样的伙伴。今年，德国电信发布了开放电信云服务，为企业提供包括私有云、公有云以及软件解决方案在内的全套云服务。华为则被选为重要合作伙伴，提供硬件和软件解决方案。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;合作实现了优势互补，德国电信有强大数字基础设施，以及对企业需求的深入了解和长期服务经验，华为则有强大的、从硬件到软件的、端到端的持续技术创新能力。我们认为，合作最大亮点在于，开放电信云完全是客户需求驱动的产物。我们发现，客户关切聚焦在IT服务标准化和敏捷性、处理和实时分析大数据、应对严格的数据安全监管要求等。因此，我们的解决方案的特性，也相应地聚焦“安全、可靠、简单、开放”。这使得德国电信提供的公有云服务，比通用型的公有云服务更好地满足企业客户需求，也更受欢迎。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;各方评价，开放电信云是德国乃至欧洲企业数字化进程中重要的新业务，它有可能成为面向行业和大企业提供公有云服务的标杆。 做云生态的积极贡献者&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;云的发展，生态很重要。华为不会独自做几朵云，华为是帮助千万万万客户建好千万朵云，积极参与云生态的建设。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在行动上，华为会以开放、合作、共赢的心态，去参与构建产业联盟，做大产业的蛋糕；还会与SAP、埃森哲、微软、Intel等重要合作伙伴形成商业战略联盟，一起帮助客户成功；我们还会积极共建开发者平台和开源社区，引入更多玩家，繁荣产业链。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;行动的背后，我们有两点理念：云生态的构建一定要以客户为中心，为客户创造价值，既是建立生态的目的，也是生态健康持续发展的保证；每个参与生态建设的组织或企业，都应该有独特价值。华为就是发挥优势，做好产品，服务好客户。健康、可持续发展的云生态一定要有优秀的技术和产品来支撑，否则就是无源之水、难以长久。 宏大的云时代，才刚刚开始&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;云时代，意味着更好的联接，更多的分享，更多的自由。要实现这些理想，必须有云的高度、云的思维。我们要站在云端看世界。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;十几天前，我在天山深处的夏塔古道拍下了这张照片。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这条古道跨越南北疆，是古丝绸之路上最为险峻的一条路，又被称作“唐僧古道”，玄奘和尚当年就是由此去西天取经的。如今，它已成为新疆最热门的徒步探险线路之一。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;远处，是海拔6995米的天山汗腾格里峰和木扎尔特冰川。翻过雪山，尽头就是南疆蓝天白云下美丽的草原牧场。道路漫漫、艰险重重，古人如何能走得过去？我想，如果心中充满了美好憧憬，一切艰险都可以被克服。“夏塔”两个字，古语中也正是“天梯”的意思。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;借用一句流行语：哪里有什么洪荒之力，成功都是一步一步走出来的！企业数字化转型也是一段艰难之路，需要一步步走向前。这次大会，就是希望大家碰撞观点、交流思想，群策群力，共同探索如何塑造云时代，如何塑造整个世界。以上是我分享的内容。谢谢！ 版权声明：本文为博主转载文章，转载请注明出处华为]]></content>
      <tags>
        <tag>资讯</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[玻璃杯碎了之后]]></title>
    <url>%2F2016%2F09%2F11%2F%E7%8E%BB%E7%92%83%E6%9D%AF%E7%A2%8E%E4%BA%86%E4%B9%8B%E5%90%8E%2F</url>
    <content type="text"><![CDATA[前言 余秋雨在写《追询德国》的文章时，为了彻底了解德国，他一个人去德国体验生活。 内容 余秋雨在写《追询德国》的文章时，为了彻底了解德国，他一个人去德国体验生活。 他要租房子，房东是一位和蔼可亲的德国老人。房子在五楼，余秋雨看了看房子，感觉还不错，就想和老人签长期租房合同。 老人笑了笑说：“不，年轻人，你还没有住，不会知道好坏，所以应该先签试住合同，有了切身体验，再定下一步是否长住。” 余秋雨一听很有道理，就和老人签了5天合同。 第5天到了，余秋雨想和老人谈长租的时候，发生了一点意外，他不小心打碎了一个玻璃杯。他很紧张，感觉这个玻璃杯价值不菲，又怕因为这个玻璃杯，老人不租给他房子。可是当他打电话告诉老人的时候，老人说：“不要紧，你又不是故意的，这个玻璃杯很便宜。” 余秋雨把碎玻璃和其他垃圾扫入垃圾袋里，放在了外面。过了不久，老人来了，进屋之后，没等余秋雨说话，老人问：“那玻璃杯碎片呢？” 余秋雨赶紧说：“我打扫完放在门外了。”老人赶紧出去，打开垃圾袋看完之后，脸色阴沉地进屋，对余秋雨说：“明天你可以搬出去了，我不再租给你房子。” 余秋雨感觉不可思议，就问：“是不是因为我打碎您的玻璃杯，惹您不高兴了？” 老人摇了摇手说：“不是，是因为你心中没有别人。” 余秋雨一头雾水。这时，老人拿了一支笔和一个垃圾袋，同时带上笤帚和撮子，来到外面，把余秋雨装好的垃圾倒了出来，重新分类。老人挑得很仔细，把所有玻璃杯碎片装入一个垃圾袋里，在上面用笔写上：里面是玻璃杯碎片，危险。然后把其他垃圾装入另一垃圾袋里，写上：安全。 此后若干年，余秋雨提起这件往事，感叹连连。 版权声明：本文为博主转载文章，转载请注明出处点这]]></content>
      <tags>
        <tag>文章</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android笔记之JNI学习]]></title>
    <url>%2F2016%2F09%2F11%2FAndroid%E7%AC%94%E8%AE%B0%E4%B9%8BJNI%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[前言 Android笔记之JNI学习 内容 交叉编译 在一个平台上去编译另一个平台上可以执行的本地代码 cpu平台 arm x86 mips 操作系统平台 windows linux mac os 原理 模拟不同平台的特性去编译代码 jni开发工具 ndk native develop kit ndk目录 docs 帮助文档 platforms 好多平台版本文件夹 选择时选择项目支持的最小版本号对应的文件夹 每一个版本号的文件夹中放了 不同cpu架构的资源文件 include文件夹 jni开发中常用的 .h头文件 lib 文件夹 google打包好的 提供给开发者使用的 .so文件 samples google官方提供的样例工程 可以参考进行开发 android-ndk-r9d\build\tools linux系统下的批处理文件 在交叉编译时会自动调用 ndk-build 交叉编译的命令 cdt eclipse的插件 高亮C代码 C的代码提示 jnihelloworld jni开发的步骤 ①写java代码 声明本地方法 用到native关键字 本地方法不用去实现 ②项目根目录下创建jni文件夹 ③在jni文件夹下创建.c文件 本地函数命名规则: Java包名类名_本地方法名 JNIENV* env JNIEnv 是JniNativeInterface这个结构体的一级指针 JniNativeInterface这个结构体定义了大量的函数指针 env 就是结构体JniNativeInterface这个结构体的二级指针 (*env)-&gt;调用结构体中的函数指针 第二个参数jobject 调用本地函数的java对象就是这个jobject ④ 导入 ⑤ 创建Android.mk makefile 告诉编译器.c的源文件在什么地方,要生成的编译对象的名字是什么 LOCAL_PATH := $(call my-dir) include $(CLEAR_VARS) LOCAL_MODULE := hello #指定了生成的动态链接库的名字LOCAL_SRC_FILES := hello.c #指定了C的源文件叫什么名字 include $(BUILD_SHARED_LIBRARY) ⑥ 调用ndk-build编译c代码生成动态链接库.so文件 文件的位置 lib-&gt;armeabi-&gt;.so ⑦ 在java代码中加载动态链接库 System.loadlibrary(“动态链接库的名字”); Android.mkLOCAL_MODULE所指定的名字 jni开发中的常见错误 java.lang.UnsatisfiedLinkError: Native method not found: 本地方法没有找到 本地函数名写错 忘记加载.so文件 没有调用System.loadlibrary findLibrary returned null System.loadLibrary(“libhello”); 加载动态链接库时 动态链接库名字写错 平台类型错误 把只支持arm平台的.so文件部署到了 x86cpu的设备上 在jni目录下创建 Application.mk 在里面指定 APP_ABI := armeabiAPP_PLATFORM := android-14 javah jdk 1.7 项目 src目录下运行javah jdk 1.6 项目 bin目录下 classes文件夹 javah native方法声明的java类的全类名 jni简便开发流程 ① 写java代码 native 声明本地方法 ② 添加本地支持 右键单击项目-&gt;andorid tools-&gt;add native surport 如果发现 finish不能点击需要给工作空间配置ndk目录的位置 window-&gt;preferences-&gt;左侧选择android-&gt;ndk 把ndk解压的目录指定进来 ③ 如果写的是.c的文件 先修改一下生成的.cpp文件的扩展名 不要忘了 相应修改Android.mk文件中LOCAL_SRC_FILES的值 ④ javah生成头文件 在生成的头文件中拷贝c的函数名到.c的文件 ⑤ 解决CDT插件报错的问题 右键单击项目选择 properties 选测 c/c++ general-&gt;paths and symbols-&gt;include选项卡下-&gt;点击add..-&gt;file system 选择ndk目录下 platforms文件夹 对应平台下(项目支持的最小版本)usr 目录下 arch-arm -&gt; include 确定后 会解决代码提示和报错的问题 ⑥编写C函数 如果需要单独编译一下c代码就在c/c++视图中找到小锤子 如果想直接运行到模拟器上 就不用锤子了 ⑦ java代码中不要忘了 system.loadlibrary(); C代码中向logcat输出内容Android.mk文件增加以下内容 LOCAL_LDLIBS += -llog C代码中增加以下内容 #include &lt;android/log.h&gt; #define LOG_TAG &quot;System.out&quot; #define LOGD(...) __android_log_print(ANDROID_LOG_DEBUG, LOG_TAG, __VA_ARGS__) #define LOGI(...) __android_log_print(ANDROID_LOG_INFO, LOG_TAG, __VA_ARGS__) define C的宏定义 起别名 #define LOG_TAG “System.out” 给”System.out”起别名LOG_TAG #define LOGI(…) android_log_print(ANDROID_LOG_INFO, LOG_TAG, VA_ARGS__) 给 __android_log_print函数起别名 写死了前两个参数 第一个参数 优先级 第二个参数TAG VA_ARGS 可变参数的固定写法 LOGI(…)在调用的时候 用法跟printf()一样 C代码回调java方法 ① 找到字节码对象 //jclass (FindClass)(JNIEnv, const char*); //第二个参数 要回调的java方法所在的类的路径 “com/itheima/callbackjava/JNI” ② 通过字节码对象找到方法对象 //jmethodID (GetMethodID)(JNIEnv, jclass, const char, const char); 第二个参数 字节码对象 第三个参数 要反射调用的java方法名 第四个参数 要反射调用的java方法签名 javap -s 要获取方法签名的类的全类名 项目/bin/classes 运行javap ③ 通过字节码创建 java对象(可选) 如果本地方法和要回调的java方法在同一个类里可以直接用 jni传过来的java对象 调用创建的Method jobject obj =(*env)-&gt;AllocObject(env,claz); 当回调的方法跟本地方法不在一个类里 需要通过刚创建的字节码对象手动创建一个java对象 再通过这个对象来回调java的方法 需要注意的是 如果创建的是一个activity对象 回调的方法还包含上下文 这个方法行不通!!!回报空指针异常 ④ 反射调用java方法 //void (CallVoidMethod)(JNIEnv, jobject, jmethodID, …); 第二个参数 调用java方法的对象 第三个参数 要调用的jmethodID对象 可选的参数 调用方法时接收的参数 版权声明：本文为博主原创文章，转载请注明出处KidSea]]></content>
      <tags>
        <tag>安卓</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android下的Linux指令集]]></title>
    <url>%2F2016%2F09%2F09%2FAndroid%E4%B8%8B%E7%9A%84Linux%E6%8C%87%E4%BB%A4%E9%9B%86%2F</url>
    <content type="text"><![CDATA[前言 Android下的Linux指令集 内容 Android目录结构 data app：用户安装的应用 data：应用的专属文件夹 system：系统的配置信息，注册表文件 anr：anr异常的记录信息 dev：devices的缩写 存放设备所对应的文件 mnt：mount的缩写 挂载在系统上的设备：sdcard，u盘 proc：硬件配置，状态信息 cpuinfo、meminfo sbin：system bin 系统重要的二进制执行文件 adbd：服务器的adb进程 system： app：存放系统应用，默认不能删除 bin：Android中可执行的linux指令文件 etc：host：主机名和ip地址的映射 fonts：Android中自带的字体 framework：存放谷歌提供的java api lib：核心功能的类库，C/C++文件 media/audio：存放Android的音效文件 tts：语音发声引擎，默认不支持中文 usr：用户设备的配置信息，键盘编码和按键编码的映射 xbin：是专为开发人员准备的二进制指令 Android下的Linux指令 su：superuser 切换到超级用户 rm：remove，删除文件 rm 文件名 ls：列出目录下的所有文件和文件夹 ls -l：查看文件的详细信息 ls -a：查看隐藏文件 cd：切换到某个目录 cat：查看文件内容 cat 文件名 不要cat二进制可执行文件 mv：move 修改文件名 mv 原文件名 新文件名 mkdir：创建文件夹 mkdir 文件夹名字 rmdir：删除文件夹 rmdir 文件夹名字 touch：创建新文件 touch 文件名 chmod：change mode，切换文件访问权限 chmod 777 文件名 echo：回显数据；重定向数据 echo 数据 &gt; 文件名 sleep：睡眠几秒 df：显示指定目录的容量 id：打印当前用户的id uid=0：root uid=1000：system uid=2000：shell uid=10000+：一般应用程序的id ps：列出系统中运行的所有进程 kill：杀死指定pid的进程 kill pid chown：change owner，修改拥有者 chown 0.0 文件名 mount：挂载文件系统 mount -o remount rw /：挂载当前目录为可读可写权限 mount -o remount rw /system：重新挂载指定目录 Android中特有的指令 am：ActivityManager，可以进行跟activity相关的操作 am start -n com.itheima.createfile/com.itheima.createfile.MainActivity：开启指定Activity am kill com.itheima.createfile：结束非前台进程 am force-stop com.itheima.createfile：结束进程 pm：PackageManager pm disable 包名：冻结指定应用 pm enable 包名：解冻指定应用 monkey -p com.itheima.createfile 1000：自动点击指定应用1000次 刷模拟器，rom写文件（su） 如果想让真实手机运行这些指令，手机必须要有root权限 刷root原理：把su二进制文件拷贝到/system/bin或者/system/xbin Android刷root软件，工作的原理全部都是利用系统的漏洞实现 rom：可以理解为android系统的安装文件 把su文件和superuser.apk写入img文件 执行su指令 Runtime.getRuntime().exec(&quot;su&quot;); 小案例：冻结解冻应用 冻结和解冻指定的应用 RootTools.sendShell(“pm disable “ + package, 300000); RootTools.sendShell(“pm enable “ + package, 300000); 小案例：零权限读取用户隐私数据 直接修改短信数据库访问权限 RootTools.sendShell(&quot;chmod 777 data/data/com.android.providers.telephony/databases/mmssms.db&quot;, 300000); SQLiteDatabase db = SQLiteDatabase.openDatabase(&quot;data/data/com.android.providers.telephony/databases/mmssms.db&quot;, null, SQLiteDatabase.OPEN_READONLY); Cursor cursor = db.query(&quot;sms&quot;, new String[]{&quot;body&quot;, &quot;address&quot;}, null, null, null, null, null); while(cursor.moveToNext()){ String body = cursor.getString(0); String address = cursor.getString(1); System.out.println(body + &quot;;&quot; + address); } RootTools.sendShell(&quot;chmod 660 data/data/com.android.providers.telephony/databases/mmssms.db&quot;, 300000); 静默安装 为什么有静默安装的需求 正规应用。电子市场，方便用户静默安装 流氓软件。后台偷偷下载安装。 自动下载应用，然后静默安装 //静默安装 RootTools.sendShell(&quot;pm install sdcard/flowstat.apk&quot;, 30000); //打开 RootTools.sendShell(&quot;am start -n com.jijian.flowstat/com.jijian.flowstat.TrafficWidgetSetting&quot;, 30000); //卸载应用 RootTools.sendShell(&quot;pm uninstall com.jijian.flowstat&quot;, 30000); //删除下载的apk包 RootTools.sendShell(&quot;rm sdcard/flowstat.apk&quot;, 30000); 修改字体 把ttf文件刷进img中 Android系统默认的中文字体为DroidSansFallBack.ttf 用你想使用的字体ttf文件替换掉这个文件即可 修改开机动画 从真机中得到bootanimation.zip 把bootanimation.zip放入system/media目录下 删除锁屏密码 删除data/system下的key文件 文本密码为password.key 手势密码为gesture.key 版权声明：本文为博主原创文章，转载请注明出处KidSea]]></content>
      <tags>
        <tag>安卓</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[知识，比什么都重要]]></title>
    <url>%2F2016%2F09%2F08%2F%E7%9F%A5%E8%AF%86%EF%BC%8C%E6%AF%94%E4%BB%80%E4%B9%88%E9%83%BD%E9%87%8D%E8%A6%81%2F</url>
    <content type="text"><![CDATA[前言 每个犹太人在小的时候，他们的母亲都会给他们讲这样一个故事： 内容 每个犹太人在小的时候，他们的母亲都会给他们讲这样一个故事： 有一艘大船出海远行，船上的乘客中除了一位拉比外，全是大亨。 大亨们闲来无聊，就开始相互炫耀起自己的财富来。正在他们争得面红耳赤时，拉比插话了：“我是你们这群人中最富有的，不信你们走着瞧。” 船行途中遇到了大风，只好靠岸，一靠岸便遇到了海盗，大亨们的财产被抢劫一空；而拉比的智慧和学识很快就受到岸边居民的赏识，他陆续在当地开班授课。于是，那些处境落魄的大亨们纷纷前来寻求拉比的帮助。他们见到拉比的第一句话就是：“还是您说得对，您确实是最富有的人。” 因此，在犹太人的心目中，赚了钱并不等于成功，真正的成功是获取知识和智慧，知识和智慧是任何人都抢不走的财富。正如《塔木德》所言：任何有知识的人都不会贫穷。 在犹太人的心目中，学者的地位不仅高于商人，而且高于国王。有话为证：“一个学者死了，没有人能代替他，而一个国王死了，所有人都能胜任。” 犹太商人说：“财富是靠脑袋的，而不是靠手，钞票有的是，遗憾的是你的口袋太小了。如果你的思维足够开阔，那你的钱包就会随之增大。” 正如犹太作家茨威格在其回忆录中所言：“发财致富对犹太人来说只是一个过渡阶段，而根本不是他的内在目标。一个犹太人的真正愿望，是提高自己的精神文明，使自己进入到更高的文化层次……倘若在自己的家庭成员中有一个人明显地成了称得上有知识的人，如当了教授、学者、音乐家，那么就会把这种荣誉头衔看做是属于全家的，仿佛他通过自己的成就会使全家人都变得高贵似的。” 版权声明：本文为博主转载文章，转载请注明出处点这]]></content>
      <tags>
        <tag>文章</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java学习之路-10]]></title>
    <url>%2F2016%2F09%2F06%2Fjava%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-10%2F</url>
    <content type="text"><![CDATA[前言 java学习之路—–&gt;Jsp学习-2 内容 Jsp中的四个域对象四个域对象： pageContext page域 request request域 session session域 application context域 1）域对象作用： 保存数据 和 获取数据 ，用于数据共享。 2）域对象方法： setAttribute(&quot;name&quot;,Object) 保存数据 getAttribute(&quot;name&quot;) 获取数据 removeAttribute(&quot;name&quot;) 清除数据 3）域对象作用范围： page域： 只能在当前jsp页面中使用（当前页面） request域： 只能在同一个请求中使用（转发） session域： 只能在同一个会话（session对象）中使用（私有的） context域： 只能在同一个web应用中使用。（全局的） Jsp的最佳实践Servlet技术： 开发动态资源。是一个java类，最擅长写java代码 jsp技术： 开发动态资源。通过java代码最擅长输出html代码。 各取所长： 在web项目中涉及到逻辑： 1）接收参数 servlet做 2）处理业务逻辑，返回结果 servlet做 3）显示数据到浏览器 jsp做 4）跳转到其他页面 servlet做 servlet+jsp模式 servlet: 1）接收参数 2）处理业务逻辑 3）把结果保存到域对象中 4）跳转到jsp页面 Jsp: 1）从域对象取出数据 2）把数据显示到浏览器 servlet的数据 -&gt; jsp页面 List&lt;Contact&gt; 使用域对象 共享数据 EL表达式EL作用 替换jsp表达式 EL表达式作用 向浏览器输出域对象中的变量值或者是表达式计算的结果 语法： $(变量或表达式) 1）输出基本数据类型变量 1.1 从四个域获取 ${name} 1.2 指定域获取 ${pageScope.name} 域范围： pageScoep / requestScope / sessionScope / applicationScope 2）输出对象的属性值 Student 3）输出集合对象 List 和 Map 4）EL表达式计算 Jsp标签jsp标签的作用替换jsp脚本 1）流程判断（if for循环） 2）跳转页面（转发，重定向） 3）。。。。。 jsp标签分类1）内置标签（动作标签）： 不需要在jsp页面导入标签 2）jstl标签： 需要在jsp页面中导入标签 3）自定义标签 ： 开发者自行定义，需要在jsp页面导入标签 动作标签转发标签 &lt;jsp:forward/&gt; 参数标签 &lt;jsp:pararm/&gt; 包含标签 &lt;jsp:include/&gt; 原理： 包含与被包含的页面先各自翻译成java源文件，然后再运行时合并在一起。 （先翻译再合并），动态包含 静态包含 vs 动态包含的区别？ 1） 语法不同 静态包含语法： &lt;%@inclue file=&quot;被包含的页面&quot;%&gt; 动态包含语法： &lt;jsp:include page=&quot;被包含的页面&quot;&gt; 2）参数传递不同 静态包含不能向被包含页面传递参数 动态包含可以向被包含页面传递参数 3）原理不同 静态包含： 先合并再翻译 动态包含： 先翻译再合并 JSTL标签JSTL (全名：java standard tag libarary - java标准标签库 ) 核心标签库 （c标签库） 天天用 国际化标签（fmt标签库） EL函数库（fn函数库） xml标签库（x标签库） sql标签库（sql标签库） 使用JSTL标签步骤1）导入jstl支持的jar包（标签背后隐藏的java代码） 注意：使用javaee5.0的项目自动导入jstl支持jar包 2）使用taglib指令导入标签库 &lt;%@taglib uri=&quot;tld文件的uri名称&quot; prefix=&quot;简写&quot; %&gt; 3）在jsp中使用标签 核心标签库的重点标签：保存数据： &lt;c:set&gt;&lt;/c:set&gt; 获取数据： &lt;c:out value=&quot;&quot;&gt;&lt;/c:out&gt; 单条件判断 &lt;c:if test=&quot;&quot;&gt;&lt;/c:if&gt; 多条件判断 &lt;c:choose&gt;&lt;/c:choose&gt; &lt;c:when test=&quot;&quot;&gt;&lt;/c:when&gt; &lt;c:otherwise&gt;&lt;/c:otherwise&gt; 循环数据 &lt;c:forEach&gt;&lt;/c:forEach&gt; &lt;c:forTokens items=&quot;&quot; delims=&quot;&quot;&gt;&lt;/c:forTokens&gt; 重定向 &lt;c:redirect&gt;&lt;/c:redirect&gt; 自定义标签引入需求： 向浏览器输出当前客户的IP地址 （只能使用jsp标签） 第一个自定义标签开发步骤 编写一个普通的java类，继承SimpleTagSupport类，叫标签处理器类 在web项目的WEB-INF目录下建立itcast.tld文件，这个tld叫标签库的声明文件。（参考核心标签库的tld文件） 在jsp页面的头部导入自定义标签库 &lt;%@taglib uri=”http://gz.itcast.cn“ prefix=”itcast”%&gt; 在jsp中使用自定义标签 自定义标签的执行过程问题： http://localhost:8080/day14/01.hellotag.jsp 如何访问到自定义标签？ 前提： tomcat服务器启动时，加载到每个web应用， 加载每个web应用的WEB-INF目录下的所有文件！！！例如。web.xml, tld文件！！！ 1）访问01.hellotag.jsp资源 2）tomcat服务器把jsp文件翻译成java源文件-&gt;编译class -&gt;构造类对象-&gt;调用_jspService（）方法 3）检查jsp文件的taglib指令，是否存在一个名为 http://gz.itcast.cn的tld文件。如果没有，则报错 4）上一步已经读到itcast.tld文件 5）读到&lt;itcast:showIp&gt;到itcast.tld文件中查询是否存在&lt;name&gt;为showIp的 &lt;tag&gt;标签 6）找到对应的&lt;tag&gt;标签，则读到&lt;tag-class&gt;内容 7）得到 gz.itcast.a_tag.ShowIpTag 构造ShowIpTag对象，然后调用ShowIpTag里面的方法 自定义标签的作用 1）控制标签体内容是否输出2）控制标签余下内容是否输出3）控制重复输出标签体内容4）改变标签体内容5）带属性的标签 输出标签体内容格式JSP： 在传统标签中使用的。可以写和执行jsp的java代码。scriptless: 标签体不可以写jsp的java代码empty: 必须是空标签。tagdependent : 标签体内容可以写jsp的java代码，但不会执行。 版权声明：本文为博主原创文章，转载请注明出处KidSea]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[人生最好的心态是平静]]></title>
    <url>%2F2016%2F09%2F05%2F%E4%BA%BA%E7%94%9F%E6%9C%80%E5%A5%BD%E7%9A%84%E5%BF%83%E6%80%81%E6%98%AF%E5%B9%B3%E9%9D%99%2F</url>
    <content type="text"><![CDATA[前言 经典哲理语句分享给大家 内容 在我们的人生道路上，我们会遇到很多选择，如何选择也是非常重要的，不管前方的路有多苦，只要方向正确，朝着目标而努力奋斗，不要急着去说别无选择，下个路口就会遇见希望。 世界再大，大不过一颗心，如果你无法忘掉昨天，就不会有一个更好的明天世界再大，大不过一颗心;走得再远，远不过一场梦。;前路曲折其实是好事，因为我们能够看到更多的风景。人的一生，总是失意的时候多，得意的时候少，无论失意还是得意，都要淡定。感恩生活，你会发现生活中总有一些很随意的、很质朴无华的人或事，会为咸咸淡淡的人生抹上一层玫瑰般的亮色，而也正是这些零零碎碎的偶然美丽，给了你一个活得更美好的理由。 脚踏实地走好每一天，每一个现在，都是我们以后的记忆。以平常之心，接受已发生的事。以宽阔之心，包容对不起你的人。不要爱上一个漂亮的人，而要爱上一个使你的生活变漂亮的人。远处的是风景，近处的才是人生。走过的生活并不完美，太完美的也就不是生活了!如果生下来只是为了活下去，那倒不如为了生活而生活，所以对待生活的态度很重要!一个人有个好的心态，才能享受人生。人生途中，有些是无法逃避的，比如命运;有些是无法更改的，比如情缘。 那么，我们要如何面对生命呢?我们毋需等到生活完美无瑕，也毋需等到一切都平稳，想做什么，现在就可以开始做起。别哭穷，因为没人会给你钱。别喊累，因为没人会帮你做。别认输，因为没人希望你赢。别靠人，因为只有自己最可靠。别哭泣，因为大家等着看笑话。别乞求，因为有些人恨不得你当乞丐。别落魄，因为一堆人等着落井下石。别回首，因为事情多不堪回首。别离愁，因为只会才下眉头却上心头。别低头，因为地上没有黄金只有石头。别强求，因为强扭的瓜不甜。生活应该是愉快的，人生在世，不能没有欲望，生活总是一直变动，环境总是不可预知，现实生活中，各种突发状况总是层出不穷。 世上有许多的不幸，都是在急于向别人证明自己的过程中发生。“证明自己”本身并没有错，错的是很多人不过是在挣扎着“证明自己给别人看”。生命是自己的，不必用别人的标准来框定自己的人生。如果想讨好所有人，满足所有人的标准，最终只会迷失自己。试图让所有人都喜欢你，是徒劳无功的，也是对自己的不负责任。不要迷失在别人的评价里，用心倾听自己内心的声音，做自己就好。有人不在意你，你却在珍惜;有人在伤你，你却在原谅。情可以无价，但不能廉价;可以放宽底线，但不允许践踏底线。为爱可放弃所有，唯独不能放弃自尊。真心对你的人，会把你牵挂在心，绝不会因忙碌而去忽略;真正在乎你的情，会把你捧在手心，绝不会忽冷忽热让你去猜测感觉。 如果你要做一件事，请不要炫耀，也不要宣扬，不要以自己的标准来要求别人，也不要戴着有色眼镜看人。因为每个人都有自己的喜好和个性以及价值。你看不惯的事情，并不一定就是不好。幸福的理解有千万种，每人的诠释也不同，人生最大的幸福就是可以做自己。相信自己，跟随自己的心灵和直觉，不盲从信条，不盲目攀比，你就是最幸福的。金无赤足，人无完人，因为不完美，我们才最真实。只管安安静静的去做。因为那是你自己的事，别人不知道你的情况，也不可能帮你实现梦想。千万不要因为虚荣心而炫耀。也不要因为别人的一句评价而放弃自己的梦想。其实最好的状态，是坚持自己的梦想，听听前辈的建议，少错几步。值不值，时间是最好的证明。 该说时说是一种水平，该哑时哑是一种聪明。该干时干是一种能力，该退时退是一种修炼。该显时显是一种睿智，该藏时藏是一种城府。该吼时吼是一种威仪，该滑时滑是一种谋略。屈伸有度是一种成熟，吃睡平和是一种性情。俗话说：“害人之心不可有，防人之心不可无。”这说明了一个简单的道理：做人，要有一点心计。“心计”不是诡计、世故，而是做人的一种智慧和谋略。有了它，你就能左右逢源、游刃有余，永远立于不败之地。从未真正长大，人生，与其不断追求而无法满足，不如先沉淀自己，看清内心深处真正的需求。只要愿意打开封闭的心，去体会、去拥抱眼前的幸福，就会比别人活得更富足，更开心。 这世界上所有令人厌恶的伤害，所有烦人的工作，你怎么能放在心上呢?你静静待着，保持内心平静就好，根本没有必要去证明什么。人生给予了我们每一个人很多的礼物，只是有的人忘了拆开它，有的人丢弃一旁，有的人甚至没找着，那些礼物叫经验。人生，需要有一些时刻，慢下来，静下来，听一听花开的声音，看一看叶子舒卷的曼妙。不要以为你放不下的人同样会放不下你，鱼没有水会死，水没有鱼却会更清澈。该来的都会来，该走的全会走，别抗拒，别挽留。用最真实的自己，才能遇见最应该的那个人。一个人真正的强大，并非看他能做什么，而是看他能承担什么。 当有一天静静内省，感受着自己当下的幸福和快乐。才发现，对物质的欲望是永无止尽的。如果贪着太多，容易不择手段，误入歧途，所以要学会适可而止。一个人，一条路，人在途中，心随景动，从起点，到尽头，也许快乐，或有时孤独，如果心在远方，只需勇敢前行，梦想自会引路，有多远，走多远，把足迹连成生命线。旅行最大的好处，不是能见到多少人，见过多美的风景，而是走着走着，在一个际遇下，突然重新认识了自己。 人的一生，既不是想象中的那么好，也不是想象中的那么坏。每个人的背后都会有心酸，都会有无法言说的艰难。每个人都会有自己的泪要擦，都会有自己的路要走。只要记得，冷了给自己加件外衣;饿了给自己买个面包，痛了给自己一份坚强;失败了给自己一个目标，跌倒了在伤痛中爬起，给自己一个宽容的微笑继续往前走，做最真实的自己。别离，不记得容颜，忘记了彼此，而我们就像羁旅异乡一样。没有目的地，游离在这条路上，孤单或偶有人陪伴，可别忘了，路人，仅仅只能陪伴你一程，而不是全部，人生的路，要靠自己走，哪就坚强的迈步，勇敢的走完。]]></content>
      <tags>
        <tag>文章</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java学习之路-9]]></title>
    <url>%2F2016%2F09%2F04%2Fjava%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-9%2F</url>
    <content type="text"><![CDATA[前言 java学习之路—–&gt;Jsp学习-1 内容 JSP基础引入Servlet的作用：用java语言开发动态资源的技术 Jsp作用：用java(+html语言)开发动态资源的技术 Jsp就是Servlet但作用不同 Jsp的特点1) Jsp的运行也要交给tomcat服务器 work目录 存放jsp运行时的临时文件 2) Jsp页面既可以写html代码，也可以写java代码 (html不能写java代码，但是jsp可以写) Jsp页面作用需求：显示当前的时间到浏览器上面 可以把jsp文件当做html页面在服务器上访问 Jsp执行过程问题： 访问http://localhost:8080/day12/01.hello.jsp 如何显示效果？ 1）访问到01.hello.jsp页面，tomcat扫描到jsp文件，在%tomcat%/work把 jsp文件翻译成java源文件 (01.hello.jsp -&gt; _01_hello_jsp.java) （翻译） 2）tomcat服务器把java源文件编译成class字节码文件 （编译） （_01_hello_jsp.java -&gt; _01_hello_jsp.class） 3）tomcat服务器构造_01_hello_jsp类对象 4）tomcat服务器调用_01_hello_jsp类里面方法，返回内容显示到浏览器。 第一次访问jsp： 走（1）（2）（3）（4） 第n次访问jsp： 走（4） jsp文件修改了或jsp的临时文件被删除了，要重新走翻译（1）和编译（2）的过程 Jsp疑问问题：为什么Jsp就是Servlet？ jsp翻译的java文件： public final class _01_hello_jsp extends org.apache.jasper.runtime.HttpJspBase implements org.apache.jasper.runtime.JspSourceDependent HttpJspBase类： public abstract class org.apache.jasper.runtime.HttpJspBase extends javax.servlet.http.HttpServlet implements javax.servlet.jsp.HttpJspPage 结论： Jsp就是一个servlet程序！！！ servlet的技术可以用在jsp程序中 jsp的技术并不是全部适用于servlet程序！ Servlet的生命周期： 1）构造方法（第1次访问） 2）init方法（第1次访问） 3）service方法 4）destroy方法 Jsp的生命周期 1）翻译： jsp-&gt;java文件 2）编译： java文件-&gt;class文件（servlet程序） 3）构造方法（第1次访问） 4）init方法（第1次访问）：_jspInit() 5）service方法：_jspService() 6）destroy方法：_jspDestroy() Jsp语法Jsp模板jsp页面中的html代码就是jsp模板 Jsp表达式语法：&lt;%=变量或表达式%&gt; 作用： 向浏览器输出变量的值或表达式计算的结果 注意： 1）表达式的原理就是翻译成out.print(“变量” );通过该方法向浏览器写出内容 2）表达式后面不需要带分号结束。 Jsp脚本语法：&lt;%java代码 %&gt; 作用： 执行java代码 注意： 1）原理把脚本中java代码原封不动拷贝到_jspService方法中执行。 Jsp声明语法：&lt;%! 变量或方法 %&gt; 作用： 声明jsp的变量或方法 注意: 1）变量翻译成成员变量，方法翻译成成员方法。 Jsp注释语法： &lt;%!-- jsp注释 --%&gt; 注意; 1)html的注释会被翻译和执行。而jsp的注释不能被翻译和执行。 Jsp的三大指令include指令作用：用于包含其他页面 语法： &lt;%@include file=&quot;common/header.jsp&quot;%&gt; 注意： 1）原理是把被包含的页面（header.jsp）的内容翻译到包含页面 (index.jsp)中,合并成翻译成一个java源文件，再编译运行！！， 这种包含叫静态包含（源码包含） 2）如果使用静态包含，被包含页面中不需要出现全局的html标签了！！！ （如html、head、body） page指令作用： 告诉tomcat服务器如何翻译jsp文件 &lt;%@ page language=&quot;java&quot; --告诉服务器使用什么动态语言来翻译jsp文件 import=&quot;java.util.*&quot; --告诉服务器java文件使用什么包 导入包，多个包之间用逗号分割 pageEncoding=&quot;utf-8&quot; --告诉服务器使用什么编码翻译jsp文件 （成java文件） contentType=&quot;text/html; charset=utf-8&quot; 服务器发送浏览器的数据类型和内容编码 注意：在开发工具中，以后只需要设置pageEncoding即可解决中文乱码问题 errorPage=&quot;error.jsp&quot; isErrorPage=&quot;false&quot; buffer=&quot;8kb&quot; session=&quot;true&quot; isELIgnored=&quot;false&quot; %&gt; 异常错误相关的 errorPage 指定当前jsp页面的错误处理页面。 isErorrPage 指定当前页面为错误处理页面。flase，则表示不是， 不能使用exception内置对象，只有true才可以 配置全局错误处理 &lt;!-- 全局错误处理页面配置 --&gt; &lt;error-page&gt; &lt;error-code&gt;500&lt;/error-code&gt; &lt;location&gt;/common/500.jsp&lt;/location&gt; &lt;/error-page&gt; &lt;error-page&gt; &lt;error-code&gt;404&lt;/error-code&gt; &lt;location&gt;/common/404.html&lt;/location&gt; &lt;/error-page&gt; session: 是否开启session功能。false，不能用session内置对象； true，可以使用session内置对象。 buffer: jsp页面的缓存区大小。 isELIgnore： 是否忽略EL表达式。 taglib指令Jsp的内置对象(重点)什么是内置对象？在jsp开发中，会频繁使用到一些对象 例如HttpSession,ServletContext,ServletContext,HttpServletRequet。 如果我们每次要使用这些对象都去创建这些对象就显示非常麻烦。 所以Sun公司设计Jsp时，在jsp页面加载完毕之后就会自动帮开发者创建好这些对象， 而开发者只需要直接使用这些对象调用方法即可！ 这些创建好的对象就叫内置对象！！！！ 举例： servlet: HttpSession session = request.getSession(true); （需要开发者做） jsp: tomcat服务器： HttpSession session = request.getSession(true); (不需要开发者做) 开发者做的： session.getId(); 9大内置对象内置对象名 类型 request HttpServletRequest response HttpServletResponse config ServletConfig application ServletContext session HttpSession exception Throwable page Object(this) out JspWriter pageContext PageContext Out 对象out对象类型：jspWriter类，相当于带缓冲的PrintWriter\ PrintWriter: writer(内容): 直接向浏览器写出内容 JspWriter: writer(内容)：向jsp缓存输出内容 当满足以下条件之一，缓冲区内容写出： 1）缓冲区满了 2）刷新缓存区 3）关闭缓存区 4）执行完毕jsp页面 pageContext对象pageContext对象的类型是PageContext，叫jsp的上下文对象 可以获取其他八个内置对象 public class 01_hello_jsp { public void _jspService(request,response){ 创建内置对象 HttpSession session =....; ServletConfig config = ....; 把8个经常使用的内置对象封装到PageContext对象中 PageContext pageContext = 封装； 调用method1方法 method1(pageContext); } public void method1(PageContext pageContext){ 希望使用内置对象 从PageContext对象中获取其他8个内置对象 JspWriter out =pageContext.getOut(); HttpServletRequest rquest = pageContext.getRequest(); ........ } } 使用场景： 在自定义标签的时候，PageContext对象频繁使用到！！！ 本身就是一个域对象ServletContext context域 HttpServletRequet request域 HttpSession session域 --Servlet学习的 PageContext page域 --jsp学习的 作用： 保存数据和获取数据，用于共享数据 #保存数据 1）默认情况下，保存到page域 pageContext.setAttribute(&quot;name&quot;); 2）可以向四个域对象保存数据 pageContext.setAttribute(&quot;name&quot;,域范围常量) #获取数据 1）默认情况下，从page域获取 pageContext.getAttribute(&quot;name&quot;) 2）可以从四个域中获取数据 pageContext.getAttribute(&quot;name&quot;,域范围常量) 域范围常量: PageContext.PAGE_SCOPE PageContext.REQUEST_SCOPE PageContext..SESSION_SCOPE PageContext.APPLICATION_SCOPE 3）自动在四个域中搜索数据 pageContext.findAttribute(&quot;name&quot;); 顺序： page域 -&gt; request域 -&gt; session域- &gt; context域（application域） 版权声明：本文为博主原创文章，转载请注明出处KidSea]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java学习之路-8]]></title>
    <url>%2F2016%2F09%2F03%2Fjava%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-8%2F</url>
    <content type="text"><![CDATA[前言 java学习之路—–&gt;会话管理 内容 会话管理生活中的会话我： 小张，你会跳小苹果码？ 小张： 会，怎么了？ 我： 公司年会上要表演节目，你教教我把 小张：没问题，一顿饭而已。 我： OK。 。。。。。。。。 在这次生活中的会话中产生通话记录（会话数据） 软件中的会话一次会话： 打开浏览器 -&gt; 访问一些服务器内容 -&gt; 关闭浏览器 登录场景：打开浏览器 -&gt; 浏览到登陆页面 -&gt; 输入用户名和密码 -&gt; 访问到用户主页(显示用户 名) 修改密码（输入原密码） 修改收货地址 ....... 问题：在此处登录会话过程中产生的数据（用户会话数据）如何保存下来呢？ 购物场景：打开浏览器 -&gt; 浏览商品列表 -&gt; 加入购物车(把商品信息保存下来) -&gt; 关闭 浏览器 打开浏览器-&gt; 直接进入购物车 -&gt; 查看到上次加入购物车的商品 -&gt; 下订单 -&gt; 支付 问题： 在购物会话过程中，如何保存商品信息？？ 会话管理： 管理浏览器客户端 和 服务器端之间会话过程中产生的会话数据。 域对象： 实现资源之间的数据共享。 request域对象 context域对象 登录场景：小张： 输入“张三” （保存数据： context.setAttribute(&quot;name&quot;,&quot;张三&quot;)） -&gt; 用户主页（显示“张三”） 小李： 输入“李四”(保存数据：context.setAttribute(&quot;name&quot;,&quot;李四&quot;)) -&gt; 用户主页（显示“李四”） 问题： context是所有用户公有的资源！！！会覆盖数据。 小张： 输入“张三”（保存数据： request.setAttribute(&quot;name&quot;,&quot;张三&quot;)） - &gt; 用户主页（显示“张三”） 问题： 一定要使用转发技术来跳转页面！！！ 解决办法： 可以使用session域对象来保存会话数据！！！ 会话技术Cookie技术：会话数据保存在浏览器客户端Session技术：会话数据保存在服务器端 Cookie技术Cookie技术核心Cookie类：用以存储会话数据 1）构造Cookie对象 Cookie(java.lang.String name, java.lang.String value) 2）设置cookie void setPath(java.lang.String uri) ：设置cookie的有效访问路径 void setMaxAge(int expiry) ： 设置cookie的有效时间 void setValue(java.lang.String newValue) ：设置cookie的值 3）发送cookie到浏览器端保存 void response.addCookie(Cookie cookie) : 发送cookie 4）服务器接收cookie Cookie[] request.getCookies() : 接收cookie Cookie原理1）服务器创建cookie对象，把会话数据存储到cookie对象中。 new Cookie(&quot;name&quot;,&quot;value&quot;); 2） 服务器发送cookie信息到浏览器 response.addCookie(cookie); 举例： set-cookie: name=eric (隐藏发送了一个set-cookie名称的响应头) 3）浏览器得到服务器发送的cookie，然后保存在浏览器端。 4）浏览器在下次访问服务器时，会带着cookie信息 举例： cookie: name=eric (隐藏带着一个叫cookie名称的请求头) 5）服务器接收到浏览器带来的cookie信息 request.getCookies(); Cookie的细节1）void setPath(java.lang.String uri) ：设置cookie的有效访问路径。 有效路径指的是cookie的有效路径保存在哪里，那么浏览器在有效路径下访问服务 器时就会带着cookie信息，否则不带cookie信息。 2）void setMaxAge(int expiry) ： 设置cookie的有效时间。 正整数：表示cookie数据保存浏览器的缓存目录（硬盘中），数值表示保存的 时间。 负整数：表示cookie数据保存浏览器的内存中。浏览器关闭cookie就丢失 了！！ 零：表示删除同名的cookie数据 3）Cookie数据类型只能保存非中文字符串类型的。 可以保存多个cookie，但是浏览器一般只允许存放300个Cookie，每个站点最多存 放20个Cookie，每个Cookie的大小限制为4KB。 Session技术引入Cookie的局限： 1）Cookie只能存字符串类型。不能保存对象 2）只能存非中文。 3）1个Cookie的容量不超过4KB。 如果要保存非字符串，超过4kb内容，只能使用session技术！！！ Session特点： 会话数据保存在服务器端。（内存中） Session核心技术HttpSession类：用于保存会话数据 1）创建或得到session对象 HttpSession getSession() HttpSession getSession(boolean create) 2）设置session对象 void setMaxInactiveInterval(int interval) ： 设置session的有效时 间 void invalidate() ： 销毁session对象 java.lang.String getId() ： 得到session编号 3）保存会话数据到session对象 void setAttribute(java.lang.String name, java.lang.Object value) ： 保存数据 java.lang.Object getAttribute(java.lang.String name) ： 获取数据 void removeAttribute(java.lang.String name) ： 清除数据 Session技术原理问题： 服务器能够识别不同的浏览者！！！ 现象： 前提： 在哪个session域对象保存数据，就必须从哪个域对象取出！！！！ 浏览器1：(给s1分配一个唯一的标记：s001,把s001发送给浏览器) 1）创建session对象，保存会话数据 HttpSession session = request.getSession(); --保存会话数据 s1 浏览器1 的新窗口（带着s001的标记到服务器查询，s001-&gt;s1,返回s1） 1）得到session对象的会话数据 HttpSession session = request.getSession(); --可以取出 s1 新的浏览器1：(没有带s001,不能返回s1) 1）得到session对象的会话数据 HttpSession session = request.getSession(); --不可以取出 s2 浏览器2：(没有带s001,不能返回s1) 1）得到session对象的会话数据 HttpSession session = request.getSession(); --不可以取出 s3 代码解读：HttpSession session = request.getSession(); 1）第一次访问创建session对象，给session对象分配一个唯一的ID，叫JSESSIONID new HttpSession(); 2）把JSESSIONID作为Cookie的值发送给浏览器保存 Cookie cookie = new Cookie(&quot;JSESSIONID&quot;, sessionID); response.addCookie(cookie); 3）第二次访问的时候，浏览器带着JSESSIONID的cookie访问服务器 4）服务器得到JSESSIONID，在服务器的内存中搜索是否存放对应编号的session对 象。 if(找到){ return map.get(sessionID); } Map&lt;String,HttpSession&gt;] &lt;&quot;s001&quot;, s1&gt; &lt;&quot;s001,&quot;s2&gt; 5）如果找到对应编号的session对象，直接返回该对象 6）如果找不到对应编号的session对象，创建新的session对象，继续走1的流程 结论：通过JSESSION的cookie值在服务器找session对象！！！！！ Session细节1）java.lang.String getId() ： 得到session编号 2）两个getSession方法： getSession(true) / getSession() : 创建或得到session 对象。没有匹配的session编号，自动创建新的session对象。 getSession(false):得到session对象。没有匹配的session编号， 返回null 3）void setMaxInactiveInterval(int interval) ： 设置session的有效 时间 session对象销毁时间： 3.1 默认情况30分服务器自动回收 3.2 修改session回收时间 3.3 全局修改session有效时间 3.4.手动销毁session对象 void invalidate() ： 销毁session对象 4）如何避免浏览器的JSESSIONID的cookie随着浏览器关闭而丢失的问题 /** * 手动发送一个硬盘保存的cookie给浏览器 */ Cookie c = new Cookie(&quot;JSESSIONID&quot;,session.getId()); c.setMaxAge(60*60); response.addCookie(c); 版权声明：本文为博主原创文章，转载请注明出处KidSea]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java学习之路-7]]></title>
    <url>%2F2016%2F09%2F02%2Fjava%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-7%2F</url>
    <content type="text"><![CDATA[前言 java学习之路—–&gt;Servlet编程 内容 Servlet编程开发步骤1) 编写java类，继承HttpServlet类 2) 重写doGet和doPost方法 3) Servlet程序交给tomcat服务器运行 将程序的字节码class码拷贝到WEB-INF/classes目录下。 在web.xml文件里进行配置 &lt;!-- 配置一个servlet --&gt; &lt;!-- servlet的配置 --&gt; &lt;servlet&gt; &lt;!-- servlet的内部名称，自定义。尽量有意义 --&gt; &lt;servlet-name&gt;FirstServlet&lt;/servlet-name&gt; &lt;!-- servlet的类全名： 包名+简单类名 --&gt; &lt;servlet-class&gt;gz.example.a_servlet.FirstServlet&lt;/servlet-cl ass&gt; &lt;/servlet&gt; &lt;!-- servlet的映射配置 --&gt; &lt;servlet-mapping&gt; &lt;!-- servlet的内部名称，一定要和上面的内部名称保持一致！！ --&gt; &lt;servlet-name&gt;FirstServlet&lt;/servlet-name&gt; &lt;!-- servlet的映射路径（访问servlet的名称） --&gt; &lt;url-pattern&gt;/first&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; 访问步骤问题：访问次URL： http://localhost:8080/day10/first 前提: tomcat服务器启动时，首先加载webapp上面的web.xml的配置文件 http:// http协议 localhost: 到本地的hosts文件中查找是否存在该域名对应的IP地址 127.0.0.1 8080：找到tomcat服务器 /day10: 找到webapp目录下的day10目录 first: 资源名称. 1）在day10的web.xml中查找是否有匹配的url-pattern的内容（/first） 2）如果找到匹配的url-pattern,则使用当前servlet-name的名称到 web.xml文件中查询是否相同名称的servlet配置 3）如果找到，则取出对应的servlet配置信息中的servlet-class内容： 字符串： gz.example.a_servlet.FirstServlet 通过反射 a) 构造FirstServlet的对象 b) 然后调用FirstServlet里面的方法 Servlet的映射路径&lt;!-- servlet的映射配置 --&gt; &lt;servlet-mapping&gt; &lt;!-- servlet的内部名称，一定要和上面的内部名称保持一致！！ --&gt; &lt;servlet-name&gt;FirstServlet&lt;/servlet-name&gt; &lt;!-- servlet的映射路径（访问servlet的名称） --&gt; &lt;url-pattern&gt;/first&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; url-pattern 浏览器输入 精确匹配 /first http://localhost:8080/day10/first /itcast/demo1 http://localhost:8080/day10/itcast/demo1 模糊匹配 /* http://localhost:8080/day10/任意路径 /itcast/* http://localhost:8080/day10/itcast/任意 路径 *.后缀名 注意: 1) url-pattern 要么以/开头 要么以*开头。 例如， itcast是非法路径。 2）不能同时使用两种模糊匹配，例如 /itcast/*.do是非法路径 3）当有输入的URL有多个servlet同时被匹配的情况下： 3.1 精确匹配优先。（长的最像优先被匹配） 3.2 以后缀名结尾的模糊url-pattern优先级最低！！！ Servlet缺省路径servlet的缺省路径（&lt;url-pattern&gt;/&lt;/url-pattern&gt;）是在tomcat服务器内置的 一个路径。 该路径对应的是一个DefaultServlet（缺省Servlet）。 这个缺省的Servlet的作用是用于解析web应用的静态资源文件。 问题： URL输入http://localhost:8080/day10/index.html 如何读取文件 1）到当前day10应用下的web.xml文件查找是否有匹配的url-pattern。 2）如果没有匹配的url-pattern，则交给tomcat的内置的DefaultServlet处理 3）DefaultServlet程序到day10应用的根目录下查找是存在一个名称为 index.html的静态文件。 4）如果找到该文件，则读取该文件内容，返回给浏览器。 5）如果找不到该文件，则返回404错误页面。 结论： 先找动态资源，再找静态资源。 Servlet的生命周期(重点)Servlet的生命周期：Servlet类对象什么时候创建，调用什么方法，什么时候销毁。 Servlet程序的生命周期由tomcat服务器控制 Servlet重要的生命周期构造方法： 创建servlet对象的时候调用。默认情况下，第一次访问servlet的时候创 建servlet对象。 init方法： 创建完servlet对象的时候调用。只调用1次。 service方法： 每次发出请求时调用。调用n次。 destroy方法： 销毁servlet对象的时候调用。停止服务器或者重新部署web应用时销 毁servlet对象。 只调用1次。 只调用1次。证明servlet对象在tomcat是单实例的。 伪代码演示servlet的生命周期Tomtcat内部代码运行： 1）通过映射找到到servlet-class的内容，字符串： gz.itcast.a_servlet.FirstServlet 2）通过反射构造FirstServlet对象 2.1 得到字节码对象 Class clazz = class.forName(&quot;gz.itcast.a_servlet.FirstServlet&quot;); 2.2 调用无参数的构造方法来构造对象 Object obj = clazz.newInstance(); ---1.servlet的构造方法被调用 3）创建ServletConfig对象，通过反射调用init方法 3.1 得到方法对象 Method m = clazz.getDeclareMethod(&quot;init&quot;,ServletConfig.class); 3.2 调用方法 m.invoke(obj,config); --2.servlet的init方法被调用 4）创建request，response对象，通过反射调用service方法 4.1 得到方法对象 Methodm m =clazz.getDeclareMethod(&quot;service&quot;, HttpServletRequest.class,HttpServletResponse.class); 4.2 调用方法 m.invoke(obj,request,response); --3.servlet的service方法被调用 5）当tomcat服务器停止或web应用重新部署，通过反射调用destroy方法 5.1 得到方法对象 Method m = clazz.getDeclareMethod(&quot;destroy&quot;,null); 5.2 调用方法 m.invoke(obj,null); --4.servlet的destroy方法被调用 Servlet的自动加载默认情况下，第一次访问servlet的时候创建servlet对象。 如果servlet的构造方法或init方法中执行了比较多的逻辑代码，那么导致用户第一次 访问sevrlet的时候比较慢。 改变servlet创建对象的时机： 提前到加载web应用的时候！！！ 在servlet的配置信息中，加上一个&lt;load-on-startup&gt;即可！！ &lt;servlet&gt; &lt;servlet-name&gt;LifeDemo&lt;/servlet-name&gt; &lt;servlet-class&gt;gz.itcast.c_life.LifeDemo&lt;/servlet-class&gt; &lt;!-- 让servlet对象自动加载 --&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; 注意： 整数值越大， 创建优先级越低！！ &lt;/servlet&gt; 有参的init方法和无参的init方法有参方法，生命周期方法，一定会被tomcat服务器调用 无参方法，是用以初始化的方法 Servlet的多线程并发问题注意： servlet对象在tomcat服务器是单实例多线程的。 因为servlet是多线程的，所以当多个servlet的线程同时访问了servlet的 共享数据，如成员变量，可能会引发线程安全问题。 解决办法： 1）把使用到共享数据的代码块进行同步（使用synchronized关键字进行同步） 2）建议在servlet类中尽量不要使用成员变量。如果确实要使用成员， 必须同步。而且尽量缩小同步代码块的范围。 （哪里使用到了成员变量，就同步哪里），以避免因为同步而导致并发效率降低。 Servlet学习：HttpServletRequest 请求对象：获取请求信息 HttpServletResponse 响应对象： 设置响应对象 ServletConfig对象 servlet配置对象 ServletContext对象 servlet的上下文对象 Servletconfig对象用于加载servlet的初始化参数 对象创建和得到 创建时机：在创建完servlet对象后，调用init方法之前 得到对象：直接从init方法里得到 servlet的初始化配置参数 &lt;servlet&gt; &lt;servlet-name&gt;ConfigDemo&lt;/servlet-name&gt; &lt;servlet-class&gt;gz.itcast.f_config.ConfigDemo&lt;/servlet-class&gt; &lt;!-- 初始参数： 这些参数会在加载web应用的时候，封装到ServletConfi g对象中 --&gt; &lt;init-param&gt; &lt;param-name&gt;path&lt;/param-name&gt; &lt;param-value&gt;e:/b.txt&lt;/param-value&gt; &lt;/init-param&gt; &lt;/servlet&gt; 注意： servlet的参数只能由当前的这个sevlet获取！！！！ ServletConfig的API： java.lang.String getInitParameter(java.lang.String name) 根据参数名获取参数值 java.util.Enumeration getInitParameterNames() 获取所有参数 ServletContext getServletContext() 得到servlet上下文对象 java.lang.String getServletName() 得到servlet的名称 ServletContext对象ServletContext对象 ,叫做Servlet的上下文对象。 表示一个当前的web应用环境。一个web应用中只有一个ServletContext对象。 对象创建和得到创建时机：加载web应用时创建ServletContext对象。 得到对象： 从ServletConfig对象的getServletContext方法得到 我们设计： 创建ServletConfig对象 public void init( ServletConfig config，ServletContext c ontext ){ 多了一个参数 得到ServletConfig对象 得到ServletContext对象； } Sun公司设计 1）创建ServletContext对象 ServletContext context = new ServletContext() 2）创建ServletConfig对象 ServetConfig config = new ServletConfig(); config.setServletContxt(context); class ServletConfig{ ServletContext context; public ServletContext getServletContxt(){ return contxt; } } public void init( ServletConfig config ){ 得到ServletConfig对象 从ServletConfig对象中得到ServletContext对象 SerlvetContext context = config.getServletContext(); } ServletContext对象的核心API(作用)java.lang.String getContextPath() --得到当前web应用的路径 java.lang.String getInitParameter(java.lang.String name) --得到web应用的初始化参数 java.util.Enumeration getInitParameterNames() void setAttribute(java.lang.String name, java.lang.Object object) --域对象有关的方法 java.lang.Object getAttribute(java.lang.String name) void removeAttribute(java.lang.String name) RequestDispatcher getRequestDispatcher(java.lang.String path) --转发（类似于重定向） java.lang.String getRealPath(java.lang.String path) --得到web应用的资源文件 java.io.InputStream getResourceAsStream(java.lang.String path) 得到web应用路径 java.lang.String getContextPath() 用在请求重定向的资源名称中 得到web应用的初始化参数（全局） java.lang.String getInitParameter(java.lang.String name) --得到web应用的初始化参数 java.util.Enumeration getInitParameterNames() web应用参数可以让当前web应用的所有servlet获取！！！ 域对象有关的方法域对象：作用是用于保存数据，获取数据。可以在不同的动态资源之间共享数据。 案例： Servlet1 Servlet2 name=eric response.sendRedirect(&quot;/Servlet2?name=eric&quot;) String request.getParameter(&quot;name&quot;); 保存到域对象中 从域对象获取 Student 方案1： 可以通过传递参数的形式，共享数据。局限：只能传递字符串类型。 方案2： 可以使用域对象共享数据，好处：可以共享任何类型的数据！！！！！ ServletContext就是一个域对象！！！！ 保存数据： void setAttribute(java.lang.String name, java.lang.Object object) 获取数据： java.lang.Object getAttribute(java.lang.String name) 删除数据： void removeAttribute(java.lang.String name) ServletContext域对象：作用范围在整个web应用中有效！！！ 所有域对象： HttpServletRequet 域对象 ServletContext域对象 HttpSession 域对象 PageContext域对象 转发RequestDispatcher getRequestDispatcher(java.lang.String path) 1）转发 a）地址栏不会改变 b）转发只能转发到当前web应用内的资源 c）可以在转发过程中，可以把数据保存到request域对象中 2）重定向 a）地址栏会改变，变成重定向到地址。 b）重定向可以跳转到当前web应用，或其他web应用，甚至是外部域名网站。 c）不能再重定向的过程，把数据保存到request中。 结论： 如果要使用request域对象进行数据共享，只能用转发技术！！！ 加载web应用中的资源文件 版权声明：本文为博主原创文章，转载请注明出处KidSea]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java学习之路-6]]></title>
    <url>%2F2016%2F09%2F01%2Fjava%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-6%2F</url>
    <content type="text"><![CDATA[前言 java学习之路—–&gt;Servlet入门与Http协议 内容 开发动态资源静态资源和动态资源的区别静态资源：当用户多次访问这个资源，资源的源代码永远不会改变的资源。 动态资源：当用户多次访问这个资源，资源的源代码可能会发送改变。 动态资源开发技术servlet: 用java语言来编写动态资源的开发技术. servlet特点： 1) 普通的java类，继承HttpServlet类，覆盖doGet方法 2) Servlet类只能由tomcat服务器来运行(开发者不能运行) Servlet手动编写步骤： 1) 编写一个servlet程序，继承HttpServlet public class HelloServlet extends HttpServlet{ @Override protected void doGet(HttpServletRequest req, HttpServlet Response resp) throws ServletException, IOException { //解决中文乱码问题 resp.setContentType(&quot;text/html;charset=utf-8&quot;); //向浏览器输出内容 resp.getWriter().write(&quot;这是第一个servlet程序。当前时间 为：&quot;+new Date()); } } 2) 找到HelloServlet类的class字节码，然后把拷贝到tomcat的一个web应用中 WEB-INF/classes目录下。 3) 在当前web应用下的web.xml文件配置Servlet。 &lt;!-- 配置一个servlet程序 --&gt; &lt;servlet&gt; &lt;!-- servlet的内部名称 ，可以自定义--&gt; &lt;servlet-name&gt;HelloServlet&lt;/servlet-name&gt; &lt;!-- servlet类名： 包名+简单类名--&gt; &lt;servlet-class&gt;gz.itcast.d_servlet.HelloServlet&lt;/servle t-class&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;!-- servlet的内部名称，和上面的名称保持一致！！！--&gt; &lt;servlet-name&gt;HelloServlet&lt;/servlet-name&gt; &lt;!-- servlet的访问名称： /名称 --&gt; &lt;url-pattern&gt;/hello&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; 4) 启动tomcat服务器，运行访问 访问servlet: http://localhost:8080/myweb/ hello 工具开发动态资源1) 创建web project （javaweb工程） 2) 在WebRoot下建立静态资源文件， 3) 在src下建立动态资源文件 3.1 new -&gt; Servlet( servlet的代码生成器) 3.2 写pacakge -&gt; class名 -&gt; 修改mapping url 4) 关联tomcat服务器 4.1 window-&gt; Preferences - &gt; MyEcplise -&gt; servers -&gt; Tomcat 6.x (注意一定要enable) 5) 部署web project应用。（拷贝web应用到tomcat的webapps目录下） 6) 启动tomcat服务器 7) 访问servlet http://localhost:8081/day08_web/hello Http协议Http协议入门http协议：对浏览器客户端和服务器端之间数据传输的格式规范。 tcp/ip协议: 数据传输的底层协议，关注是客户端与服务器之间的数据是否传输成功。 http协议是在tcp/ip之前的封装的一层协议，关注的是数据传输规范。 Http协议 查看Http协议的工具1）使用火狐的firebug插件（右键-&gt;firebug-&gt;网络） 2）使用谷歌的“审查元素” 3）使用系统自带的telnet工具（远程访问工具） a）telnet localhost 8080 访问tomcat服务器 b）ctrl+] 回车 可以看到回显 c）输入请求内容 GET /day09/hello HTTP/1.1 Host: localhost:8080 d）回车，即可查看到服务器响应信息。 Http请求请求（浏览器-》服务器）GET /day09/hello HTTP/1.1 --请求行 Host: localhost:8080 --请求头(多个键值对象) User-Agent: Mozilla/5.0 (Windows NT 6.1; WOW64; rv:35.0) Gecko/2 0100101 Firefox/35.0 Accept: text/html,application/xhtml+xml,application/xm l;q=0.9,*/*;q=0.8 Accept-Language: zh-cn,en-us;q=0.8,zh;q=0.5,en;q=0.3 Accept-Encoding: gzip, deflate Connection: keep-alive --一个空行 name=eric&amp;password=123456 --（可选）实体内容 请求行GET /day09/hello HTTP/1.1 http协议版本 http1.0: 当前浏览器客户端与服务器建立连接后，只能发送一次请求，就结 束连接，效率低。 http1.1: 当前浏览器客户端与服务器建立连接后，可以在一次连接中发送多 次请求，效率高。 请求资源 URL: 统一资源定位符, http://localhost:8080/day09/testImg.html 只能定位互联网资源 是URI的子集 URI：统一资源标记符, /day09/hello 可以定位任意资源 请求方式 常见的请求方式: GET 、 POST、 HEAD、 TRACE、 PUT、 CONNECT 、DE LETE 常用的请求方式：GET 和 POST 表单提交 &lt;form action=&quot;提交地址&quot; method=&quot;GET/POST&quot;&gt; &lt;form&gt; get与post的区别 1)get方式 a）地址栏（URI）会跟上参数数据。以？开头，多个参数之间以&amp;分割。 b）GET提交参数数据有限制，不超过1KB。 c）GET方式不适合提交敏感密码。 d）注意： 浏览器直接访问的请求，默认提交方式是GET方式 2)post方式 a）参数不会跟着URI后面。参数而是跟在请求的实体内容中。没有？开 头，多个参数之间以&amp;分割。 b）POST提交的参数数据没有限制。 c）POST方式提交敏感数据。 请求头Accept: text/html,image/* -- 浏览器接受的数据类型 Accept-Charset: ISO-8859-1 -- 浏览器接受的编码格式 Accept-Encoding: gzip,compress --浏览器接受的数据压缩格式 Accept-Language: en-us,zh- --浏览器接受的语言 Host: www.it315.org:80 --（必须的）当前请求访问的 目标地址（主机:端口） If-Modified-Since: Tue, 11 Jul 2000 18:23:51 GMT --浏览器最后的 缓存时间 Referer: http://www.it315.org/index.jsp -- 当前请求来自于哪里 User-Agent: Mozilla/4.0 (compatible; MSIE 5.5; Windows NT 5.0) --浏览器类型 Cookie:name=eric -- 浏览器保存的cookie信息 Connection: close/Keep-Alive -- 浏览器跟服务器 连接状态。close: 连接关闭 keep-alive：保存连接。 Date: Tue, 11 Jul 2000 18:23:51 GMT -- 请求发出的时间 实体内容只有POST提交的参数会放到实体内容中 HttpServletRequest对象HttpServletRequest对象作用是用于获取请求数据。 核心的API： 请求行： request.getMethod(); 请求方式 request.getRequetURI() / request.getRequetURL() 请求资源 request.getProtocol() 请求http协议版本 请求头： request.getHeader(&quot;名称&quot;) 根据请求头获取请求值 request.getHeaderNames() 获取所有的请求头名称 实体内容: request.getInputStream() 获取实体内容数据 传递的请求参数如何获取 GET方式： 参数放在URI后面 POST方式： 参数放在实体内容中 获取GET方式参数： request.getQueryString(); 获取POST方式参数： request.getInputStream(); 问题：但是以上两种不通用，而且获取到的参数还需要进一步地解析。 所以可以使用统一方便的获取参数的方式： 核心的API： request.getParameter(&quot;参数名&quot;); 根据参数名获取参数值 （注意，只能获取一个值的参数） request.getParameterValue(&quot;参数名“)；根据参数名获取参数值 （可以获取多个值的参数） request.getParameterNames(); 获取所有参数名称列表 请求参数编码问题修改POST方式参数编码： request.setCharacterEncoding(&quot;utf-8&quot;); 修改GET方式参数编码： 手动解码：String name = new String(name.getBytes(&quot;iso-8859-1&quot;),&quot;utf-8&quot;); 请求参数编码问题 Http响应响应（服务器-》浏览器）HTTP/1.1 200 OK --响应行 Server: Apache-Coyote/1.1 --响应头 Content-Length: 24 Date: Fri, 30 Jan 2015 01:54:57 GMT --一个空格 this is hello servlet!!! --实体内容 响应行HTTP/1.1 200 OK http响应版本 状态码 常见的状态： 200：表示请求处理完成并完美返回 302：表示请求需要进一步细化。 404：表示客户访问的资源找不到。 500：表示服务器的资源发送错误。（服务器内部错误） 常见的响应头Location: http://www.it315.org/index.jsp -表示重定向的地址， 该头和302的状态码一起使用。 Server:apache tomcat ---表示服务器的类型 Content-Encoding: gzip -- 表示服务器发送给浏览器的 数据压缩类型 请求重定向 Content-Length: 80 --表示服务器发送给浏览器的数据长度 Content-Language: zh-cn --表示服务器支持的语言 Content-Type: text/html; charset=GB2312 --表示服务器发送给浏览器的 数据类型及内容编码 Last-Modified: Tue, 11 Jul 2000 18:23:51 GMT --表示服务器资源的 最后修改时间 Refresh: 1;url=http://www.it315.org --表示定时刷新 Content-Disposition: attachment; filename=aaa.zip --表示告诉浏览器以 下载方式打开资源（下载文件时用到） Transfer-Encoding: chunked Set-Cookie:SS=Q0=5Lb_nQ; path=/search --表示服务器发送给浏览器的 cookie信息（会话管理用到） Expires: -1 --表示通知浏览器不进行缓存 Cache-Control: no-cache Pragma: no-cache Connection: close/Keep-Alive --表示服务器和浏览器的连接状态。close：关闭连接 keep-alive:保存连接 HttpServletResponse对象HttpServletResponse对象修改响应信息： 响应行： response.setStatus() 设置状态码 响应头： response.setHeader(&quot;name&quot;,&quot;value&quot;) 设置响应头 实体内容： response.getWriter().writer(); 发送字符实体内容 response.getOutputStream().writer() 发送字节实体内容 响应数据编码 项目中的编码问题 版权声明：本文为博主原创文章，转载请注明出处KidSea]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android源码下载]]></title>
    <url>%2F2016%2F08%2F31%2FAndroid%E6%BA%90%E7%A0%81%E4%B8%8B%E8%BD%BD%2F</url>
    <content type="text"><![CDATA[前言 Android源码下载 内容 Android源码下载 Android源码下载支持的系统目前只有Ubuntu和Mac OS两种操作系统, 本次以Ubuntu系统为例. 官方网站: http://source.android.com/source/downloading.html 下载单独项目的源码：https://github.com/android 下载Git(版本控制工具). 调出命令行: ctrl + alt + T sudo apt-get install git （下载地址在源中,&quot;系统设置/软件和更新&quot;,路径：/etc/apt/sources.list） 安装curl(上传和下载数据的工具). sudo apt-get install curl 安装repo(一个基于git的版本库管理工具, 这里用于自动批量下载android整个项目.). // 创建目录 mkdir ~/bin // 下载repo脚本到本地bin文件夹下 curl http://android.git.kernel.org/repo &gt;~/bin/repo （官网：curl https://storage.googleapis.com/git-repo-downloads/repo &gt; ~/bin/repo） // 如果上面下载失败, 采用下面这种方式 curl &quot;http://php.webtutor.pl/en/wp-content/uploads/2011/09/repo&quot; &gt;~/bin/repo // 给所有用户追加可执行的权限 chmod a+x ~/bin/repo // 临时把repo添加到环境变量中, 方便后面执行. // 注意: 每次重启ubuntu之后此环境变量失效, 重新配置就可以了. export PATH=~/bin:$PATH 创建文件夹, 用于存放下载的Android源码. // 创建目录 mkdir ~/android_source // 修改权限 chmod 777 ~/android_source cd ~/android_source 初始化库. // 需要先配置git的用户信息 git config --global user.email &quot;dai_zhenliang@163.com&quot; git config --global user.name &quot;haha&quot; repo init -u https://android.googlesource.com/platform/manifest -b android-2.3_r1 // 如果上面初始化失败, 用下面的代码 repo init -u git://codeaurora.org/platform/manifest.git -b gingerbread ######当屏幕出现以下信息表示成功初始化 repo initialized in /home/haha/android_source 开始同步下载. repo sync 注意: 下载过程中, 因为网络问题, 可能会中断下载. 当中断下载时, 继续使用repo sync命令继续下载. 版权声明：本文为博主原创文章，转载请注明出处KidSea]]></content>
      <tags>
        <tag>安卓</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android源码分析]]></title>
    <url>%2F2016%2F08%2F31%2FAndroid%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[前言 Android源码分析 内容 Android系统启动流程 当系统引导程序启动Linux内核，内核会加载各种数据结构，和驱动程序，加载完毕之后，Android系统开始启动并加载第一个用户级别的进程：init（system/core/init/Init.c） 查看Init.c代码，看main函数 int main(int argc, char **argv) { ... //执行Linux指令 mkdir(&quot;/dev&quot;, 0755); mkdir(&quot;/proc&quot;, 0755); mkdir(&quot;/sys&quot;, 0755); ... //解析执行init.rc配置文件 init_parse_config_file(&quot;/init.rc&quot;); ... } 在system\core\rootdir\Init.rc中定义好的指令都会开始执行，其中执行了很多bin指令，启动系统服务 //启动孵化器进程，此进程是Android系统启动关键服务的一个母进程 service zygote /system/bin/app_process -Xzygote /system/bin --zygote --start-system-server socket zygote stream 666 onrestart write /sys/android_power/request_state wake onrestart write /sys/power/state on onrestart restart media onrestart restart netd 在app_process文件夹下找到app_main.cpp，查看main函数，发现以下代码 int main(int argc, const char* const argv[]) { ... //启动一个系统服务：ZygoteInit runtime.start(&quot;com.android.internal.os.ZygoteInit&quot;,startSystemServer); ... } 在ZygoteInit.java中，查看main方法 public static void main(String argv[]) { ... //加载Android系统需要的类 preloadClasses(); ... if (argv[1].equals(&quot;true&quot;)) { //调用方法启动一个系统服务 startSystemServer(); } ... } startSystemServer()方法的方法体 String args[] = { &quot;--setuid=1000&quot;, &quot;--setgid=1000&quot;, &quot;--setgroups=1001,1002,1003,1004,1005,1006,1007,1008,1009,1010,1018,3001,3002,3003&quot;, &quot;--capabilities=130104352,130104352&quot;, &quot;--runtime-init&quot;, &quot;--nice-name=system_server&quot;, &quot;com.android.server.SystemServer&quot;, }; ... //分叉启动上面字符串数组定义的服务 pid = Zygote.forkSystemServer( parsedArgs.uid, parsedArgs.gid, parsedArgs.gids, debugFlags, null, parsedArgs.permittedCapabilities, parsedArgs.effectiveCapabilities); SystemServer服务被启动 public static void main(String[] args) { ... //加载动态链接库 System.loadLibrary(&quot;android_servers&quot;); //执行链接库里的init1方法 init1(args); ... } 动态链接库文件和java类包名相同，找到com_android_server_SystemServer.cpp文件 在com_android_server_SystemServer.cpp文件中，找到了 static JNINativeMethod gMethods[] = { /* name, signature, funcPtr */ //给init1方法映射一个指针，调用system_init方法 { &quot;init1&quot;, &quot;([Ljava/lang/String;)V&quot;, (void*) android_server_SystemServer_init1 }, }; android_server_SystemServer_init1方法体中调用了system_init()，system_init()没有方法体 在system_init.cpp文件中找到system_init()方法，方法体中 //执行了SystemServer.java的init2方法 runtime-&gt;callStatic(&quot;com/android/server/SystemServer&quot;, &quot;init2&quot;); 回到SystemServer.java，在init2的方法体中 //启动一个服务线程 Thread thr = new ServerThread(); thr.start(); 在ServerThread的run方法中 //准备消息轮询器 Looper.prepare(); ... //启动大量的系统服务并把其逐一添加至ServiceManager ServiceManager.addService(Context.WINDOW_SERVICE, wm); ... //调用systemReady，准备创建第一个activity ((ActivityManagerService)ActivityManagerNative.getDefault()) .systemReady(new Runnable(){ ... }）； 在ActivityManagerService.java中，有systemReady方法，方法体里找到 //检测任务栈中有没有activity，如果没有，创建Launcher mMainStack.resumeTopActivityLocked(null); 在ActivityStack.java中，方法resumeTopActivityLocked // Find the first activity that is not finishing. ActivityRecord next = topRunningActivityLocked(null); ... if (next == null) { // There are no more activities! Let&apos;s just start up the // Launcher... if (mMainStack) { return mService.startHomeActivityLocked(); } } ... Handler消息机制 Message类的obtain方法 消息队列顺序的维护是使用单链表的形式来维护的 把消息池里的第一条数据取出来，然后把第二条变成第一条 if (sPool != null) { Message m = sPool; sPool = m.next; m.next = null; sPoolSize--; return m; } 创建Handler对象时，在构造方法中会获取Looper和MessageQueue的对象 public Handler() { ... //拿到looper mLooper = Looper.myLooper(); ... //拿到消息队列 mQueue = mLooper.mQueue; mCallback = null; } 查看myLooper方法体，发现Looper对象是通过ThreadLocal得到的，再查找ThreadLocal的set方法时发现 Looper是直接new出来的，并且在Looper的构造方法中，new出了消息队列对象 sThreadLocal.set(new Looper()); private Looper() { mQueue = new MessageQueue(); mRun = true; mThread = Thread.currentThread(); } sThreadLocal.set(new Looper())是在Looper.prepare方法中调用的 prepare方法是在prepareMainLooper()方法中调用的 public static final void prepareMainLooper() { prepare(); ... } 在应用启动时，主线程要被启动，ActivityThread会被创建，在此类的main方法中 public static final void main(String[] args) { ... //创建Looper和MessageQueue Looper.prepareMainLooper(); ... //轮询器开始轮询 Looper.loop(); ... } Looper.loop()方法中有一个死循环 while (true) { //取出消息队列的消息，可能会阻塞 Message msg = queue.next(); // might block ... //解析消息，分发消息 msg.target.dispatchMessage(msg); ... } Linux的一个进程间通信机制：管道（pipe）。原理：在内存中有一个特殊的文件，这个文件有两个句柄（引用），一个是读取句柄，一个是写入句柄 主线程Looper从消息队列读取消息，当读完所有消息时，进入睡眠，主线程阻塞。子线程往消息队列发送消息，并且往管道文件写数据，主线程即被唤醒，从管道文件读取数据，主线程被唤醒只是为了读取消息，当消息读取完毕，再次睡眠 Handler发送消息，sendMessage的所有重载，实际最终都调用了sendMessageAtTime public boolean sendMessageAtTime(Message msg, long uptimeMillis) { ... //把消息放到消息队列中 sent = queue.enqueueMessage(msg, uptimeMillis); ... } enqueueMessage把消息通过重新排序放入消息队列 final boolean enqueueMessage(Message msg, long when) { ... final boolean needWake; synchronized (this) { ... //对消息的重新排序，通过判断消息队列里是否有消息以及消息的时间对比 msg.when = when; Message p = mMessages; if (p == null || when == 0 || when &lt; p.when) { // 如果消息队列中没有消息，或者当前消息的时候比队列中的消息的时间小，则让当前消息成为队列中的第一条消息 msg.next = p; mMessages = msg; needWake = mBlocked; // new head, might need to wake up } else { // 代码能进入到这里说明消息队列中有消息，且队列中的消息时间比当前消息时间小，说明当前消息不能做为队列中的第一条消息 Message prev = null; // 当前消息要插入到这个prev消息的后面 // 这个while循环用于找出当前消息(msg)应该插入到消息列表中的哪个消息的后面（应该插入到prev这条消息的后面） while (p != null &amp;&amp; p.when &lt;= when) { prev = p; p = p.next; } // 下面两行代码 msg.next = prev.next; prev.next = msg; needWake = false; // still waiting on head, no need to wake up } } //唤醒主线程 if (needWake) { nativeWake(mPtr); } return true; } Looper.loop方法中，获取消息，然后分发消息 //获取消息队列的消息 Message msg = queue.next(); // might block ... //分发消息，消息由哪个handler对象创建，则由它分发，并由它的handlerMessage处理 msg.target.dispatchMessage(msg); message对象的target属性，用于记录该消息由哪个Handler创建，在obtain方法中赋值 Handler中的Callback接口，可能过构造方法或其它方法传入 Handler的dispatchMessage方法中： public void dispatchMessage(Message msg) { if (msg.callback != null) { handleCallback(msg); // 第一优先Runnable对象 } else { if (mCallback != null) { if (mCallback.handleMessage(msg)) { // 第二优先Callback对象 return; } } handleMessage(msg); } } Message中保存了callback(Runnabe)和target(Handler)，也可以调用Message的sendToTarget()方法来发消息，前提是必须已经给Message设置了target对象。 Handler消息机制 AsyncTask机制 AsyncTask基本使用： AsyncTask&lt;String, Integer, Object&gt; asyncTask = new AsyncTask&lt;String, Integer, Object&gt;() { protected void onPreExecute() {}; @Override protected Object doInBackground(String... params) { return null; } protected void onPostExecute(Object result) {}; protected void onProgressUpdate(Integer[] values) {}; }; asyncTask.execute(&quot;params&quot;) AsyncTask的execute方法，开始执行异步任务，在此方法体中 public final AsyncTask&lt;Params, Progress, Result&gt; execute(Params... params) { ... mStatus = Status.RUNNING; //调用onPreExecute方法 onPreExecute(); //把参数赋值给mWorker对象 mWorker.mParams = params; //线程池对象执行mFuture sExecutor.execute(mFuture); return this; } mWorker是什么类型？，在AsyncTask的构造方法中 mWorker = new WorkerRunnable&lt;Params, Result&gt;() { public Result call() throws Exception { Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND); return doInBackground(mParams); } }; 然后把mWorker对象封装至FutureTask对象 mFuture = new FutureTask&lt;Result&gt;(mWorker) 在FutureTask的构造中，又把mWorker封装给Sync对象 public FutureTask(Callable&lt;V&gt; callable) { if (callable == null) throw new NullPointerException(); sync = new Sync(callable); } 在Sync的构造方法中 Sync(Callable&lt;V&gt; callable) { //这里的callable就是mWorker this.callable = callable; } 线程池执行mFuture对象，此对象是FutureTask的对象，而FutureTask实现了Runnable接口 public final AsyncTask&lt;Params, Progress, Result&gt; execute(Params... params) { ... //线程池对象开一个子线程去执行mFuture对象中的run方法 sExecutor.execute(mFuture); ... } mFuture的run方法被调用了 public void run() { sync.innerRun(); } 在innerRun方法中，调用了callable的call方法，但是在sync被new出来的时候，在构造方法中就已经把mWorker赋值给了callable，所以实际上是调用mWorker的call方法 void innerRun() { ... //调用mWorker的call() result = callable.call(); set(result); ... } mWorker的call在mWorker被new出来时就已经重写了 mWorker = new WorkerRunnable&lt;Params, Result&gt;() { public Result call() throws Exception { ... //在子线程中调用了doInBackground方法 return doInBackground(mParams); } }; call方法调用完毕后，得到doInBackground所返回的result void innerRun() { ... result = callable.call(); //返回的result传入了set方法 set(result); ... } set方法体 protected void set(V v) { sync.innerSet(v); } innerSet方法体 if (compareAndSetState(s, RAN)) { result = v; releaseShared(0); //关键的done方法 done(); return; } innerSet方法是属于FutureTask类的，那么done方法也是调用FutureTask类的，这个done方法定义的地方，在AsyncTask.java的构造方法里 mFuture = new FutureTask&lt;Result&gt;(mWorker) { //此处重写done方法 @Override protected void done() { //获取doInbackground方法返回的结果 result = get(); //创建一个消息 message = sHandler.obtainMessage(MESSAGE_POST_RESULT, new AsyncTaskResult&lt;Result&gt;(AsyncTask.this, result)); //把这条消息发送给创建这个消息的Handler：target.sendMessage(this) message.sendToTarget(); } }; 然后sHandler的handlerMessage被触发 public void handleMessage(Message msg) { AsyncTaskResult result = (AsyncTaskResult) msg.obj; switch (msg.what) { case MESSAGE_POST_RESULT: //调用finish方法 result.mTask.finish(result.mData[0]); break; } } 查看AsyncTaskResult类中的mTask成员，其实它就是AsyncTask对象 再看AsyncTask对象的finish的方法体 private void finish(Result result) { if (isCancelled()) result = null; //调用onPostExecute方法，并传入结果 onPostExecute(result); mStatus = Status.FINISHED; } AsyncTask分析 版权声明：本文为博主原创文章，转载请注明出处KidSea]]></content>
      <tags>
        <tag>安卓</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android源码编译]]></title>
    <url>%2F2016%2F08%2F31%2FAndroid%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91%2F</url>
    <content type="text"><![CDATA[前言 Android源码编译 内容 Android源码编译在编译源码之前需要做一些准备操作, 详细步骤如下: 1. 安装JDK, google官方要求编译2.3源码需要JDK1.6. 1). 下载JDK1.6, 下载地址:http://www.oracle.com/technetwork/java/javasebusiness/downloads/java-archive-downloads-javase6-419409.html、http://download.oracle.com/otn/java/jdk/6u45-b06/jdk-6u45-linux-x64.bin 2). 创建目录. sudo mkdir /usr/java 3). 在文件系统中右击上面的创建的文件夹，选择“以管理员权限打开”，然后把下载好的jdk-6u45-linux-x64.bin拖动到/usr/java目录中 4). 添加可执行权限. sudo chmod 755 /usr/java/jdk-6u45-linux-x64.bin 5). 解压. cd /usr/java sudo ./jdk-6u45-linux-x64.bin 6). 配置环境变量. export JAVA_HOME=/usr/java/jdk1.6.0_45 export PATH=$PATH:$JAVA_HOME/bin export CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar 7). 验证是否成功. java -version 2. 安装其他编译时依赖的软件.sudo apt-get install gnupg sudo apt-get install flex sudo apt-get install bison sudo apt-get install gperf sudo apt-get install zip sudo apt-get install curl sudo apt-get install build-essential sudo apt-get install libesd0-dev sudo apt-get install libwxgtk2.8-dev sudo apt-get install libsdl-dev sudo apt-get install lsb-core sudo apt-get install lib32readline-gplv2-dev sudo apt-get install g++-multilib sudo apt-get install lib32z1-dev sudo apt-get install libswitch-perl 安装注意事项： 3. 开始编译, 在源码的目录下, 执行一下命令:cd ~/android_source make clean(如果之前有编译过，则需要调用这个命令) make 注意: ubuntu自带的源中速度比较慢, 有些软件找不到, 所以需要修改为国内的源, 修改源步骤如下: 1). 备份ubuntu自带的源. sudo cp /etc/apt/sources.list /etc/apt/sources.list.old 2). 修改源文件. sudo gedit /etc/apt/sources.list 3). 这时会弹出一个文本编辑框, 先删除所有内容, 然后把以下内容拷贝进去, 并保存. deb http://mirrors.163.com/ubuntu/ trusty main restricted universe multiverse deb http://mirrors.163.com/ubuntu/ trusty-security main restricted universe multiverse deb http://mirrors.163.com/ubuntu/ trusty-updates main restricted universe multiverse deb http://mirrors.163.com/ubuntu/ trusty-proposed main restricted universe multiverse deb http://mirrors.163.com/ubuntu/ trusty-backports main restricted universe multiverse deb-src http://mirrors.163.com/ubuntu/ trusty main restricted universe multiverse deb-src http://mirrors.163.com/ubuntu/ trusty-security main restricted universe multiverse deb-src http://mirrors.163.com/ubuntu/ trusty-updates main restricted universe multiverse deb-src http://mirrors.163.com/ubuntu/ trusty-proposed main restricted universe multiverse deb-src http://mirrors.163.com/ubuntu/ trusty-backports main restricted universe multiverse deb http://mirrors.sohu.com/ubuntu/ trusty main restricted universe multiverse deb http://mirrors.sohu.com/ubuntu/ trusty-security main restricted universe multiverse deb http://mirrors.sohu.com/ubuntu/ trusty-updates main restricted universe multiverse deb http://mirrors.sohu.com/ubuntu/ trusty-proposed main restricted universe multiverse deb http://mirrors.sohu.com/ubuntu/ trusty-backports main restricted universe multiverse deb-src http://mirrors.sohu.com/ubuntu/ trusty main restricted universe multiverse deb-src http://mirrors.sohu.com/ubuntu/ trusty-security main restricted universe multiverse deb-src http://mirrors.sohu.com/ubuntu/ trusty-updates main restricted universe multiverse deb-src http://mirrors.sohu.com/ubuntu/ trusty-proposed main restricted universe multiverse deb-src http://mirrors.sohu.com/ubuntu/ trusty-backports main restricted universe multiverse 4). 保存之后, 更新数据源. sudo apt-get update 版权声明：本文为博主原创文章，转载请注明出处KidSea]]></content>
      <tags>
        <tag>安卓</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Connection+使能新业务，拓展新市场]]></title>
    <url>%2F2016%2F08%2F31%2FConnection-%E4%BD%BF%E8%83%BD%E6%96%B0%E4%B8%9A%E5%8A%A1%EF%BC%8C%E6%8B%93%E5%B1%95%E6%96%B0%E5%B8%82%E5%9C%BA%2F</url>
    <content type="text"><![CDATA[前言 Connection+使能新业务，拓展新市场 内容 信息通信技术的迅猛发展极大丰富了人们的沟通与生活，全联接世界正渐行渐近。技术创新的脚步从未停歇，蜂窝网络技术的发展将继续扩大连接的领域。4.5G技术将把连接进一步扩展到物联网和集群通信领域，代表技术有NB-IoT（Narrow Band Internet of Things）和LiTRA（LTE integrated Trunked Radio）。 Connection+之NB-IoT介绍传统的互联网满足了人与人之间的通信，物联网将进一步把人与物，物与物连接起来。物联网的本质是基于数据的感知、获取和传输，数据的感知和获取即可以是通过智能设备、监控设备，也可以是通过基于传感器的实物终端，如居民日常用的水表，水表被连接起来后，极大提高工作效率的同时也为居民提供了便利。可以预见，物联网将渗透到我们工作和生活的方方面面，创造出极大的社会价值。 未来物联网中将有大量的应用是此类实物终端的连接，广泛的应用在日常生活如宠物跟踪，或垂直行业如工业制造、资产跟踪等方面。这些应用的共同特征是需要一张低功耗广域网（LPWAN，Low Power Wide Area Network），它应该具备如下特征： 频谱：使用授权频谱，具备良好的可靠性和安全性 覆盖能力强：能够覆盖到地下室、远郊等场景 终端功耗小：使用电池供电可支撑10年的使用周期 连接数量多：每小区100K的连接能力 成本低：通信模组成本低 传输时延：对时延不敏感 具备扩展能力：移动性、漫游、定位等能力 当前的蜂窝网络技术由于覆盖、功耗、成本等原因不能很好的满足LPWAN需求，NB-IoT（窄带蜂窝物联网）技术应运而生。它具有覆盖广、连接多、速率低、成本低、功耗少、架构优等特点。可以说，NB-IoT是最符合LPWAN需求的一种技术，是运营商进入LPWAN应用市场的最佳选择。 华为和沃达丰早在2013年就合作开始了低带宽网络连接技术的研究，并于2014向国际标准组织3GPP做技术提案，开启了NB-IoT技术方向。2015年9月NB-IoT正式在3GPP R13版本立项为Work Item，标准化进入加速阶段，预计2016年6月完成标准制定。 LPWAN市场已经崛起，为了快速匹配市场需求，华为在参与国际标准组织共同制定相关规范的同时，也启动了端到端解决方案的研发，并推出了可用于测试的预标准解决方案。基于预标准解决方案，华为成功于2015年6月与中国联通共同在上海完成了第一个全球样板点，于2015年12月与沃达丰共同在西班牙完成基于其商用网络的测试。 NB-IoT一个重要应用方向为垂直行业的物联通讯服务，产业创新需要与各垂直行业合作伙伴精诚合作。为此华为将在全球范围内与合作伙伴共同成立8个开放实验室作为创新平台，目前已经在智能停车、远程抄表等方向取得了卓有成效的实质进展。欢迎更多的合作伙伴加入我们共同打造全联接世界。 Connection+之LiTRA LTE公网集群通信解决方案介绍集群通信系统最早诞生于60年代末到70年代初。与普通的点对点全双工的移动通话不同，集群通信又被形象的称为PTT（Push To Talk, 一键通），它采用半双工、一对多的通信方式，具有低时延、大容量的优势，可满足用户一呼百应、一呼即应、现场实时调度的通信需求，广泛的应用于公共安全、公用事业以及企业领域。 集群通信正在从窄带走向宽带，从专网向公网演进。传统的集群技术多为窄带的专网通信标准，窄带技术导致其业务单一，以语音为主，无法支持视频多媒体等高速数据业务；而专网的技术架构带来了产业链封闭、系统设备采购和建设成本高、终端价格高、维护费用高等诸多问题，无法满足用户的业务诉求。 以LiTRA为代表的LTE公网集群（ PTT over LTE ）则很好的解决了上述问题，凭借LTE网络的大带宽和低时延的优势，LiTRA不但能够提供媲美传统集群的性能体验，还能够提供诸如视频呼叫、视频监控、文件传输、GIS协同等多媒体专业集群功能；更重要的是，它完全基于运营商的LTE现网部署，能够大幅度降低建网和维护成本，提供更好的网络覆盖和漫游服务，并且兼容LTE智能终端，打破了封闭的产业链限制，为用户提供更加专业和高效的集群通信服务。 当前， 3GPP正在主导新一代集群通信标准的制定。世界各大集群标准组织和政府机构，包括OMA、ETSI、TCCA、TIA、英国内政部、美国FCC、美国商务部等，都在与3GPP展开合作，在R12、R13、R14，构建一整套面向公共安全和关键任务应用场景，完全基于LTE公网的专业集群通标准。 LiTRA是华为推出的基于3GPP标准和LTE公网的专业集群解决方案，旨在帮助运营商为公共安全用户提供一个安全、高效、专业的PS LTE（Public Safety LTE）网络。 华为认为LTE商用网络直接用于公共安全应用场景，将面临诸多挑战。为此，LiTRA 从QoS、MCPTT语音、拥塞控制等五大方面全面提升LTE网络应对突发事件的能力，更好的为公共安全用户提供服务。 同时，LiTRA还发布了包括应用平台、调度台、APP以及三防终端的端到端产品解决方案，帮助运营商快速部署集群业务，抢占市场先机。 越来越多的国家准备基于运营商的LTE现网，部署国家公共安全网络。预计在2016，基于LTE公网的国家安全网络将逐步进入预商用阶段。 版权声明：本文为博主转载文章，转载请注明出处华为]]></content>
      <tags>
        <tag>Iot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java学习之路-5]]></title>
    <url>%2F2016%2F08%2F31%2Fjava%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-5%2F</url>
    <content type="text"><![CDATA[前言 java学习之路—–&gt;Web开发入门 内容 Web开发入门引入之前的程序： java桌面程序，控制台控制，socket gui界面。javase规范 现在和以后的程序：java web程序。浏览器控制。javaee规范 软件的构架C/S (Client - Server 客户端-服务器端)典型应用：QQ软件 ，飞秋，红蜘蛛。 特点： 1）必须下载特定的客户端程序。 2）服务器端升级，客户端升级。 B/S （Broswer -Server 浏览器端- 服务器端）典型应用： 腾讯官方（www.qq.com） 163新闻网站， （俗称：网站） 特点： 1）不需要安装特定的客户端（只需要安装浏览器即可！！） 2）服务器端升级，浏览器不需要升级！！！！ javaweb的程序就是b/s软件结构！！！ 服务器从物理上来说，服务器就是一台PC机器，8核,8G以上，T来计算，带宽100M以上 web服务器：PC机器安装一个具有web服务的软件，称之为web服务器 数据库服务器：PC机器安装一个具有数据管理件服务的软件，称之为数据库服务器。 邮件服务器：PC机器安装一个具有发送邮件服务的软件，称之为邮件服务器。 Web服务软件 作用：把本地的资源共享给外部访问 常见的市面上的web服务软件 javase的规范,包含IO流，线程，集合，socket编程。。。。 WebLogic: BEA公司的产品。 收费的。支持JavaEE规范。 WebSphere： IBM公司的产品。收费的。支持JavaEE规范 JBoss: Redhat公司的产品。收费的。支持JavaEE规范 Tomcat：开源组织Apache的产品。免费的。支持部分的JavaEE规范。（servle t、jsp。jdbc，但ejb， rmi不支持） Web服务软件用途 Tomcat基本使用下载并安装1）到apache官网。www.apache.org http://jakarta.apache.org(产品的主 页) 2） 安装版：window （exe、msi） linux（rmp） 压缩版：window（rar，zip） linux（tar，tar.gz）学习时候使用 3）运行和关闭tomcat 3.1 启动软件 a）找到%tomcat%/bin/startup.bat ，双击这个文件 b）弹出窗口，显示信息（不要关闭次窗口） c）打开浏览器，输出以下地址 http://localhost:8080 d）看到一只猫画面，证明软件启动成功！ 3.2 关闭软件 a）找到%tomcat%/bin/shutdown.bat，双击这个文件即可！ c）打开浏览器，输出以下地址。看到“无法连接”（最好先清空浏览器缓存） Tomcat运行图 tomcat软件使用的常见问题1）闪退问题 原因：tomcat软件是java语言开发的。 tomcat软件启动时，会默认到系统的环境 变量中查找一个名称叫JAVA_HOME的变量。这个变量的作用找到tomcat启动所需的 jvm。 解决办法； 到环境变量中设置JAVA_HOME的变量 JAVA_HOME= C:\Program Files\Java\jdk1.6.0_30 (注意别配置到bi n目录下) Tomcat配置 2）端口占用的错误 原因： tomcat启动所需的端口被其他软件占用了！ 解决办法： a）关闭其他软件程序，释放所需端口 b）修改tomcat软件所需端口 找到并修改%tomcat%/conf/server.xml文件 3）CATALINA环境变量问题 原因： tomcat软件启动后，除了查找JAVA_HOME后，还会再查找一个叫CAT ALINA_HOME变量，这个变量的作用是设置tomcat的根目录。 解决办法：建议不要设置CATALINA_HOME变量。检查如果有的话，清除掉！！！ 体验tomcat软件作用webapps目录： tomcat共享目录。需要共享的本地资源放到此目录中。 URL 统一资源定位符，用以定位互联网的资源 问题： http://localhost:8081/myweb/test.html 看到文件？ http:// 协议。http协议。 localhost 域名。为了找到IP地址。 本地域名： localhost 外部域名：www.baidu.com 8081 端口。软件监听的 8080： tomcat默认的端口 3306：mysql数据库的端口 1521： orace数据库的端口。 /myweb: web应用的名称。默认情况下，在webapps目录下找 /test.html ： 资源名称。 Tomcat的目录结构 |-bin: 存放tomcat的命令。 catalina.bat 命令： startup.bat -&gt; catalina.bat start shutdown.bat - &gt; catalina.bat stop |- conf: 存放tomcat的配置信息。其中server.xml文件是核心的配置文件。 |-lib：支持tomcat软件运行的jar包。其中还有技术支持包，如servlet，jsp |-logs：运行过程的日志信息 |-temp: 临时目录 |-webapps： 共享资源目录。web应用目录。（注意不能以单独的文件进行共享） |-work： tomcat的运行目录。jsp运行时产生的临时文件就存放在这里 Web应用的目录结构 |- WebRoot : web应用的根目录 |- 静态资源（html+css+js+image+vedio） |- WEB-INF ： 固定写法。 |-classes： （可选）固定写法。存放class字节码文件 |-lib： （可选）固定写法。存放jar包文件。 |-web.xml 注意： 1）WEB-INF目录里面的资源不能通过浏览器直接访问 2）如果希望访问到WEB-INF里面的资源，就必须把资源配置到一个叫web.xml的文件中。 版权声明：本文为博主原创文章，转载请注明出处KidSea]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[谷歌创始人：谢尔盖·布林的故事，曝光角上的名字]]></title>
    <url>%2F2016%2F08%2F30%2F%E8%B0%B7%E6%AD%8C%E5%88%9B%E5%A7%8B%E4%BA%BA%EF%BC%9A%E8%B0%A2%E5%B0%94%E7%9B%96%C2%B7%E5%B8%83%E6%9E%97%E7%9A%84%E6%95%85%E4%BA%8B%EF%BC%8C%E6%9B%9D%E5%85%89%E8%A7%92%E4%B8%8A%E7%9A%84%E5%90%8D%E5%AD%97%2F</url>
    <content type="text"><![CDATA[前言 谷歌创始人：谢尔盖·布林的故事，曝光角上的名字 内容 二年级时，他随父母移民到美国。由于语言不通，再加上只对数学和计算机感兴趣，他在上其他课时总埋头琢磨数学题和计算机程序，常常被老师批评、罚站。可是他屡教不改，依旧把时间都用在研究数学和计算机上。渐渐地，老师对他绝望了，不想把太多时间浪费在无谓的批评上，专门在教室角落里架起了一个小黑板，取名为“曝光角”，每当发现有学生违纪就在上面记一次名字。结果几个月下来，上面反反复复出现了他的名字，几乎天天如此。 学校通知家长来参观，父母看到“曝光角”上只写了他的名字，还被写得很大很醒目，便狠狠地训斥道：“只有你的大名被写在小黑板上，听说天天都是如此，现在可好，几乎所有家长都知道你了……” 20年后，他与好友合伙开了家公司，专门提供搜索引擎服务。公司经营得风生水起，几年后他就跃升为美国400富豪榜中最年轻的富豪。 他正是美国企业家谢尔盖·布林，他创办的公司名叫谷歌。 有人问及布林的成功之道，他讲了上面的故事，然后说：“那是我受到的最严厉惩罚，也是我成长中最宝贵的一课。” 对方不明白这话的意思，布林便点开了谷歌页面：“我们网页上只有谷歌几个字母，再无其他，而且天天如此。” 他停了停，接着说：“就好比当年小黑板上只有我的名字，虽然它很醒目很刺眼，但无疑会让所有人一下子都记住它。” 用积极的心态去面对错误，或许它们就将转化为你成功的独特技巧和宝贵经验。 版权声明：本文为博主转载文章，转载请注明出处点这]]></content>
      <tags>
        <tag>文章</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java学习之路-4]]></title>
    <url>%2F2016%2F08%2F30%2Fjava%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-4%2F</url>
    <content type="text"><![CDATA[前言 java学习之路—–&gt;XML学习 内容 XML学习XML引入 HTML: 负责网页的结构CSS： 负责网页的样式（美观）Javascript： 负责在浏览器端与用户进行交互。 HTML与XML区别 HTML负责静态的网页制作的语言 HTML语言特点： 1）由标签组成。 &lt;title&gt; &lt;p&gt; &lt;hr/&gt; &lt;br/&gt; 2）语法结构松散的 &lt;p&gt;&lt;/p&gt; &lt;p&gt; &lt;P&gt; 大小写不区分 结束标签和开始标签不一定匹配 XML是HTML中的自定义标签 XML作用描述带关系的数据(软件配置文件)web服务器（PC）： 学生管理系统 -&gt; 添加学生功能 -&gt; 添加学生页面 -&gt; name=eric&amp;email=eric@qq.com 前提： 网络（IP地址： oracle：255.43.12.54 端口：1521 ） java代码：使用ip（255.43.12.54）地址和端口（1521），连接oracle数据 库，保存学生数据。 把ip地址端口配置到xml文件： host.xml &lt;host&gt; &lt;ip&gt;255.43.12.55&lt;/ip&gt; &lt;port&gt;1521&lt;/port&gt; &lt;/host&gt; 数据库服务器（PC）： 主服务器（255.43.12.54）：Oracle数据库软件（负载） 副服务器（255.43.12.55）：Oracle数据库软件 数据的载体(小型的”数据库”)教师管理系统： 姓名 工龄+1 邮箱 发教师数据给财务管理系统： String teacher = name=张三&amp;email=zhangsan@qq.com&amp;workag e=2 字符串 （问题： 1）不好解析 2）不是规范） teacher.xml &lt;teacher&gt; &lt;name&gt;张三&lt;/name&gt; &lt;email&gt;zhangsan@qq.com&lt;/email&gt; &lt;workage&gt;2&lt;/workage&gt; &lt;/teacher&gt; 这种一种规范 财务管理系统： 姓名 工龄+1 邮箱 发奖金： 统计奖金。 工龄 发邮件功能： 邮箱 姓名 金额 方案一： 在财务管理系统中维护了一套教师信息。 每年 ： 工龄增加 维护了两个系统的信息。 方案二： 教师信息只在教学管理系统中维护。 XML语法xml文件以xml后缀名结尾。xml文件需要使用xml解析器去解析。浏览器内置了xml解析器。 标签：语法： &lt;student&gt; 开始标签 student 标签内容 &lt;/student&gt; 结束标签 &lt;student /&gt;空标签 xml严格区分大小写 xml标签一定要正确配对 xml标签名中间不能加空格 xml标签名不能以数字开头 xml根标签只能有一个 属性：&lt;student name=&quot;eric&quot;&gt; student &lt;/student&gt; xml属性值一定要以引号包含，不能省略，也不能单双引号混用 一个标签内可以有多个属性，但是不能重复 注释：&lt;!-- xml注释 --&gt; 文档声明：&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; version 版本号默认1.0 encoding 解析xml文件时查询的码表（解码过程时查询的码表） 注意： 1）如果在ecplise工具中开发xml文件，保存xml文件时自动按照文档声明的enco ding来保存文件。 2）如果用记事本工具修改xml文件，注意保存xml文件按照文档声明的encoding的 码表来保存。 XML转义字符：在xml中内置了一些特殊字符，这些特殊字符不能直接被浏览器原样输出。 如果希望把这些特殊字符按照原样输出到浏览器，对这些特殊字符进行转义。 转义之后的字符就叫转义字节。 特殊字符 转义字符 &lt; &amp;lt; &gt; &amp;gt; &quot; &amp;quot; &amp; &amp;amp; 空格 &amp;nsbp; CDATA块：作用： 可以让一些需要进行包含特殊字符的内容统一进行原样输出。 &lt;![CDATA[ &lt;html&gt; &lt;/html&gt; ]]&gt; 处理指令：作用： 告诉xml解析如果解析xml文档 案例： &lt;?xml-stylesheet type=&quot;text/css&quot; href=&quot;1.css&quot;?&gt; 告诉xml解析该xml 文档引用了哪个css文件 需要提前xml内容可以使用xml-stylesheet指令指令 XML解析xml文件除了给开发者看，更多的情况使用程序读取xml文件的内容。这叫做xml解析 XML解析方式DOM解析 SAX解析 XML解析工具DOM解析： JAXP JDOM工具 Dom4J工具 三大框框使用 SAX解析： SAX解析工具(官方) 什么是DOM解析xml解析器一次性把整个xml文档加载进内存，然后在内存中构建一颗Document的 对象树，通过Document对象，得到树上的节点对象，通过节点对象访问(操作)到xml文 档的内容 DOM解析 Dom4J工具非官方，不在jdk 使用步骤： 1）导入dom4j的核心包。 dom4j-1.6.1.jar 2）编写Dom4j读取xml文件代码 Dom4J读取xml文件节点： iterator Element.nodeIterator;//获取当前标签节点下的所有子节点 标签： Element Document.getRootElement();//获取xml文档的根标签 Element ELement.element(&quot;标签名&quot;);//指定名称的第一个子标签 Iterator&lt;Element&gt; Element.elementIterator(&quot;标签名&quot;);// 指定名称的 所有子标签 List&lt;Element&gt; Element.elements(); //获取所有子标签 属性： String Element.attributeValue(&quot;属性名&quot;) //获取指定名称的属性值 Attribute Element.attribute(&quot;属性名&quot;)；//获取指定名称的属性对象 Attribute.getName() //获取属性名称 Attibute.getValue() //获取属性值 List&lt;Attribute&gt; Element.attributes(); //获取所有属性对象 Iterator&lt;Attribute&gt; Element.attibuteIterator(); //获取所有属 性对象 文本： Element.getText(); //获取当前标签的文本 Element.elementText(&quot;标签名&quot;) //获取当前标签的指定名称的子标签的文本 内容 Dom4J修改xml文件写出内容到xml文档 XMLWrite write = new XMLWriter(OutputStream,OutputForamt); write.write(Document); 修改xml文档的api 增加： DocumentHelper.createDocument() 增加文档 addElement(&quot;名称&quot;) 增加标签 addAttribute(&quot;名称&quot;,&quot;内容&quot;) 修改： Attribute.setValue(&quot;值&quot;) 修改属性值 Element.addAttribute(&quot;同名的属性名&quot;,&quot;值&quot;) 修改同名的属性值 Element.setText(&quot;内容&quot;) 修改文本内容 删除: Element.detach() 删除标签 Attribute.detach()删除属性 XML乱码问题 xPath技术引入 当dom4j查询比较深的层次结构的节点比较麻烦 作用 快速获取所需的节点对象 运用 1) 导入xPath支持包. 2) 使用方法 List&lt;Node&gt; selectNodes(&quot;xPath表达式&quot;); 查找多个节点 Node selectSingleNode(&quot;xPath表达式&quot;); 查找一个节点对象 xPath语法/ 绝对路径 表示从xml的根位置开始或者子元素(一个层次结构) // 相对路径 表示不分任何层次结构的选择元素 * 通配符 表示所有元素 [] 定域 表示选择什么条件下的元素 @ 属性 表示选取属性节点 SAX解析加载一点，读取一点，处理一点，对内存要求低。 SAX解析 SAX解析工具Sun公司提供，内置在Jdk中。 org.xml.sax 核心Api SaxParser类 用于读取和解析xml文件 parse(File?f, DefaultHandler?dh)放法，解析xml文件 参数一：File 表示读取的xml文件路径 参数二：DefaultHandler Sax事件处理程序，使用DefaultHandler的子类 例如： 1.创建SAXParser对象 SAXParser parser=SAXParserFactory.newInstance().newSAXParse r(); 2.调用parse方法 parser.parse(new File(&quot;./src/contact.xml&quot;), new MyDefaultHan dler()); [一个类继承class 类名（extends DefaultHandler） 在调用是创建传 进去 DefaultHandler类的APi void starDocument() 在读到文档开始时调用 void EndDocument() 在读到文档结束时调用 void startElement(String uri, String localName, String qName, At tributes attributes) ：读到开始标签时调用 void endElement(String uri, String localName, String qName) ：读到结束标签时调用 void characters(char[] ch, int start, int length) ： 读到文本内容 时调用 DOM解析与SAX解析区别DOM解析 原理： 一次性加载xml文档，不适合大容量的文件读取 DOM解析可以任意进行增删改成 DOM解析任意读取任何位置的数据，甚至往回读 DOM解析面向对象的编程方法（Node，Element，Attribute）,Java开发者编码比较简 单。 SAX解析 原理： 加载一点，读取一点，处理一点。适合大容量文件的读取 SAX解析只能读取 SAX解析只能从上往下，按顺序读取，不能往回读 SAX解析基于事件的编程方法。java开发编码相对复杂。 XML约束只要能看懂约束内容，根据约束内容写出符合规则的xml文件 引入xml语法：规范的xml文件的基本编写规则.(由w3c组织规定的) xml约束：规范xml文件数据内容格式的编写规则.(开发者自己定义) XML约束技术DTD约束:语法简单，功能简单 Schema约束:语法复杂，功能相对强大(名称空间) DTD约束1)导入方式 内部导入 &lt;!DOCTYPE note [ &lt;!ELEMENT note (to,from,heading,body)&gt; &lt;!ELEMENT to (#PCDATA)&gt; &lt;!ELEMENT from (#PCDATA)&gt; &lt;!ELEMENT heading (#PCDATA)&gt; &lt;!ELEMENT body (#PCDATA)&gt; ]&gt; 外部导入 本地系统导入 &lt;!DOCTYPE note SYSTEM &quot;note.dtd&quot;&gt; 公共的外部导入 &lt;!DOCTYPE 根元素 PUBLIC &quot;网络地址.dtd&quot;&gt; 2)DTD语法 约束标签 &lt;!ELEMENT 元素名称 类别&gt; 或 &lt;!ELEMENT 元素名称 (元素内容)&gt; 类别： EMPTY 空标签 表示元素一定是空 #PCDATA 普通字符串 表示元素的内容一定是普通字符串(不能含有子标 签) ANY 任何类型 表示元素的内容是可以任意内容(包括子标签) 元素内容： 顺序问题 &lt;!ELEMENT 元素名称 (子元素名称 1,子元素名称 2,.....)&gt;： 按顺序出现子标签 次数问题： 标签 ： 必须且只出现1次。 标签+ ： 至少出现1次 标签* ： 0或n次。 标签？ ： 0 或1次。 约束属性 &lt;!ATTLIST 元素名称 属性名称 属性类型 默认值&gt; 默认值： #REQUIRED 属性值是必需的 #IMPLIED 属性不是必需的 #FIXED value 属性不是必须的，但属性值是固定的 属性类型：控制属性值的 CDATA ：表示普通字符串 (en1|en2|..)： 表示一定是任选其中的一个值 ID：表示在一个xml文档中该属性值必须唯一。值不能以数字开头 Schema约束名称空间：告诉xml文档的哪个元素被哪个schema文档约束。 在一个xml文档中，不同 的标签可以受到不同的schema文档的约束。 1）一个名称空间受到schema文档约束的情况 2）多个名称空间受到多个schema文档约束的情况 3）默认名称空间的情况 4）没有名称空间的情况 Schema约束 版权声明：本文为博主原创文章，转载请注明出处KidSea]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java学习之路-3]]></title>
    <url>%2F2016%2F08%2F28%2Fjava%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-3%2F</url>
    <content type="text"><![CDATA[前言 java学习之路—–&gt;Javaspcrit 内容 JavaScriphtml负责一个页面的结构css 负责一个页面的数据的风格和样式javascrip负责与用户交互 javascript的历史微软 盖茨认为未来是&quot;视窗&quot;的世界。 网景： 1995年退出了一款浏览器（导航者）和liveScript(校验功能)， 非常受欢 迎。 和sun公司合作，借用了java的名字，把liveScirpt改名成javascript。 70%市场 份额。 盖茨知错了,盖茨找网景的老大判断， 不同意 （领航者)。 盖茨一年投资20亿美元去开发JScript. 微软 :捆绑销售+免费。 45美元。 1998年被美国在线的公司收购， 03年的时候网景宣布破产。 同意赔钱7亿美元 拿出2千万美金成立了一个基金会（Mozilla ）谋智+ 把浏览器的 源代码全部开工。 协议1997年欧洲的计算机协议（ECMA）组织出来给javascript规定协议。 1. ECMAScirpt(规范了基本的语法而已) 2. BOM （浏览器对象模型） 3. DOM (文档对象模型) javascript的特点：1. 跨平台 2. 安全性。 （javascript的代码不能直接访问硬盘的内容） javascript与java之间区别 ：1. javascript是属于网景公司产品， java是sun公司的产品。 2. javascript是基于对象的语言，java是面向对象的语言。 3. javascript是解释型语言，java是解释、编译型语言。 4. javascript是弱类型语言， java 是强类型语言。 5. java中声明变量 的时候必须要明确该变量的数据类型。 6. javascript声明变量不需要明确是何种数据类型， 任何的变量都是使用一个关键字 var去声明即可。 如何编写javascript的代码。方法1：可以使用&lt;script&gt;标签体进行编写； &lt;script type=&quot;test/javascript&quot;&gt; js代码块； alert(&quot;哈哈&quot;);//弹出框 document.write(&quot;数据&quot;);//向页面输出数据 &lt;/script&gt; 方法2： 可以引入javascript代码 &lt;script src=&quot;name.js&quot; type=&quot;test/javascript&quot;&gt; &lt;/script&gt; 注意： 1.&lt;script&gt;是有开始标签与结束标签的，千万不要在一个标签中结束了。 2.如果&lt;script&gt;已经用于引入了js文件，那么该&lt;script&gt;标签体就不能再写 js代码了， 网页的注释：html &lt;!--注释的内容--&gt; css注释 /*注释的内容*/ javascript: //单行 /*多行*/ 变量的声明：格式： var 变量名 = 数据; var a = 10; document.write(&quot;a=&quot;+a+&quot;&lt;br/&gt;&quot;); var b = &quot;狗娃&quot;; document.write(&quot;b=&quot;+b+&quot;&lt;br/&gt;&quot;); var c = 3.14; document.write(&quot;c=&quot;+c+&quot;&lt;br/&gt;&quot;); 注意: 1. 变量可以存储任何类型 2. 类型根据数据类型决定 3. 没有重复变量说法，只有定义顺序 4. 使用typeof来检测数据类型 数据类型： number 小数跟整数 string 字符跟字符串 boolean 布尔类型 undefined 未被定义类型 类型转换： 字符串转数字 parseInt() 整数 parseFloat() 浮点数 IsNaN方法 判断该字符串是不是一个数字 运算符+(加法、正数、连接符) true 是1 false 是0 /(除法) 两个整数不能整除时候结果为浮点数。 比较运算符 &gt; 大于号 10&gt;3 true &quot;10&quot;&gt;&quot;3&quot; false &quot;19&quot;&gt;&quot;18888&quot; true 10&gt;&quot;9&quot; true 数字与字符串比较时，会先把字符串转换成数字再进行比较 &lt; 小于号 逻辑运算符 &amp;&amp; 逻辑与 没有单与 || 逻辑或 ！ 非 三目运算符 表达式?执行体1:执行体2 控制流程语句if语句 if(condition){ 执行体 } if语句的特殊处 1.类似C语言，与JAVA有些区别 2.String不能空是true 空为false 3.undefined false 4.NaN false switch用法与其他类似 特殊之处 case后可以跟常量与变量，还可以跟表达式 循环语句 for 格式： for(初始化语句;判断条件;循环后的语句){ 执行体; } for-in 格式： for(var 变量名 in 遍历的目标){ 执行体； } 1. 可以遍历数据的元素 var arr = {12,13,19,15,16}; for (var index in arr){ document.write(arr[index]+&quot;,&quot;); } 2. 可以用以遍历对象的所以属性 while 格式： while(判断条件){ 执行体； } do while 格式： do { 执行体； }while(判断条件)； with 说明：有了With语句，在存取对象属性和调用方法时就不用重复指定对象 格式: with(对象){ 可直接调用对象方法或属性; } 函数格式： function 函数名(形参列表){ 函数体; } 注意细节: 1.在Js的函数定义时，形参不能加var声明 2.在Js函数中，没有返回值类型，但可以有返回值，也可以没有，不用声明 3.在Js的函数中，没有函数重载 4.在Js的函数中，任何一个函数内部都隐式的维护了一个arguments的对象，给函 数传递数据的时候，会先给arguements的数组里，然后再分配给形参 字符串对象方式1： new String(&quot;内容&quot;); 方式2： var str = &quot;内容&quot;; 常用方法 anchor() 生产锚点 &quot;&quot;.anchor(&quot;&quot;); blink() 为元素添加blink标签 charAt() 返回指定索引位置处的字符 charCodeAt() 返回索引值对应的码值 fontcolor() 给字符串加上颜色 indexof() 返回指定字符串第一次出现的索引值 italics() 把字符串变为斜体 link() 给字符串添加超链接 replace() 替换字符串内容 split() 切割字符串 substr() 截取字符串 toUpperCase()转大写 toLowerCase()转小写 Date对象getYear() 获取当前年份与1900年份相差年份 getFullYear() 获取当前准确年份 getMonth()获取月份 getDate()获取日 getHours()获得时间 getMinutes()获得分钟 getSeconds()获得秒 toLocaleString()获取一定格式的日期，不能修改 Number对象方式1： var 变量 = new Number(数字); 方式2： var 变量 = 数字; 常用方法 toString() 将数字转换成字符串 toFixed() 指定保留小数位，还带有四舍五入 Math对象常用方法 ceil() 向上取整 floor() 向下取整 random() 随机数方法 round() 四舍五入 Array数组对象 方式1： var 变量名 = new Array(); 方式2： var 变量名 = new Array(个数); 创建一个指定数组长度的数组 方式3： var 变量名 = new Array(元素1,元素2,...); 方式4: var 变量名 = [&quot;&quot;]; 注意细节： 1.数组长度可以变化 常用方法 concat() 连接数组 join() 使用指定的分割符，把数组中的元素拼装成一个字符串返回 pop() 移除数组中的最后一个元素并返回 push() 将新元素加入数组，并返回最新长度 reverse() 反转数组的元素 shift() 移除第一个元素，并返回 slice() 截取数组的一段内容 sort() 排序方法,但是需要写排序方法 splice() 移除一个或多个元素，必要时还可以插入元素 自定义对象在Js中没有类的概念，只要有函数即可创建对象 方式1：使用无参函数创建对象 function Person(){ } var p = new Person(); p.id = 110; 方式2：使用带参的函数创建对象 function Person(id,name){ this.id = id; this.name = name; this.say = function(){ alert(name + &quot;呵呵&quot;); } } var p = new Person(); 方式3: 使用Object函数来创建对象 function Object(){ } var p = new Object(); p.id = 100; p.name = &quot;铁蛋&quot;; 方式4：使用字面量的方式创建 var p = { id:110, name:&quot;狗娃&quot;, say:function{ alert(this.name + &quot;呵呵&quot;); } } prototype1.prototype是函数的一个必备属性 2.prototype的值是一个对象 3.可以任意修改函数的prototype属性的值 4.一个对象会自动用有这个对象的构造函数的prototpye的成员属性和方法 Array.prototype.getMax = function(){ var max = this[0]; for(var index = 1; index&lt;this.length ; index++){ if(this[index]&gt;max){ max = this[index]; } } return max; } Array.prototype.searchEle = function(target){ for(var i = 0 ; i&lt;this.length ; i++){ if(target==this[i]){ return i; } } return -1; } //var arr = new Array(12,4,17,9); var arr = [12,4,17,9]; var max = arr.getMax(); var index = arr.searchEle(9); document.write(&quot;最大值：&quot;+ max+&quot;&lt;br/&gt;&quot;); document.write(&quot;索引值：&quot;+ index+&quot;&lt;br/&gt;&quot;); Bom编程 浏览器对象模型: 浏览器对象模型中把浏览器的各个部分都用一个对象来描述， 如果想要操作浏览器的一些属性，我们就可以通过浏览器对象模型的对象来操作 window 代表了新开一个窗口 常用方法： open() 打开新窗口并装入给定的URL的文档 resizeBy 改变窗口当前的位置，指定X与Y resizeTo 将窗口的大小更改为指定的宽度和高度值 moveBy() 相对于原来的窗口移动指定的值 moveTo() 相对于整个屏幕移动 setInterval() 每经过指定的时间就可以执行指定的代码，单位ms clearInterval() 取消定时任务 setTimeout() 经过指定的时间后，执行一次指定代码，单位ms 注意细节： window的一些方法调用可以省略window的对象 事件 注册事件的方式: 方式1：直接在html元素上注册 &lt;body onload=&quot;ready()&quot;&gt; function ready)(){ 代码体; } 方式2：可以在js代码找到对应的对象再注册 推荐 var bodyNode = document.getElementById(&quot;body&quot;); bodyNode.onload = function{ } 常用的事件: 鼠标点击相关： onclick 在用户用鼠标左键单击对象时触发。 ondblclick 当用户双击对象时触发。 onmousedown 当用户用任何鼠标按钮单击对象时触发。 onmouseup 当用户在鼠标位于对象之上时释放鼠标按钮时触发。 鼠标移动相关： onmouseout 当用户将鼠标指针移出对象边界时触发。 onmousemove 当用户将鼠标划过对象时触发。 焦点相关的： onblur 在对象失去输入焦点时触发。 onfocus 当对象获得焦点时触发。 其他： onchange 当对象或选中区的内容改变时触发。 onload 在浏览器完成对象的装载后立即触发。 onsubmit 当表单将要被提交时触发。 Location 代表了地址栏对象 href 设置以及获取地址栏的对象 reload() 刷新当前页面 Screen 代表了整个屏幕对象 availHeight 获取系统屏幕的工作区域高度 availWidth 获取屏幕的工作区域宽度 height 获取屏幕的垂直分辨率 width 获取屏幕的水平分辨率 Dom编程 文档对象模型：一个html页面被浏览器加载的时候，浏览器就会对整个html页面上 的所有变迁都会创建一个对应的对象进行描述， 我们在浏览器上看到的信息只不过就是这些html对象的属性信息而已。 我们只要能找到对应的对象操作对象的属性，则可以改变浏览器的当前显示内容。 document.all 获取html文件中的所有标签节点 document.links 获取文档中所有含有href属性的标签 通过html因素的标签属性找节点 document.getElementById(&quot;html元素的id&quot;) document.getElementsByTagName(&quot;标签名&quot;) document.getElementsByName(&quot;html元素的name&quot;) 通过关系(父子关系、兄弟关系)找标签。 parentNode 获取当前元素的父节点。 childNodes 获取当前元素的所有下一级子元素。 firstChild 获取当前节点的第一个子节点。 lastChild 获取当前节点的最后一个子节点。 ------------------------------------------------------------ nextSibling 获取当前节点的下一个节点。（兄节点） previousSibling 获取当前节点的上一个节点。（弟节点） 注意细节: InnerHTml是用来设置标签题的内容，value死用以设置标签的value属性值 获取子节点的时候包括空文本和注释文本，可以通过便标签的类型判断筛选 文本类型： 3 注释类型: 8 标签节点类型: 1 创建、插入节点 document.createElement(&quot;标签名&quot;) 创建新元素节点 elt.setAttribute(&quot;属性名&quot;, &quot;属性值&quot;) 设置属性 elt.appendChild(e) 添加元素到elt中最后的位置 elt.insertBefore(newNode,oldNode); 在child之前 elt必须是oldNode的直接父节点 elt.removeChild(eChild) 删除指定节点 elt必须是child的直接父节点 正则表达式方式1: /正则表达式/模式 var str = &quot;hello1123&quot; var reg = /^[a-z0-9]+/; 方式2: new RegExp(&quot;正则表达式&quot;,模式); 常用的两个方法 test方法 匹配，使用正则对象去匹配字符串，成功则返回true，否则false exec方法 查找，根据正则表达式查找字符串符合规则的内容 模式 g 全文查找 i 忽略大小写 版权声明：本文为博主原创文章，转载请注明出处KidSea]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如光]]></title>
    <url>%2F2016%2F08%2F28%2F%E5%A6%82%E5%85%89%2F</url>
    <content type="text"><![CDATA[前言 这场雨一直下，从我生命的这头一直下到那头。这座城叫雨城。 内容 这场雨一直下，从我生命的这头一直下到那头。这座城叫雨城。 我正撑着伞，一个人走在市中心的天桥上。周围的高楼把我围绕，色调干燥的霓虹和海报从四面八方而来，把这个城市包装出浮华的样子。我厌弃繁华，在你离开以后，所有的繁华都只是一具空虚的框架。没有你在身边，我面对繁华总是要失魂刹那。 于是我压低伞沿，在这灰色的雨中行走，在这穿越我生命的大雨中行走，在这陌生的人潮中行走。忽然我听到有人喊你名字，迟钝的我迅速转身，却只看到身后密密麻麻的、灰色的行人。 一切都是灰色的，在这场不会停止的大雨里，世界被雨水染成灰色，生命被雨水染成灰色。我回身找不到你，因为所有东西，自你离开的那刻都被带走了颜色。 这时，表情冷淡的行人与我擦肩而过，碰撞让我身上落满雨渍。我的世界也从此刻开始带上了色彩，我定是想起初遇你时的情景了。在那时灰色的大雨里，我一个人撑着伞在市中心的天桥上行走。来往的行人面无表情，却只有你，一脸纯真的鲜明。从那时起，我的世界开始充满明丽的色彩。你为我的世界染上色彩，却轻轻一笑，转身，再次隐入陌生的人群。留我神色恍惚，呆呆地站在人潮中，欣赏这个初具色彩的世界，还有回忆，回忆刚刚那个如光一般照亮我生命的女孩。 但我清楚，你不会再回到雨城。 雨声磨去了所有杂音，人们的表情也像我面对世界的态度一般冷漠而木然。但你则不然，你焕发出微光与这个没落的世界格格不入。 你总是如光一般，轻一笑，转身为我的世界染上色彩，但除了最后一次。那是世界仍具有色彩的最后一个傍晚，黄昏濡湿你温柔的眼角，你低声说你实在不能忍受雨城的雨了。但我低着头，同样低声地说我害怕雨城外面的世界。你一定早就料到，在那个连暮霭都湿润的黄昏，仍坚持如光一般，对我挤出一个最后，也是最苦涩的微笑，再含泪低头倒退，转身。你转身，把我遗落在雨城的阴影里，却带走了我整个世界的色彩。你的背影越来越小，我的晚霞也涨满灰色。 雨是灰色的，墙是灰色的，整个世界都是灰色的，自你离开我以后。我也知道你不会再回来，却一直期待，那个如光一般的女孩能再次出现。一看到你，就像看见晴天。 版权声明：本文为博主转载文章，转载请注明出处点这]]></content>
      <tags>
        <tag>文章</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[物联网将引发照明的下一场革命]]></title>
    <url>%2F2016%2F08%2F27%2F%E7%89%A9%E8%81%94%E7%BD%91%E5%B0%86%E5%BC%95%E5%8F%91%E7%85%A7%E6%98%8E%E7%9A%84%E4%B8%8B%E4%B8%80%E5%9C%BA%E9%9D%A9%E5%91%BD%2F</url>
    <content type="text"><![CDATA[前言 物联网将引发照明的下一场革命 内容 路灯给夜晚出行的人们带来了光明，为现代人们快节奏的生活方式提供了方便。对于路灯，现代的人们早已司空见惯，而在15世纪以前，它却是一件稀罕物。人类尝试在城市街道上进行人工照明，最早要追溯到15世纪初。1417年，当时的伦敦市长为了让冬日漆黑的街道明亮起来，要求在室外悬挂灯具照明，这就是路灯的起源。1843年，上海街头出现了中国第一盏路灯，尽管它是煤油点燃的，却吸引了黄浦江边众多人群的目光。直到1879年，上海的码头才亮起了中国第一盏电灯。 路灯控制技术发展缓慢如今，路灯已经遍布全球各个城市的大街小巷。根据国际气候组织（The Climate Group）统计，全球路灯的保有量已经上升到3.04亿盏，并将在2025年达到3.52亿盏。路灯的数量不断增长，照明技术也在不断革新，而路灯的控制技术却发展缓慢。 最初的马路电灯在每根电线杆上都装有闸刀开关，需要工人每天手动开启和关闭，后来若干路灯开始合用一个开关。这种通过开关控制的路灯形式在全国各城市中一直沿用到20世纪50年代。 直到今天，大部分的城市路灯仍然无法实现智能化控制。目前使用较多的分散时控方式，多采用在路灯配电箱中安装定时器，按预定时间自行开/关灯。这种控制模式的缺陷在于无法灵活调整开/关灯时间，更无法反映照明设施的运行情况，并且故障率高，维修困难。随着城市的不断发展，控制范围越来越大，在现行的控制模式下，会使得维修工作十分被动。运行过程中的故障只有等待巡视人员到达现场才能发现，或者被动等待市民电话反映，难以做到及时维修。 能耗高、巡检慢、管理难是横在市政照明领域的3只“拦路虎”。 “灯联网”：驱散市政照明的“拦路虎”如今，物联网技术飞速发展，数以亿计的各种终端正加速接入网络，我们即将迎来万物互联的新世界。当一个物体被接入网络，将迸发出巨大的潜能。把汽车接入网络，无人驾驶技术就应运而生，一举改变了几百年来的驾驶习惯；如果将路灯接入网络，将会带来哪些改变？华为照明物联网解决方案已经给出了答案。 该方案为每盏路灯安装了内置无线通信模块的照明控制器，赋予了路灯联接的“翅膀”，让路灯之间实现快速自组网，再辅以物联网关节点，将城市中数量庞大的路灯联成了一张巨大的“灯联网”。照明控制器实时采集路灯的各种运行参数并上送到云端；基于GIS地图的可视化管理系统可以清楚获知每一个街区、每一盏路灯的运行状态，实现路灯的在线巡检；通过应用照明策略，能够精准控制每一盏路灯的开/关状态和照明亮度，真正实现按需照明，节能效率高达80%。照明物联网方案将市政照明领域的3只“拦路虎”一举驱散。 照明物联网方案的“驱虎”之术究竟有哪些精妙之处？ “高智商”节能：精确计算+智能感知对路灯的智能控制上，方案提供组合照明控制策略。首先，可以基于经纬度计算路灯所在地区的日出和日落时间，科学地设定照明时长；根据一年四季的变化规律，针对不同季节和不同月份之间照明时长的差异，动态调整照明计划；在每一天的照明时间段内，照明计划可以分时精细化编排；其次，对路灯的控制可以与亮度传感器、车流量和人流量传感器等进行联动。比如在深夜时段、在车流稀少的路段可以调低路灯亮度或者间隔开灯；而在光照条件不好的阴雨天气则根据对环境的感知及时开灯等。 高效管理：可视化在线巡检+前瞻性维护对路灯的管理上，采用了基于GIS地图的可视化管理方式，城市中不同街区的路灯数量、路灯运行状态、安装位置和安装时间等信息一目了然。当路灯发生故障时，系统会自动告警，并发送信息通知维修人员及时前往事故地点检修。除此之外，管理系统还可以对路灯进行生命周期管理，了解路灯的运行时长和历史故障记录，提前预知可能发生的故障，实现前瞻性维护。 多级控制：本地控制+云端控制在传统的群控模式下，因为施工等原因造成控制网络中断时，经常导致多台路灯脱管。路灯不是在白天与日争辉，就是连续很多天漆黑一片。多级智能控制是该方案的最大特色，包括两级本地智能控制和一级云端智能控制。敏捷物联网关和路灯控制器均支持照明策略的本地化部署。当敏捷网关的上行网络故障时，可快速切换到本地控制策略；而当传感网络故障时，路灯控制器则可以工作于离线模式。多级智能控制机制最大程度强化了对路灯的可控性，防止路灯脱离控制的状况发生。 智能照明开拓更广阔的物联网空间照明物联网方案采用全层次开放架构，从底层芯片到上层应用均提供开放接口。底层控制芯片可基于华为开源物联网操作系统LiteOS进行开发；敏捷网关支持虚拟化架构，合作伙伴可以开发和安装定制化应用；敏捷控制器则对第三方应用系统提供标准北向接口，便于扩充各种服务组件。 随着智慧城市建设的推进，路灯将不再只是灯杆加灯头，而将成为智慧城市的重要“据点”。在照明物联网的基础上可以增加更丰富的传感设施，将环境监测、交通监测、智能充电桩和智能垃圾桶等各种对象都纳入到感知网络中，为智慧城市提供基础的数据支撑，扩展更多智慧化服务。 小路灯撬动大市场，照明物联网化潮流已经到来。从业内厂商纷纷开始布局这一领域的动向也可以看出，照明物联网化是大势所趋。若能将城市路灯全部互联，发挥智能照明的作用，定会开拓更为广阔的物联网空间。 版权声明：本文为博主转载文章，转载请注明出处华为]]></content>
      <tags>
        <tag>Iot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java学习之路-2]]></title>
    <url>%2F2016%2F08%2F27%2Fjava%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-2%2F</url>
    <content type="text"><![CDATA[前言 java学习之路—–&gt;Html+Css 内容 1. HTML1.1 语言结构&lt;html&gt; 根标签 &lt;head&gt;&lt;/head&gt;网页的头信息 &lt;body&gt;&lt;/body&gt;网页的体信息 &lt;/html&gt; 1.2 注释&lt;!-- 注释的内容 --&gt; 1.3 头信息的作用1&gt; 可以设置网页的标题 2&gt; 可以 1.4 html常用标签1&gt; 标签作用：用于描述一个网页的结构 2&gt; 需要操作数据时，需要添加标签 3&gt; 标签 &lt;h1&gt;--&lt;h6&gt;描述标题 &lt;p&gt;&lt;/p&gt;表示段落 &lt;hr/&gt;水平线 &lt;sub&gt;&lt;/sub&gt;下标标签 &lt;br/&gt;换行 &lt;sup&gt;&lt;/sup&gt;上标 &lt;pre&gt;&lt;/pre&gt;原样标签 &lt;ol&gt; &lt;li&gt;&lt;/li&gt;有序列表标签 &lt;ul&gt;&lt;/ul&gt;无序列表 &lt;/ol&gt; &lt;dl&gt; &lt;dt&gt;&lt;/dt&gt;无缩进 &lt;dd&gt;&lt;/dd&gt;有缩进 &lt;/dl&gt; &lt;span&gt;&lt;/span&gt;行内标签 &lt;div&gt;&lt;/div&gt;块标签 标签内容独立占一行 1.5 实体标签&amp;nbsp 空格 &amp;lt; 小于号 &amp;gt; 大于号 &amp;amp; 与号 &amp;yen; 人民币 &amp;copy; 版权 &amp;reg; 商标 1.6 媒体标签&lt;embed src=&quot;&quot;&gt;&lt;/emned&gt; src表示路径 &lt;marquee&gt;弹幕&lt;/marquee&gt; &lt;embed src=&quot;纯音乐 - 偏偏喜欢你.mp3&quot;&gt;&lt;/embed&gt; &lt;marquee direction=&quot;right&quot; scrollamount=&quot;30&quot;&gt; &lt;font color=&quot;#CC0000&quot; size=&quot;+5&quot;&gt;弹幕&lt;/font&gt; &lt;/marquee&gt; 1.7 超链接标签&lt;a&gt;&lt;/a&gt; href = &quot;链接&quot; target：设置打开新资源的目标 Blank 在独立的窗口上打开资源 _self 在当前窗口下打开 file 是用在查找本地的网页 使用http协议,会在本地机器去找一个hosts文件，如果再此文件没有该域名的主机，则 去NDS上找到该域名的主机号,不是http或者file协议的，会去查找本地是否有适合这个 协议的应用，如果有则处理。 邮件协议：mailTo 迅雷协议：thunder 锚点定位： 1.首先写一个锚点 &lt;a name=&quot;锚点名字&quot;&gt;数据&lt;/a&gt; 2.使用a标签的herf属性链接到锚点处: href=&quot;#锚点名 1.8 图片标签&lt;img src=&quot;&quot;/&gt; width设置宽度 height高度 alt图片加载不了时，进行提醒 1.9 表格标签&lt;table&gt;&lt;/table&gt; &lt;tr&gt;表示行 &lt;td&gt;单元格 &lt;th&gt;表头 默认剧中加粗 &lt;caption&gt; 表的标题 border表格的边框 bordercolor表格边框颜色 width表格宽度 height表格高度 align位置 colspan表示单元格占据几个列 rowspan表示占据的行数 &lt;thead&gt;&lt;/thead&gt; &lt;tbody&gt;&lt;/tbody&gt; &lt;tfoot&gt;&lt;/tfoot&gt; 1.10 框架标签frameSet: 一个frameset可以切割成多块 &lt;frameset&gt;&lt;/frameset&gt; frame不可以被分割，位于frameset中 1.11 表单标签&lt;form&gt; &lt;/form&gt; action 指定提交数据的地址 method 指定有表单提交方式 get提交方式 默认 提交内容会显示在地址栏 不超过1KB 不安全 post提交方式 不会显示 数据不受限制 安全 注意:表单提交，需要加上name属性 2. CSS html负责一个页面的结构 css 负责一个页面的数据的风格和样式 2.1 编写CSS代码的方式1.在style标签中编写css代码 &lt;style type=&quot;text\css&quot;&gt; a{ color:#366; text-decoration:none; } &lt;/style&gt; 2.引入css文件 ⑴建立.css文件 推荐使用 使用&lt;link href=&quot;.css&quot; rel=&quot;stylesheet&quot;/&gt; ⑵用style引入 &lt;style type=&quot;text\css&quot;&gt; @import url(&quot;1.css&quot;); &lt;/style&gt; 3.直接在html中引用 style内容里编写 用分号隔开 2.2 css注释/* */ 2.3 选择器标签选择器 标签名{ 样式1；样式2..... } div{ color:#f00: font-size:20px; } 类选择器 .class的属性值{ 样式1；样式2.... } class名不能以数字开头 类选择器的样式要优先于标签选择器的样式 id选择器 #one{ background-color:#ff9; } id选择器的优先值最高 id也不能以数字开头命名 id属性值在一个html页面中只能出现一次 交集选择器 选择器1 选择器2{ 样式1，样式2.... } 并集选择器:对制定的选择器进行统一的样式化 格式： 选择器1 选择器2 ..{ 样式1;样式2.... } 通过选择器 *{ 样式1;样式2... } 伪类选择器:对元素处于某种状态的进行的样式的 link 没有被点击过 visited 已经被访问过的样式 hover 鼠标经过的状态 active 点击未释放 2.4 常用CSS样式背景属性： background 背景颜色样式 background-image 背景图片 background-repeat 可以设置图片是否可以重复 background-position 位置设置 第一个参数是水平 第二个是垂直 文本属性： color 设置文本颜色 direction 没什么用 font-size 字体大小 font-height 行高 letter-space 字符跟字符间的间距 text-align 元素的对齐方式 text-decoration 文本样式 text-transform 转换字符 表格属性： border-collapse:collapse 合并边框 border-spaceing empty-cells 要不要显示空单元格 table-layout 控制单元格的样式 边框属性：默认无边框 border-style 边框样式 border-color 边框颜色 2.5 盒子模型把html边框比作成了一个盒子的边框，盒子模型要做用于操作数据与边框之间的距离或 者是边框与边框之间的距离. 盒子模型主要是用于操作内边框与外边框. 2.6 定位相对定位： 是相对于元素原来的位置来移动 利用position:relative属性 绝对定位： 绝对定位是相对于整个页面而言 固定定位： 相对于整个浏览器而言的位置 版权声明：本文为博主原创文章，转载请注明出处KidSea]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[遵循内心，做你所想]]></title>
    <url>%2F2016%2F08%2F27%2F%E9%81%B5%E5%BE%AA%E5%86%85%E5%BF%83%EF%BC%8C%E5%81%9A%E4%BD%A0%E6%89%80%E6%83%B3%2F</url>
    <content type="text"><![CDATA[前言 今年年初的时候，我正陷入某种人生困境中。 内容 今年年初的时候，我正陷入某种人生困境中。 现在看来，这个困境根本不算什么，无非是要不要辞职，回家把书写完，然后考试申请出国。虽说我对职场没有任何眷恋，也没人指望着我出去赚钱养家，但是，辞职这件事情还是让我觉得痛苦。我担心，离开正常的工作就会陷入拖延症，脱离正常的人际交往的日子。再说，万一书写不出来怎么办？万一成绩考不出来怎么办？…… 我独自纠结了一段时间，去找朋友聊了一下。她说了“反正你的工作对于人类社会也没什么贡献”“辞职以后就可以一起学习一起游泳”之类的话，就更加坚定我要辞职的信念，可真写起辞职信的时候，还是有些担心。 那天，我在办公室里写辞职信，来回纠结修辞问题，瞪着电脑看了半个小时啥也写不出来，就跑到对面去买咖啡。天气好冷，我抱着超级难喝的热咖啡站在路口等绿灯，突然想，为什么要犹豫？你恐惧辞职后写书、考试会失败，但是，你怎么知道上班就能成功呢？如果你考试都考不出来，这个智商，就以为自己真能成为职场小能手啦？你以为往前走是失败，但是安于现状就不失败了？就完全保险了？就能成功？就能成为人生赢家啦？反正都不见得有多好，倒不如做点让自己高兴的事情呢。 当我意识到这一点的时候，果断地回去，痛痛快快地把辞职信写完。然后，去图书大厦买了几本参考书，开始我的备考和自由职业的路途。几个月过去了，半年过去了，甚至今年也马上要结束了。我的生活没有变得一团糟，相反，事情正在顺利地进行着。该弄的事情弄完了，该学的东西也学完了，该克服的困难也克服了，新书也写完了。很好，我竟然没有毁掉自己的人生。 在多年的人生经历里，你，或者我，多多少少已经看清这个世界的冷酷面目。世界不温柔，人们经常不快乐，森林里也没有数不清的糖果屋。生活不是小说，不努力绝对不会有回报，但努力也不意味着成功，相反，你有可能一次又一次地迎来痛击……无论你后退还是前进，人生总会不尽如人意。比如说，明明渴望去大城市看看的年轻人，却担心失败而留在家乡随便找份工作生活，最终被无聊感和不甘心所缠绕终日；明明想做某件事情，却听了一堆“朋友说”而放弃内心的渴望。 在这座城市里，每天都有许多人在自我质疑与他人质疑中困惑着——年轻的作家挣扎多年，写出作品后却连续遭出版社退稿；职场新人每日写的PPT被客户骂得一无是处；当初那颗兴奋而怀揣梦想的心，已经在现实的打磨中变得日益暗沉。这时候，是选择后退，还是选择向前一步？ 乔布斯告诉我们，一定要遵循内心。问题是，普通人到底应该怎么做选择呢？普通人遵循自己的内心，就一定会成功吗？ 当然不是，遵循内心仅仅是一个开始。乔布斯不做苹果也可能做出其他震惊世人的产品，这个就是现实情况。可是，你以为往后退就会安全，会成功吗？不会的，生活的麻烦总会找上你。反正左右都有可能失败，倒不如去做自己想做的事情好了，至少，痛快了。往好的方面想想，往前走，搞不好能探索出新的可能性，即使没有，也没有关系啊，反正原来的人生也不见得会很好，成功了就很让人高兴，失败了也没有太大的损失。 大部分尝试都会失败，恰恰如此，内心的信念才显得如此之珍贵，自暴自弃是容易的，看清世界的冷酷仍然选择往前走，仍然按照自己的意愿去生活，则是艰难的。一颗不畏惧不服从的内心，它让生命有其他的可能性，它是无边无际的黑夜中微弱而明亮的星辰。 对于芸芸众生来说，遵循内心的声音，去做你想做的事情，同样也是一种相对理性的选择。 版权声明：本文为博主转载文章，转载请注明出处点这]]></content>
      <tags>
        <tag>文章</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[它会记着你的好]]></title>
    <url>%2F2016%2F08%2F26%2F%E6%96%87%E6%91%98%E6%AC%A3%E8%B5%8F-1%2F</url>
    <content type="text"><![CDATA[前言 动物是这样，你把它当人看，你对它好，它会记着你的好；人更是这样，人是世界上最高等的动物，你对他的好，他会点滴记心中，会“滴水之恩，涌泉相报”。 内容 动物是这样，你把它当人看，你对它好，它会记着你的好；人更是这样，人是世界上最高等的动物，你对他的好，他会点滴记心中，会“滴水之恩，涌泉相报”。 以前在好莱坞电影里出现的猛兽，如狮子、老虎，大多是用鞭打、电击等很残酷的方法训练的。海夫尔当驯兽师后，他认为动物也是有感情的，他提出驯兽应该用“慈善诱导法”，他便放弃了残酷的训练方法。可很多人不以为然，觉得野兽就是野兽，人只能用暴力来制服它们，并且大家准备看他的笑话，甚至认为他终有一天会被动物吃掉。但他仍然采取温柔的办法待动物，渐渐地培养起了与动物们的感情。 有一天，海夫尔要外出演出，他开着拖车，带着他几年来用慈善诱导法精心训练的狮子泰米去片场拍戏。没想到，在高速公路上出了车祸，铁笼散架了，狮子泰米受伤了，头上和身上都是血，眼睛受伤看不见了，发出一声嘶哑的咆哮！现场的人被吓坏了，马上报了警。警察闻讯赶到，为防止它伤人准备击毙它。 但海夫尔醒来后，冲泰米吹了声口哨，然后用亲切镇定的声音一遍遍地呼唤它的名字。既受惊又瞎了眼的泰米正焦躁不安地发狂，听到海夫尔的声音，它猛地转过头。迟疑了片刻，终于慢慢地，一瘸一拐地朝着海夫尔走来，海夫尔抚摸着狮子，带着它进了另一个笼子，一场危机就这样化解了。 事后海夫尔不禁泪如泉涌，并伸开双臂迎接这个对他无限信任的朋友。这件事后，大家相信了海夫尔。也相信了猛兽们，也开始对它们好起来，并且改变了残酷的训练方法。 还有一位少年16岁报名参加骑师训练班。报名的800多人中，最后被录取了7人，他是年龄最小、个子最矮的一个。此后训练极其艰苦，早晨5点起床，然后集体做俯卧撑、蹲马步，然后在马背上开始一天的训练；无论是烈日炎炎，还是狂风暴雨，一年365天，没有休息日。他知道，要成为一名优秀的骑师，光会骑马技术远远不够，还要有对马儿的情感投入，以及打心底里透出的呵护和爱惜，因为马的智商和人相近，它不仅能接受训导，还能学习模仿，与人交流感情。于是结束一天的训练后。其他同学累得只想睡觉，他却跑到马厩里，细心地给马儿进行护理，每天雷打不动给马匹量两次体温，洗澡，细心地擦干，而且还要陪马坐一会儿，给马捶一捶、揉一揉。自己才回宿舍休息。 他的马成了他的伙伴，每次训练、比赛都很配合，很肯帮他的忙，他也因此从见习骑师到正式骑师，本来要经过3年，赢得40场头马，而他仅仅用了1年。便赢得178场头马，提前晋级为正式骑师。 动物是这样，你把它当人看，你对它好，它会记着你的好；人更是这样，人是世界上最高等的动物，你对他的好，他会点滴记心中，会“滴水之恩，涌泉相报”。 版权声明：本文为博主转载文章，转载请注明出处点这]]></content>
      <tags>
        <tag>文章</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java学习之路-1]]></title>
    <url>%2F2016%2F08%2F26%2Fjava%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF-1%2F</url>
    <content type="text"><![CDATA[前言 java学习之路—–&gt;基础复习 内容 1.集合1.1 集合的类型和各自的特性---|Collection: 单列集合 ---|List: 有存储顺序, 可重复 ---|ArrayList: 数组实现, 查找快, 增删慢 由于是数组实现,在增和删的时候会牵扯到数组增容,以及拷贝元素.所以慢。 数组是可以直接按索引查找,所以查找时较快。 ---|LinkedList: 链表实现, 增删快, 查找慢 由于链表实现, 增加时只要让前一个元素记住自己就可以, 删除时让前一个元素记 住后一个元素, 后一个元素记住前一个元素. 这样的增删效率较高但查询时需要一 个一个的遍历, 所以效率较低 ---|Vector: 和ArrayList原理相同, 但线程安全, 效率略低 ---|Set: 无存储顺序, 不可重复 ---|HashSet: 线程不安全，存取速度快。底层是以哈希表实现的。 ---|TreeSet 红-黑树的数据结构，默认对元素进行自然排序（String）。如果在比较的时候两 个对象返回值为0，那么元素重复。 1.2 遍历集合遍历集合的几种方式 1. 使用迭代器Iterator的方式。 2. 使用增强for循环的方式。 3. 如果有下标，则可以使用下标的方式。 遍历数组 public static void main(String[] args) { // 遍历数组： String[] arr = new String[] { &quot;xx&quot;, &quot;yy&quot;, &quot;zz&quot; }; // 1，增强的for循环 for (String elt : arr) { System.out.println(elt); } // 2，下标的方式 for (int i = 0; i &lt; arr.length; i++) { System.out.println(arr[i]); } } 遍历List public static void main(String[] args) { // 遍历List： List&lt;String&gt; list = new ArrayList&lt;String&gt;(); list.add(&quot;aa&quot;); list.add(&quot;bb&quot;); list.add(&quot;cc&quot;); // 1，增强的for循环 for (String elt : list) { System.out.println(elt); } // 2，下标 for (int i = 0; i &lt; list.size(); i++) { System.out.println(list.get(i)); } // 3，迭代器 for (Iterator&lt;String&gt; iter = list.iterator(); iter.hasNext();){ String elt = iter.next(); System.out.println(elt); } } 遍历Set public static void main(String[] args) { // 遍历Set： Set&lt;String&gt; set = new HashSet&lt;String&gt;(); set.add(&quot;dd&quot;); set.add(&quot;ee&quot;); set.add(&quot;ff&quot;); // 1，增强的for循环 for (String elt : set) { System.out.println(elt); } // 2，迭代器 for(Iterator&lt;String&gt; iter = set.iterator(); iter.hasNext() ; ){ String elt = iter.next(); System.out.println(elt); } } 遍历Map public static void main(String[] args) { // 遍历Map： Map&lt;String, String&gt; map = new HashMap&lt;String, String&gt;(); map.put(&quot;aa&quot;, &quot;xx&quot;); map.put(&quot;bb&quot;, &quot;yy&quot;); map.put(&quot;cc&quot;, &quot;zz&quot;); // 1，增强的for循环（Entry集合） for (Entry&lt;String, String&gt; entry : map.entrySet()) { System.out.println(entry); } // 2，增强的for循环（Key集合） for(String key : map.keySet()){ System.out.println(key + &quot; = &quot; + map.get(key)); } // 3，遍历值的集合 for(String value : map.values()){ System.out.println(value); } } 2.泛型2.1 泛型出现原因存入的是特定的对象,取出的时候是Object对象,需要强制类型转换,可能诱发类型转换异常。无法控制存入的是什么类型的对象,取出对象的时候进行强转时可能诱发异常。而且在编译时期无法发现问题。 虽然可以再类型转换的时候通过if语句进行类型检查(instanceof),但是效率较低。(例如吃饭的时候,还需要判断米饭里有没有沙子,吃饭效率低)。可以通过给容器加限定的形式规定容器只能存储一种类型的对象。 就像给容器贴标签说明该容器中只能存储什么样类型的对象，所以在jdk5.0后出现了泛型。 2.2 泛型作用 将运行时的异常提前至编译时发生。 获取元素的时候无需强转类型，就避免了类型转换的异常问题 2.3 泛型使用细节细节一： 声明好泛型类型之后,集合中只能存放特定类型元素 public class Demo6 { public static void main(String[] args) { //创建一个存储字符串的list ArrayList&lt;String&gt; arr=new ArrayList&lt;String&gt;(); arr.add(&quot;gz&quot;); arr.add(&quot;itcast&quot;); //存储非字符串编译报错. arr.add(1); } } 细节二： 泛型类型必须是引用类型 public class Demo6 { public static void main(String[] args) { // 泛型类型必须是引用类型,也就是说集合不能存储基本数据类型 // ArrayList&lt;int&gt; arr2=new ArrayList&lt;int&gt;(); // 使用基本数据类型的包装类 ArrayList&lt;Integer&gt; arr2 = new ArrayList&lt;Integer&gt;(); } } 细节三: 使用泛型后取出元素不需要类型转换. public class Demo6 { public static void main(String[] args) { ArrayList&lt;String&gt; arr = new ArrayList&lt;String&gt;(); arr.add(&quot;gzitcast&quot;); arr.add(&quot;cditcast&quot;); arr.add(&quot;bjitcast&quot;); //使用泛型后取出元素不需要类型转换. String str=arr.get(0); System.out.println(); } } 创建对象的时候要指定泛型的具体类型 创建对象时可以不指定泛型的具体类型(和创建集合对象一眼)。默认是Object，例如我们使用集合存储元素的时候没有使用泛型就是那么参数的类型就是Object 类上面声明的泛型只能应用于非静态成员函数，如果静态函数需要使用泛型，那么需要在函数上独立声明。 如果建立对象后指定了泛型的具体类型，那么该对象操作方法时，这些方法只能操作一种数据类型。 所以既可以在类上的泛型声明，也可以在同时在该类的方法中声明泛型。 静态方法不可以使用类中定义的泛型 3.IO 输入流 输出流 说明 字节流 InputStream OutputStream 字节流是处理字节的（二进制） 字符流 Reader Writer 字符流是处理字符的 4.多线程4.1 启动线程方式 自定义的类继承Thread类。使用代码为new MyThread().start() 自定义的类实现Runnable接口。使用代码为new Thread(newMyRunnable()).start 4.2 代码实现private static int count = 100; public static void main(String[] args) { // 用继承Thread类的方式启动一个线程 new Thread() { public void run() { synchronized (StartThreadTest.class) { while (count &gt; 0) { count--; System.out.println(Thread.currentThread() + &quot;卖了一张票，还剩&quot; + count); } } } }.start(); // 用实现Runnable接口的方式启动一个线程 new Thread(new Runnable() { public void run() { synchronized (StartThreadTest.class) { while (count &gt; 0) { count--; System.out.println(Thread.currentThread() + &quot;卖了一张票，还剩&quot; + count); } } } }).start(); } 5.Junit5.1 Junit用途 目前方法如果需要测试，都要在main函数方法上调用 目前的结果需要我们人工对比 5.2 Junit细节 绿条表示通过，红条表示失败 在测试方法上用@Test 点击类测试，则测试所有类中的test方法；其他类似 @Test不能是静态的，且不能有形参 如果测试一个方法的时候需要准备测试的环境或者是清理测试的环境，可以使用@before/beforeclass @after/afterclass 5.3 Junit使用规范 一个类如果需要测试，则该类就应该对应一个测试类，测试类的命名方法为：测试类名+test 一个被测试的方法一般对应一个测试的方法，测试的方法的命名是：test+方法名 6.内省 开发框架时候，会把一些东西封装到对象中。 变态的反射 使用JAVA对象属性封装程序的数据 7.BeanUtils 解决问题：将对象的属性数据封装到对象中 好处 1&gt; BeanUtils设置属性的时候，如果属性书基本数据类型，BeanUtils会自动转回数据类型 2&gt; BeanUtils设置属性值得底层也是依赖SETHUO GET方法 3&gt; BeanUtils设置属性值，如果设置的属性是其他的引用类型的数据，需要注册一个类型转换器 操作步骤1&gt; 导入BeanUtils包2&gt; 导入LOGGING包 配置文件路径问题 版权声明：本文为博主原创文章，转载请注明出处KidSea]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MQTT协议及其在物联网中的应用]]></title>
    <url>%2F2016%2F08%2F25%2FMQTT%E5%8D%8F%E8%AE%AE%E5%8F%8A%E5%85%B6%E5%9C%A8%E7%89%A9%E8%81%94%E7%BD%91%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8%2F</url>
    <content type="text"><![CDATA[前言 MQTT协议及其在物联网中的应用 内容 原文链接：A Brief, but Practical Introduction to the MQTT Protocol and its Application to IoT作者：Ben Howes译者：孙薇责编：周建丁（zhoujd@csdn.net） MQTT （Message Queuing Telemetry Transport，消息队列遥测传输） 是一种标准化的发布/订阅消息传输协议，设计于1999年，最初是为了在卫星之类的物体上使用。它是一个非常轻量级的协议，由于对带宽需求很低，从而成为了 M2M 通信或物联网应用的理想选择，现在已经成为这类场景最常见的协议之一。 本文会对该协议及一些使用范例做以简介，虽然没打算写成 MQTT 的综合性参考指南，但会提供足够的信息，让开发人员了解到如何安装运行这一协议。如果想要更深入地了解，可以参考 HiveMQ 所发布的系列文章。 发布/订阅发布/订阅，通常也被成为 pub-sub 模式是 MQTT 的核心，除了基于同一个消息代理的发布者和订阅者之外，还有一些其它节点围绕着该消息代理呈星型拓扑分布。这个模型与标准的客户端/服务器迥然不同，一开始看似有些奇怪，但它提供的去耦能力在很多情况下都有巨大的优势。 客户端可以发布或订阅特定的主题（topic，有些类似信息主题），根据使用它们的消息代理来决定谁会收到信息。MQTT 的主题有特定的语法，使用斜杠（/）作为分隔符，整体呈层次结构，非常类似 URL 中的路径格式，因此厨房中的温度传感器也许会发布到类似“sensors/temperature/home/kitchen” 这样的主题。 我们看一个例子：想象一下有一个网络，将全世界的温度传感器连接起来，提供气象服务。所有这些传感器保持与某个消息代理中间件相连接，每隔10分钟报告一次当前的温度。他们基于自身位置按照下面的格式向特定主题发布信息： sensors/temperature/{country}/{city}/{street name} 那么在伦敦贝克街（BakerStreet）的某个传感器就会向“sensors/temperature/uk/london/baker_street”发布一条包含当前温度的信息。 MQTT 示例拓扑 气象服务需要保证历史温度数据库的数据最新，因此创建了订阅到 MQTT主题的数据库服务，数据库服务会在收到最新温度信息时发出提示。不过这里存在一个问题：数据库服务需要了解到全世界所有的温度传感器，而将每个传感器订阅到独立的主题会非常复杂，幸好 MQTT 有相应的解决方案：通配符（wildcards）。 通配符在 MQTT 中有两个可用的通配符，分别是+和#，+表示匹配单一层级中的任意主题，#表示匹配任意数量的层次。因此在全球温度数据库中可能会有订阅到 sensors/temperature/#的服务，它能从全世界的任何一个传感器接收温度读数。但如果英国政府想要在自己的温度服务中利用这些数据，只要订阅到sensors/temperature/uk/#，就可以限制范围，只接受英国的传感器读数。如果某个服务想要接收某个特定位置所有类型的传感器数据，可以使用类似这样的格式： sensors/+/uk/london/bakerstreet_ 正如你所见，这是一个极优秀的模块化系统，添加新的传感器与数据库只是小事一桩。而且该系统在性能方面也很优秀，MQTT消息代理可以高度并行化并采用事件驱动，从而使得单个消息代理可以轻易扩展到每秒处理数万条信息的级别。 服务质量（QoS）MQTT 的设计初衷是为了在不可靠的网络中运作良好，为不同的场景提供了三个级别的服务质量，允许客户端指定自己想要的可靠性级别。 QoS Level 0：至多一次这是最简单的级别，无需客户端确认，其可靠性与基础网络层 TCP/IP 一致。 QoS Level 1：至少一次，有可能重复确保至少向客户端发送一次信息，不过也可发送多次；在接收数据包时，需要客户端返回确认消息（ACK包）。这种方式常用于传递确保交付的信息，但开发人员必须确保其系统可以处理重复的数据包。 QoS Level 2：只有一次，确保消息只到达一次这是最不常见的服务质量级别，确保消息发送且仅发送一次。这种方法需要交换4个数据包，同时也会降低消息代理的性能。由于相对比较复杂，在MQTT 实现中通常会忽略这个级别，请确保在选择数据库或消息代理前检查这个问题。 在 MQTT 中的服务质量水平划分 “临终遗嘱”信息该协议提供了检测方式，利用KeepAlive机制在客户端异常断开时发现问题。因此当客户端电量耗尽、崩溃或者网络断开时，消息代理会采取相应措施。 客户端会向任意点的消息代理发送“临终遗嘱”（LWT）信息，当消息代理检测到客户端离线（连接并未关闭），就会发送保存在特定主题上的LWT信息，让其它客户端知道该节点已经意外离线。 安全性MQTT（及通常的物联网设备）的安全性是一个相当大的主题，之后我们会详加描述，不过在本文中仅涉及两个主要的安全性功能：身份验证与加密。 身份验证是通过在 MQTT连接包中发送用户名与密码来实现，几乎所有消息代理与客户端在实现时都支持这一功能。但由于信息太容易被拦截，为了避免，应当尽可能地使用安全传输层协议（TLS）。 协议本身未提供加密功能，但由于MQTT是在TCP上层运行的，我们可以很容易地利用TLS来提供加密连接。但这确实增加了发送与接收信息的计算复杂性，不但在约束系统中会造成问题，还会影响消息代理的性能。稍后我们会就这个问题进行更多讨论。 消息代理软件有许多不同方式实现的可用消息代理，最常见的系统包括： Mosquitto —— 这是最早在生产环境中可用的消息代理之一，以 C 语言编写，提供多种配置与高性能。 Mosca —— 以Node.js编写，可嵌入Node应用或以独立可执行文件的形式运行。由于配置简单并具有可扩展性，它也是我们最喜欢的消息代理，具有高性能的优点。 RSMB —— IBM对MQTT协议的实现，也是最不常用的选项之一，不过它是一个用C语言编写的成熟系统。 HiveMQ —— HiveMQ是一种相对较新的消息代理，面向企业环境，在博客上有很多关于 MQTT 不错的信息。 客户端库几乎包含了所有流行语言的客户端库，想要具体了解的话，Paho项目会是你的最佳选择。这个项目隶属于Eclipse，旨在提供各种语言尽可能多样化的 MQTT 客户端实现参考。这是个很好的资源，包含以C、Java、Python、Javascript等语言编写的可用客户端。 结论MQTT是一个理想的协议，它在物联网与M2M通信中的应用是无限的。如果你需要轻量级的消息传输系统，那么它会是很好的选择，而且在未来几年中很可能会流行起来。希望本文能帮助读者对 MQTT 做以了解。 版权声明：本文为博主转载文章，转载请注明出处CSDN社区]]></content>
      <tags>
        <tag>Iot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux之Shell命令]]></title>
    <url>%2F2016%2F08%2F25%2FLinux%E4%B9%8BShell%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[前言 这是我之前学习Linux基本操作时，所记录的笔记，希望对大家会有些帮助 内容 【1】shell内核、shell、文件系统、应用程序 【2】shell 脚本Shell命令的有序集合 【3】创建一个脚本文件1--- vi 1.sh 2--- chmod 777 1.sh 3--- ./1.sh rw- rw- r-- 110 110 100 6 6 4 111 111 111 7 7 7 【4】变量1--- 自定义变量 1.没有数据类型 2.赋值的时候等号两边不能有空格 3.使用 $ 获取变量里的内容 2--- 位置变量 命令行的位置参数。 位置参数从 ${10} 开始用花括号括起来 3--- 预定义变量 $@、$* 命令行所有的参数，除了第一个执行语句 $# 命令行所有参数的个数，除了第一条执行语句 $$ PID $? 只跟上一条shell命令有关；一般为上一条shell命令执行成功 ：$? = 0 【5】readread从标准输入读入一行 【6】expr1--- `expr $A + $B` 2--- + - \* / % \( \) 3--- 运算符两边留有空格 【7】test$?:满足条件结果为：0 不满足条件：1 1--- 字符串 = ！= -z -n 2--- 整数 -eq -ne -lt -le -gt -ge -a:与 -o：或 3--- 文件 1&gt;测文件的类型 b c d - l s p linux -b -c -d -f -L -S -p shell脚本test 2&gt;测文件的权限 -r 测一个文件是否具有可读权限 -w 测一个文件是否具有可写权限 -x 测一个文件是否具有可执行权限 3&gt;其它 -e 测试一个文件是否存在 -s 测试name 文件是否存在且其长度不为0 -nt 测试文件f1 是否比文件f2 更新 -ot 测试文件f1 是否比文件f2 更旧 【8】if if 表达式 then 命令表 fi ***************************** if 表达式 then 命令表 else fi 【9】exit用于结束程序 【10】switchcase 变量 in 模式1) 命令表1 ；； 模式2 | 模式3) 命令表2 ；； *) 命令表n ；； esac 【11】循环for 变量名 in 单词表 do 命令表 done 1--- for循环几次跟单词表里单词的个数有关 2--- 单词表里的单词有几个，就产生几次提取和赋值的操作，然后依次执行命令表里的 内容 【12】``用法`date` 将ls命令的执行结果提取出来 【13】while循环while 命令或表达式 do 命令表 done 【14】break与continuebreak //结束整个循环 continue //跳出本次循环，进入下一循环 【15】函数1--- 函数的调用 直接写函数名：fun 2--- 函数的传参 fun 10 20 3--- 函数的返回值 只能用$?获取 版权声明：本文为博主原创文章，转载请注明出处KidSea]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux之基本操作-2]]></title>
    <url>%2F2016%2F08%2F25%2FLinux%E4%B9%8B%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C-2%2F</url>
    <content type="text"><![CDATA[前言 这是我之前学习Linux基本操作时，所记录的笔记，希望对大家会有些帮助 内容 【1】history1--- history &gt;&gt; 1.txt 2--- echo $HISTSIZE 3---修改历史纪录 1&gt; HISTSIZE = 500 2&gt; cd sudo vi .bashrc source .bashrc 【2】wc用于测文件的命令 wc -l filename wc -w filename wc -c filename 【3】管道第一个命令的输出将作为第二个命令的输入 命令 | 命令 【4】重定向输出&gt;&gt; 以追加的模式 &gt; 以新建的模式重定向输出 命令 &gt; 文件名 【5】cat将一个文件内容打印到终端上 cat filename 【6】df -aTh查看磁盘使用情况 【7】一切皆文件的思想标准输入 0 标准输出 1 标准出错 2 【8】用户操作//关机 sudo shutdown -h now sudo shutdown -h 12：00 sudo shutdown -h +30 //重启 sudo shutdown -r +30 //取消关机 sudo shutdown -c 【9】datedate date -s 月/日/年/ date -s 13：00：00 【10】top动态查看进程 ps -aux 版权声明：本文为博主原创文章，转载请注明出处KidSea]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[优秀的程序员就像艺术家？]]></title>
    <url>%2F2016%2F08%2F24%2F%E4%BC%98%E7%A7%80%E7%9A%84%E7%A8%8B%E5%BA%8F%E5%91%98%E5%B0%B1%E5%83%8F%E8%89%BA%E6%9C%AF%E5%AE%B6%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[前言 优秀的程序员真的就像艺术家？ 内容 优秀的代码能不能算艺术品？软件工艺这一理论是否有点矫枉过正？怎么样才算是一名真正“优秀”的程序员？ 让我们先从一个问题引入话题。假设你雇了一个水管工替换地下室里已经老化的旧水管，在整个过程中，这家伙一个劲地给你灌输这些水管是有多么多么的有艺术美感。 “哇哦，看看这根管子弯曲的角度，它与墙壁对齐得是这么的漂亮！简直就是艺术品啊！”你会怎么看这个水管工？ 写代码也是如此。再也没有比一个开发人员非要将他的代码写成艺术的模式更糟的了。上述比喻来自一篇广受好评的文章《programming is not a craft》，其作者是Dan North，“Agile troublemaker”和BDD方法的创始人。 软件艺术该理论的作者是 Kevlin Henney、Bob Martin、Corey Haines和Glenn Vanderburg，以下就是软件艺术的要领。 不仅得能正常运作，还应该精心制作 不仅可以应对变化，还能稳步增值 有良好的个体交流，以及专业人士组成的社区 和谐的客户合作关系，富有成效的伙伴关系 而现在的问题是，很多软件开发人员往往会因为太过自大反而不能很好地完成软件项目。因为自大会让他们将软件艺术捧得很高，North 说。Web服务和J2EE的项目就是这方面的例子，该项目的失败有很大一部分归咎于将软件艺术放到了过于崇高的地位。 优秀的程序员你或许早就在一些小的IT项目中就领略过上述问题的存在了。如果有开发人员坚持使用某种特定的美学技术而不愿意务实的话，那么我敢肯定他已经被所谓的“软件艺术”洗脑了。 好的代码应该是高效的代码，而不是因为它的美观。不管它是什么样子，只要它可靠、高效就成。换言之就是不管黑猫白猫，能抓老鼠的就是好猫。也可以归结为理解和实现简单流程的能力。 “一个经验丰富的编程团队完全可以在很短的时间内拿出惊人的业务成绩。只有真正的专业人士和真正的软件匠手才能在毫无头绪一团糟中，例如各种企业软件，发现被抛弃的优雅与朴素。”——Dan North 但可悲的是，即使是优秀的程序员也经常会忘记何谓优秀软件的核心功能——过分重视所谓的软件艺术往往是罪魁祸首。 “软件从业者——具有讽刺意味的是，尤其是一些优秀人才——却经常会犯此错误。他们爱上了软件本身，然后觉得自己已经化身成了软件艺术工匠。”——Dan North 程序员的才华 全文这个辩论是基于一个问题展开的，这个问题就是：软件工程是否是艺术形式的一种？ 据说性能和效率的比重在软件行业里已经有所下降，而怎么样才能成为一名优秀的开发人员却依然没有达成共识。“伟大的程序员，只需要几个小时或者几天就能完成普通程序员需要数周或者数月才能搞定的任务。”Dan North坚持这么认为。 “作为买家，你难道不想知道你的系统是由大师级工匠还是临时工做的吗？你付了钱，就应该有这个知情权。所以如何辨别两者就很重要了。”——Dan North North也承认，好不好看并不能让我们正确区分两者。任何开发人员都可以自诩为软件匠手，也能做到对何为“软件架构之美”侃侃而谈。North诚挚地希望能有有识之士重新编写软件艺术的概念，这是最基础的理念问题。 站在背后的代码我们并不在乎水管长啥样——反正是埋在里面的。这同样适用于软件。无论是客户还是用户，都只关心代码是否能工作以及页面看上去ok就行。 “同样的，我只想请专家电工来给我的房子布线而不是一个滥竽充数的家伙，我也只想要专业程序员来写代码，” North郑重其事地说，“我最讨厌的就是，一个自命不凡自以为是的水管工一刻不停地谈论他优雅美丽富有艺术感的水管。” 友情链接：点这 英文原文：The art of good programming. 版权声明：本文为博主转载文章，转载请注明出处图灵社区]]></content>
      <tags>
        <tag>趣事</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C语言学习-基础-5]]></title>
    <url>%2F2016%2F08%2F24%2FC%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0-%E5%9F%BA%E7%A1%80-5%2F</url>
    <content type="text"><![CDATA[前言 C语言基础笔记之五，函数和结构体. 内容 【1】函数命名格式&lt;数据类型&gt; &lt;函数名称&gt;( &lt;形式参数说明&gt; ) { 语句序列； return[(&lt;表达式&gt;)]; } 【2】 main函数int main （） { return 0； } argc：命令行参数的个数 argv[]:数组，元素：指针类型 char * $ 命令行 【3】函数的声明两种方式 1--- 在main函数之前声明并编写函数体 2--- 在main函数之前声明，在main函数后编写函数体(推荐) 【4】return1--- 返回一个值 2--- 结束函数的功能 3--- void 可以使用return； 4--- 一个程序中可以有多条return语句，但只执行一条 【5】函数的传参1--- 复制型传参 2--- 地址传参 3--- 传递一个地址量时，用指针变量去承接 【6】指针函数本质：函数，返回值是一个指针 char* string_cpy(char* str1,char* str2); 【7】函数的指针本质：指针，指向一个函数名的地址 char (*p)fun(); 【7】结构体struct 结构体类型名 { 数据类型 成员名1； 数据类型 成员名2； ： 数据类型 成员名n； }s1； //s1: 全局变量 struct stu s2 ； //s2: 局部变量 【8】访问成员变量名.成员名 【9】初始化struct 结构体名 变量名={初始数据表}； struct 结构体名 { 成员列表； }变量名={初始数据表}； 【10】无名结构体1--- 没有结构体类型名 2--- 不可以定义局部变量 【11】结构体嵌套1--- 成员所属的数据类型是 结构体类型 2--- 内部的结构体通常定义为无名结构体 【12】结构体数组本质：数组，元素：结构体类型 【13】结构体指针本质是指针，指向一个结构体数据 版权声明：本文为博主原创文章，转载请注明出处KidSea]]></content>
      <tags>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C语言学习-基础-4]]></title>
    <url>%2F2016%2F08%2F24%2FC%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0-%E5%9F%BA%E7%A1%80-4%2F</url>
    <content type="text"><![CDATA[前言 C语言基础笔记之四，指针. 内容 【1】指针概述1--- 指针变量 用于存放地址量的变量 2--- 指针 指针变量、地址常量通称为指针 3--- * 1--- 定义 2--- 指针解引用：通过地址获取其内容 4--- 指针加减：加减的是单位长度 单位长度：指针所指向的数据所占有的字节大小 【2】数组a[i] &lt;===&gt; *(a+i) *(p+i) &lt;===&gt; p[i] []:指针加上单位长度后，取*运算 a:地址常量 p：指针变量 【3】atoi功能：将数值形式的字符串转换成整形数据 头文：&lt;stdlib.h&gt; 参数：char * 返值：int 特点：遇到非数值形式的数据停止转换 【4】二维数组int a[3][4] 1--- a：行地址，加一移动一行 a[0]：列地址，加一移动一列 2--- a[i][j] &lt;===&gt; *(a[i]+j) &lt;===&gt; *(*(a+i)+j) 【5】sizeof指针占四字节空间，与存储类型的数据没有关系 【6】指针数组int *p[3]; 1--- 本质：数组，元素是指针类型 2--- 三个元素：p[0]、p[1]、p[2] 【7】数组指针int a[4][3]; int （*p）[3]; 1-- p[i][j] &lt;===&gt; *(p[i]+j) &lt;===&gt; *(*(p+i)+j) a[i][j] &lt;===&gt; *(a[i]+j) &lt;===&gt; *(*(a+i)+j) 2-- p:指针变量，a：地址常量 【8】&amp;与*互为逆运算 【9】二级指针用于存放一级指针的地址 int a = 10; int *p = &amp;a; int **q = &amp;p; 【10】constconst int * p； 常量化*p; int * const p； 常量化p; 【11】void *泛型指针 【12】NULLint *p = NULL； 防止野指针的形成 版权声明：本文为博主原创文章，转载请注明出处KidSea]]></content>
      <tags>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C语言学习-基础-3]]></title>
    <url>%2F2016%2F08%2F24%2FC%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0-%E5%9F%BA%E7%A1%80-3%2F</url>
    <content type="text"><![CDATA[前言 C语言基础笔记之三，数组. 内容 【1】数组多个数据类型相同的数据集合。 1--- 有数组一定有元素 2--- 数组元素的类型相同 3--- 元素存储是连续的 【2】数组的定义1--- 常量 int a[3]; 2--- 定义宏 #define N 5 int b[N]; 3--- 变量（不可以初始化） int i = 3; int c[i]; 【3】数组的初始化1--- 全部赋值 2--- 部分赋值，没有赋值的部分默认初始化为0 3--- 不赋值，元素为随机值（static修饰的除外） 4--- int a[] = {1,2,3,4}; &lt;===&gt; int a[4]; 【4】遍历使用循环语句遍历 int a[10] = {1,1,2,3,45,34,5323,341,432}; int i = 0; for(i=0;i&lt;10;i++) { printf(&quot;%d&quot;,a[i]); } 【5】数组名int a[N] = {0}; 1--- 代表数组首元素的地址 2--- N * sizeof（int）； sizeof（a）； N = sizeof(a) / sizeof（int）； 【6】冒泡排序（1）比较第一个数与第二个数，若为逆序a[0]&gt;a[1]，则交换；然后比较第二个数与第三个数；依次类推，直至第n-1个数和第n个数比较为止——第一趟冒泡排序，结果最大的数被安置在最后一个元素位置上 （2）对前n-1个数进行第二趟冒泡排序，结果使次大的数被安置在第n-1个元素位置 （3）重复上述过程，共经过n-1趟冒泡排序后，排序结束 【7】二维数组int a[N][M]； 1--- N：代表N行，M：代表M列 2--- a：数组名，首元素的地址 3--- a[0]、a[1]、a[2] 代表每一行的首地址 4--- 行数可以省略，列项不可以省略。 int a[][3] = {0，1，2，3}； 《==》 int a[2][3]; 【8】字符型数组1--- char a[8] = {&apos;A&apos;}; char b[9] = &quot;hello&quot;; char c[ ] = &quot;world&quot;; 2--- puts(a); gets(a); 【9】strcpy格式：strcpy(字符数组1,字符串2) 头文：&lt;string.h&gt; 功能：将字符串2，拷贝到字符数组1中去 返值：返回字符数组1的首地址 说明：字符数组1必须足够大 ?拷贝时‘\0’一同拷贝 【10】strcat格式：strcat(字符数组1,字符数组2) 头文：&lt;string.h&gt; 功能：把字符数组2连到字符数组1后面 返值：返回字符数组1的首地址 说明：字符数组1必须足够大 新串最后加‘\0’ 【11】strlen格式：strlen(字符数组) 功能：计算字符串长度 返值：返回字符串实际长度，不包括‘\0’在内 【12】strcmp格式：strcmp(字符串1,字符串2) 功能：比较两个字符串 比较规则：对两串从左向右逐个字符比较（ASCII码），直到遇到不同字符或‘\0’为止 返值：返回int型整数， a. 若字符串1 &lt; 字符串2， 返回负数 b. 若字符串1 &gt; 字符串2， 返回正数 c. 若字符串1 == 字符串2，返回0 说明：字符串比较不能用“==”,必须用strcmp 版权声明：本文为博主原创文章，转载请注明出处KidSea]]></content>
      <tags>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C语言学习-基础-2]]></title>
    <url>%2F2016%2F08%2F24%2FC%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0-%E5%9F%BA%E7%A1%80-2%2F</url>
    <content type="text"><![CDATA[前言 C语言基础笔记之二，常用的一些输入输出函数以及控制语句. 内容 【1】存储模型&lt;存储类型&gt; &lt;数据类型 &gt; &lt;变量名&gt; ； 1--- 生命期：与程序同步，与函数同步 2--- 作用域 auto 默认存储类型 static 1&gt; 与程序同步 2&gt; 默认初始化为0 3&gt; 只初始化一次 register 1&gt; 数据存储在寄存器中 2&gt; 运算的速度快 extern 外部声明 【2】putchar格式: putchar( c ) 参数: c为字符常量、变量或表达式 功能：把字符c输出到显示器上 返值：正常，输出字符的的ASCII值； 【3】getchar格式: getchar( ) 功能：从键盘读一字符 返值：正常，返回读取的代码值；出错,返回EOF(-1) 1--- 可以用于垃圾字符的回收。 【4】printf格式：printf(“格式控制串”，输出表) 功能：按指定格式向显示器输出数据 返值：正常，返回输出字节数；出错，返回EOF(-1） 1--- 输出的数据控制 d o x u 整数 c 字符 f e 浮点型、指数 s 字符串。传递一个地址量，字符串常量当成地址进行数据处理 p 打印数据的地址 %% 打印% 2--- 输出的格式控制 正整数：控制数据显示的宽度 - ：使数据左对齐 + ：正数显示符号 0 ：空位用0补全 .3 ：控制浮点型数据的精度，控制字符串输出的字符数 3--- 返回值 为输出字符的个数（字节数） 【5】scanf格式：scanf(“格式控制串”，地址表） 功能：按指定格式从键盘读入数据，存入地址表指定存储单元中,并按回车键结束 返值：正常，返回成功获取数据的个数 d o x 整形数据 c 字符 f 浮点型 s [^\n] 字符串 【6】puts格式：puts(字符数组) 功能：向显示器输出字符串（输出完，换行） 说明：字符数组必须以‘\0’结束 反值：输出字符的个数 1--- 自带换行 2--- 遇到&apos;\0&apos;结束输出 3--- 数组名代表数组首元素的地址 【7】gets格式：gets(字符数组) 功能：从键盘输入一以回车结束的字符串放入字符数组中，并自动加‘\0’ 说明：输入串长度应小于字符数组维数 1--- 只以‘\n’作为字符串的结束标志 2--- 会在字符串末尾主动加一个‘\0’ 【8】数学函数double sqrt（double）； 1--- 头文件：&lt;math.h&gt; 2--- 功能 ：开方 3--- gcc 1.c -lm //链接库操作linux下编译 ./a.out 【9】ifif(表达式1) {语句块1} else if(表达式2） {语句块3} else {语句块2} 1--- else只跟上一个相邻的if有关 【10】switch语句switch (表达式) { case 常量表达式1:语句块1；break; case 常量表达式2:语句块2; break; …. case 常量表达式n:语句块n; break; default :语句块n+1 } 1--- 表达式的结果：整形，字符型 2--- case语句后的表达式必须是常量 【11】gotogoto 标识符；（很少用） 【12】while循环while（条件表达式） { } 1--- 表达式为真时执行循环体里的内容，为假立刻跳出while循环 【13】for循环for(expression1； expression2； expression3) { statements; } 1--- expression1：最先执行，只执行一次，循环变量的赋值操作 2--- expression2：控制循环的条件， 3--- expression3：更改循环变量 版权声明：本文为博主原创文章，转载请注明出处KidSea]]></content>
      <tags>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[安卓学习资料]]></title>
    <url>%2F2016%2F08%2F23%2F%E5%AE%89%E5%8D%93%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99%2F</url>
    <content type="text"><![CDATA[前言 上传一些自己学习安卓时相关的资料，有需要的伙伴可以自己查看 内容 安卓视频资料 黑马程序员74期：itheima 密码： go5z 传智Java33期：itcast 密码: 8a0i 安卓学习笔记 谷歌官方文档翻译篇：google 黑马笔记note 密码: rfwv 安卓开源社区 CSDN安卓社区CSDN 安卓BUSBus 开源中国os-china 版权声明：本文为博主原创文章，转载请注明出处KidSea]]></content>
      <tags>
        <tag>安卓</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux之基本操作-1]]></title>
    <url>%2F2016%2F08%2F23%2FLinux%E4%B9%8B%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C-1%2F</url>
    <content type="text"><![CDATA[前言 这是我之前学习Linux基本操作时，所记录的笔记，希望对大家会有些帮助 内容 【1】打开终端1--- ctrl + alt + t 2--- ctrl + shift + t ctrl + shift + n //在已打开终端基础上使用 【2】目录标识linux @ ubuntu: ~ $ 用户名 主机名 路径 ~ //家目录，主目录 &lt;==&gt; /home/linux/ / //根目录，一切文件的起源 $ //普通用户命令提示符 # //超级用户命令提示符 【3】susu 用户名 //切换用户 root //超级用户 exit //退出当前用户 【4】路径切换.. //上一级路径 . //当前路径 【5】ls用于显示当前路径下所有文件 ls ls -l //以列表的形式，显示文件的详细信息 【6】文件的信息文件类型（7种） bcd-lsp linux：一切皆文件的思想 b 块设备文件 c 字符设备文件 d 目录 - 普通文件 l 链接文件 s 套接字文件 p 管道文件 文件的权限 r 可读权限 w 可写权限 x 可执行权限 - 没有该权限 【7】cdcd .. //切换到上一级目录 cd ~ //切换到家目录 cd //直接切换到家目录 cd / //直接切换到跟目录 cd - //切换到上一次路径 【8】mkdirmkdir dir //创建目录 rmdir dir //删除空目录 rm dir -rf //删除目录 rm filename //删除文件 【10】清屏ctrl + l clear 【11】路径绝对路径：从根目录开始，当前文件所在的位置 相对路径：从当前目录到想要到的位置(. 和 ..) 【12】touch1--- 用于创建文件 touch 1.c 2--- 更新文件的时间戳（文件名已存在） 【13】echo1--- 向终端打印字符串 echo “hello” echo hello 【14】vim文本编辑器1--- 进入编辑器 vi filename 2--- 进入输入模式 i //从光标所在位置前面开始插入 a //从光标所在位置后面开始新增 A //从光标所在行最后面的地方开始新增 I //从光标所在行最前面的地方开始新增 o //在光标所在列下新增一列并进入输入模式 O //在光标所在列上方新增一列并进入输入模式 3--- 命令模式 Esc 进入命令模式 1&gt; yy 复制 2&gt; p 粘贴 3&gt; dd 剪切 4&gt; 2yy 复制两行 5&gt; 5dd 剪切5行 6&gt; u 撤销 7&gt; ctrl + r 反撤销 8&gt; gg 文本的第一行 9&gt; G 文本的最后一行 4--- 底行模式 Esc ：进入底行模式 1&gt; w 保存 2&gt; w! 强制保存 3&gt; q 退出 4&gt; q! 强制退出 5&gt; wq 保存退出 6&gt; wqa 全部保存退出 7&gt; vsp filename //左右分屏显示文件 8&gt; sp filename //上下分屏显示文件 9&gt; %s/chong/Chong/g //修改文件特定的字符串 【15】cat1--- cat filename 2--- 将文件的内容打印到终端上 【16】cp1--- cp filename 2--- 文件的拷贝 【17】mv1--- mv filename .. mv [文件名] [路径] 2--- 用于文件的移动 【18】编译C文件1--- vi hello.c //建立.c文件 main + Tab 2--- gcc hello.c //编译源文件 a.out 3--- ./a.out //执行可执行文件 【19】Gcc1--- gcc hello.c -o hello //指定输出的文件名 2--- 四步完整的编译流程 1&gt; 预处理：主要进行宏替换以及头文件的包含展开 gcc -E Hello.c -o Hello.i 2&gt; 编译：编译生成汇编文件，会检查语法是否有错误 gcc -S Hello.i -o Hello.s 3&gt; 汇编：将汇编文件编译生成目标文件(二进制文件) gcc -c Hello.s -o Hello.o 4&gt; 链接：链接库函数，生成可执行文件 gcc Hello.o -o Hello 3--- 两步操作 1&gt; gcc -c hello.c -o hello.o 2&gt; gcc hello.o -o hello 【20】字符表示字符：使用单引号括起来的 【21】ASCII1--- man ASCII //查看ASCII码 2--- putchar(67); //向终端打印一个字符 putchar(&apos;B&apos;); 3--- 10 ‘\n&apos; 32 ‘空格’ 65-90 ‘A’ - ‘Z’ 97-122 ‘a’ - ‘z’ 48-57 ‘0’ - ‘9’ 大写字符与小写字符相差32 【22】词法符号1--- 关键字 2--- 命名规则 1) 标识符由一个或多个字母、数字或下划线组成 2）标识符的第一个字符必须是字母或下划线 3）标识符不能与任何关键字相同 【23】代码跟踪调试1&gt; __FILE__ //代码所在文件 2&gt; __LINE__ //代码所在行 3&gt; __FUNCTION__ //代码所在函数 版权声明：本文为博主原创文章，转载请注明出处KidSea]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScrip发展史]]></title>
    <url>%2F2016%2F08%2F23%2FJavaScrip%E5%8F%91%E5%B1%95%E5%8F%B2%2F</url>
    <content type="text"><![CDATA[前言 最近正在学JAVAEE，了解了一些Javascrip的发展，所以给大家分享一个Javascrip趣事 发展史 为什么会有Js? 1994年之前，用户使用浏览器没有交互提醒功能，用户提交的表单只能到服务器验证，那时候网速只有7-8Kb/s，每次提交都可能要花上很多时间，用户体验特别差，所以当时的微软跟网景（火狐的前身，刚成立）等公司看到了商机。虽然是商机，但是由于盖茨认为未来是视窗的世界（PC桌面应用），因此没有投入开发，而去全力开发Windows,只有网景对其进行开发。 网景与微软的故事 1995年网景推出了一款浏览器（导航者）和liveScript(校验功能)，非常受欢迎，但是还不是很满意，于是和sun公司合作，借用了java的名字，把liveScirpt改名成javascript。鼎盛时期网景大概占据了浏览器市场的70%市场份额，并且上市，股价一律飙升。 这时候盖茨知错了，于是找网景的老大的谈判，要求合作，但是网景不同意这个提议。于是微软财大气粗，花了一年投了20亿美元去开发Jscript脚本语言（20亿用于挖工程师、代码什么的、捆绑销售+免费），而当时一款浏览器使用需要45美元，所以很快98年网景就支撑不住，被美国在线的公司收购，于03年宣布破产，因此又一家优秀的公司被微软搞垮。 公司被不正当搞垮，网景的公司肯定不高兴，于是上告微软，但是迟迟告不下来，直到快要破产的时候，微软才宣布赔款，大约花了几亿美金。当然网景员工肯定不会罢休，于是拿出2千万美金成立了一个基金会（Mozilla ）谋智以及把浏览器的源代码全部公开，目的就是为了对抗微软。也因此，到了最后谋智基金会开发出火狐浏览器，至此，这个故事就结束了。 JavaScript标准 1997年欧洲的计算机协议（ECMA）组织出来给javascript规定协议。 ECMAScirpt(规范了基本的语法而已) BOM （浏览器对象模型） DOM (文档对象模型) JavaScript特点 跨平台 安全性。 （javascript的代码不能直接访问硬盘的内容） JavaScript与Java区别 javascript是属于网景公司产品， java是sun公司的产品。 javascript是基于对象的语言，java是面向对象的语言。 javascript是解释型语言，java是解释、编译型语言。 javascript是弱类型语言， java 是强类型语言。 java中声明变量 的时候必须要明确该变量的数据类型。 javascript声明变量不需要明确是何种数据类型，任何的变量都是使用一个关键字var去声明即可。 版权声明：本文为博主原创文章，转载请注明出处KidSea]]></content>
      <tags>
        <tag>趣事</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C语言学习-基础-1]]></title>
    <url>%2F2016%2F08%2F23%2FC%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[前言 这是C语言的一些笔记，我会陆续上传到博客，希望对大家的学习以及复习有些帮助. 内容 【1】定义变量数据类型 变量名； 【2】bool#include &lt;stdbool.h&gt; 【3】char1--- 占1个字节 2--- signed char a； -128 ~ 127 0000 0000 0 0111 1111 127 1111 1111 -127 1000 0000 -128 3--- unsigned char b； 0~255 【4】数据的存储存储时： 源码 反码 补码 正数 0000 0101 0000 0101 0000 0101 char a = 5； 负数 1000 0101 1111 1010 1111 1011 char b = -5； 反码：符号位不变，其它位取反 补码：反码加一 读取时： 补码 反码 源码 【5】char c = 129； （存储）因为是正数，源码、反码、补码相同 源码：1000 0001 反码：1000 0001 补码：1000 0001 （读取）因为是signed类型，最高位为符号位 补码：1000 0001 反码：1000 0000 补码：1111 1111 （-127） unsigned char d = -1； （存储） 源码：1000 0001 反码：1111 1110 补码：1111 1111 （读取）因为是unsigned类型，都是正数 补码：1111 1111 反码：1111 1111 源码：1111 1111（255） 【6】整形数据1--- int 占4个字节 2--- short 占2个字节 3--- long 占4字节（32位系统） 【7】浮点型数据1--- float 1&gt; 12.45 2&gt; 15e-3 《==》 15*10^-3 3&gt; 占4字节 2--- double 1&gt; 占8字节 【8】printf%d 整形 %c 字符型&apos;A&apos; %s 字符串 %f 浮点型 【9】常量1--- 整数形式 34 034 0x34 2--- 浮点型 23.34 3--- 指数型 13e+5 《==》 13*10^5 4--- 字符型 ‘A’ 5--- 字符串常量 “hello” &quot;A&quot; //字符串以‘\0’作为结束标志 6--- 定义宏 1--- #define N 5 2--- 对一个常量进行命名 【10】强制类型转换float a = 32， b = 45； printf（“%d\n”,（int)(a+b）); 【11】运算符1--- 算数运算符 + - * / %（参与运算必须是整形数据） ++(自增) --（自减） 2--- 关系运算符 1. 结果只有两个：1 或 0 2. &gt; &gt;= &lt; &lt;= == != 3--- 逻辑运算符 1. 结果只有两个：1 或 0 2. 短路原则：当一个等式可以决定整个等式的结果，就不去执行其它运算 &amp;&amp; 与：一假则假 || 或：一真则真 ！ 非 4--- 位运算符 1&gt; 取反 ~ 2&gt; 位与 &amp; 3&gt; 位或 | 4&gt; 异或 ^ 相同为0， 不同为1 b 0000 0101 c 0000 0011 —————————— d 0000 0110 5&gt; 位右移 d &gt;&gt; 1 //向右移动1位 d / 2^n 位左移 d &lt;&lt; 2 //向左移动2位 d * 2^n 5--- 复合运算符 算数运算符、位运算符 【12】三步运算,完成数据交换a ^= b; b ^= a; a ^= b; 1--- 参与运算的是变量 2--- 针对于基本数据类型 3--- 变量需要交替互换 【13】条件运算符1--- &lt;表达式1&gt; ? &lt;表达式2&gt; : &lt;表达式3&gt; 2--- 表达式1为真，执行表达式2； 表达式1为假，执行表达式3； ###【14】逗号表达式 逗号表达式的结果与最后一个表达式有关 【15】sizeof求一个数据或类型占用空间的大小，以字节为单位 【16】优先级1 （） 2 ++ -- ~ ！ 从右向左 4 * / % 5 + - 关系运算符 位运算 逻辑运算 赋值运算 从右向左 ， 【17】存储模型&lt;存储类型&gt; &lt;数据类型 &gt; &lt;变量名&gt; ； 1--- 生命期：与程序同步，与函数同步 2--- 作用域 auto 默认存储类型 static 1&gt; 与程序同步 2&gt; 默认初始化为0 3&gt; 只初始化一次 版权声明：本文为博主原创文章，转载请注明出处KidSea]]></content>
      <tags>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[my new post]]></title>
    <url>%2F2016%2F08%2F21%2Fmy-new-post%2F</url>
    <content type="text"><![CDATA[关于博客 很早之前，就想做一个博客，可是一直没去实施 最近花了一点时间，终于把它搭建好了 这是我通过网上学习使用Hexo与Github搭建的一个博客网站 以后我会不定期发布一些自己的学习经历以及物联网相关的资讯 谢谢大家的关注]]></content>
      <tags>
        <tag>help</tag>
      </tags>
  </entry>
</search>
